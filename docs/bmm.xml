<?xml version="1.0" encoding="UTF-8"?>
<indexing>
 <object alt="" name="Image1" object_type="graphic"/>
 <object alt="" name="Image2" object_type="graphic"/>
 <object alt="" name="Image3" object_type="graphic"/>
 <object alt="" name="Image4" object_type="graphic"/>
 <object alt="" name="Image5" object_type="graphic"/>
 <object alt="" name="Image6" object_type="graphic"/>
 <object alt="" name="Image7" object_type="graphic"/>
 <object alt="" name="Image8" object_type="graphic"/>
 <object alt="" name="Image9" object_type="graphic"/>
 <object alt="" name="Image10" object_type="graphic"/>
 <object alt="" name="Image11" object_type="graphic"/>
 <object alt="" name="Image12" object_type="graphic"/>
 <object alt="" name="Image13" object_type="graphic"/>
 <object alt="" name="Image14" object_type="graphic"/>
 <object alt="" name="Image15" object_type="graphic"/>
 <object alt="" name="Image16" object_type="graphic"/>
 <object alt="" name="Image17" object_type="graphic"/>
 <object alt="" name="Image18" object_type="graphic"/>
 <object alt="" name="Image19" object_type="graphic"/>
 <object alt="" name="Image20" object_type="graphic"/>
 <object alt="" name="Image21" object_type="graphic"/>
 <object alt="" name="Image22" object_type="graphic"/>
 <object alt="" name="Image23" object_type="graphic"/>
 <object alt="" name="Image24" object_type="graphic"/>
 <object alt="" name="Image25" object_type="graphic"/>
 <object alt="" name="Image26" object_type="graphic"/>
 <object alt="" name="Image27" object_type="graphic"/>
 <object alt="" name="Image28" object_type="graphic"/>
 <object alt="" name="Image29" object_type="graphic"/>
 <object alt="" name="Image30" object_type="graphic"/>
 <object alt="" name="Image31" object_type="graphic"/>
 <object alt="" name="Image32" object_type="graphic"/>
 <object alt="" name="Image33" object_type="graphic"/>
 <object alt="" name="Image34" object_type="graphic"/>
 <object alt="" name="Image35" object_type="graphic"/>
 <object alt="" name="Image36" object_type="graphic"/>
 <object alt="" name="Image37" object_type="graphic"/>
 <object alt="" name="Image38" object_type="graphic"/>
 <object alt="" name="Image39" object_type="graphic"/>
 <object alt="" name="Image40" object_type="graphic"/>
 <object alt="" name="Image41" object_type="graphic"/>
 <object alt="" name="Image42" object_type="graphic"/>
 <object alt="" name="Image43" object_type="graphic"/>
 <object alt="" name="Image44" object_type="graphic"/>
 <object alt="" name="Image45" object_type="graphic"/>
 <object alt="" name="Image46" object_type="graphic"/>
 <object alt="" name="Image47" object_type="graphic"/>
 <object alt="" name="Image48" object_type="graphic"/>
 <object alt="" name="Image49" object_type="graphic"/>
 <object alt="" name="Image50" object_type="graphic"/>
 <object alt="" name="Image51" object_type="graphic"/>
 <object alt="" name="Image52" object_type="graphic"/>
 <object alt="" name="Image53" object_type="graphic"/>
 <object index="168" name="header" object_type="section"/>
 <paragraph index="169" node_type="writer" parent_index="168">￹</paragraph>
 <object index="170" name="toc" object_type="section"/>
 <object index="172" name="toctitle" object_type="section"/>
 <paragraph index="173" node_type="writer" parent_index="172">Table of Contents</paragraph>
 <paragraph index="175" node_type="writer" parent_index="170">Basic Meta-Model (BMM) </paragraph>
 <paragraph index="176" node_type="writer" parent_index="170">Amendment Record </paragraph>
 <paragraph index="177" node_type="writer" parent_index="170">Acknowledgements </paragraph>
 <paragraph index="178" node_type="writer" parent_index="170">Primary Author </paragraph>
 <paragraph index="179" node_type="writer" parent_index="170">Contributors </paragraph>
 <paragraph index="180" node_type="writer" parent_index="170">Trademarks </paragraph>
 <paragraph index="181" node_type="writer" parent_index="170">1. Preface </paragraph>
 <paragraph index="182" node_type="writer" parent_index="170">1.1. Purpose </paragraph>
 <paragraph index="183" node_type="writer" parent_index="170">1.2. Status </paragraph>
 <paragraph index="184" node_type="writer" parent_index="170">1.3. Feedback </paragraph>
 <paragraph index="185" node_type="writer" parent_index="170">1.4. Conformance </paragraph>
 <paragraph index="186" node_type="writer" parent_index="170">1.5. Previous Versions </paragraph>
 <paragraph index="187" node_type="writer" parent_index="170">1.5.1. Version 3.0.0 </paragraph>
 <paragraph index="188" node_type="writer" parent_index="170">1.5.2. Version 3.1.0 </paragraph>
 <paragraph index="189" node_type="writer" parent_index="170">1.6. A Note on Language </paragraph>
 <paragraph index="190" node_type="writer" parent_index="170">1.7. Tooling </paragraph>
 <paragraph index="191" node_type="writer" parent_index="170">2. Overview </paragraph>
 <paragraph index="192" node_type="writer" parent_index="170">2.1. Introduction </paragraph>
 <paragraph index="193" node_type="writer" parent_index="170">2.2. Features </paragraph>
 <paragraph index="194" node_type="writer" parent_index="170">2.3. Current State of the Art </paragraph>
 <paragraph index="195" node_type="writer" parent_index="170">2.3.1. UML </paragraph>
 <paragraph index="196" node_type="writer" parent_index="170">2.3.2. XML Schema </paragraph>
 <paragraph index="197" node_type="writer" parent_index="170">2.4. Computational Model </paragraph>
 <paragraph index="198" node_type="writer" parent_index="170">2.5. Purpose of the BMM </paragraph>
 <paragraph index="199" node_type="writer" parent_index="170">2.5.1. Class Model Representation </paragraph>
 <paragraph index="200" node_type="writer" parent_index="170">2.5.2. Meta-Model for Expressions Language </paragraph>
 <paragraph index="201" node_type="writer" parent_index="170">2.5.3. Information Model Representation </paragraph>
 <paragraph index="202" node_type="writer" parent_index="170">2.5.4. Archetype Modelling </paragraph>
 <paragraph index="203" node_type="writer" parent_index="170">3. Package Structure </paragraph>
 <paragraph index="204" node_type="writer" parent_index="170">3.1. Overview </paragraph>
 <paragraph index="205" node_type="writer" parent_index="170">3.2. Class Definitions </paragraph>
 <paragraph index="206" node_type="writer" parent_index="170">3.2.1. BMM_DEFINITIONS Class </paragraph>
 <paragraph index="207" node_type="writer" parent_index="170">4. Model Access Package </paragraph>
 <paragraph index="208" node_type="writer" parent_index="170">4.1. Overview </paragraph>
 <paragraph index="209" node_type="writer" parent_index="170">4.2. Class Definitions </paragraph>
 <paragraph index="210" node_type="writer" parent_index="170">4.2.1. BMM_MODEL_ACCESS Class </paragraph>
 <paragraph index="211" node_type="writer" parent_index="170">4.2.2. BMM_SCHEMA_DESCRIPTOR Class </paragraph>
 <paragraph index="212" node_type="writer" parent_index="170">4.2.3. BMM_MODEL_METADATA Class </paragraph>
 <paragraph index="213" node_type="writer" parent_index="170">4.2.4. BMM_SCHEMA Class </paragraph>
 <paragraph index="214" node_type="writer" parent_index="170">4.2.5. BMM_SCHEMA_STATE Enumeration </paragraph>
 <paragraph index="215" node_type="writer" parent_index="170">4.2.6. BMM_INCLUDE_SPEC Class </paragraph>
 <paragraph index="216" node_type="writer" parent_index="170">5. Model Structure </paragraph>
 <paragraph index="217" node_type="writer" parent_index="170">5.1. Overview </paragraph>
 <paragraph index="218" node_type="writer" parent_index="170">5.2. Naming Convention </paragraph>
 <paragraph index="219" node_type="writer" parent_index="170">5.3. Model Semantics </paragraph>
 <paragraph index="220" node_type="writer" parent_index="170">5.3.1. Packages </paragraph>
 <paragraph index="221" node_type="writer" parent_index="170">5.3.2. Use of other Models </paragraph>
 <paragraph index="222" node_type="writer" parent_index="170">5.3.3. Documentation </paragraph>
 <paragraph index="223" node_type="writer" parent_index="170">5.3.4. Other Meta-data </paragraph>
 <paragraph index="224" node_type="writer" parent_index="170">5.4. The Any Class and Type </paragraph>
 <paragraph index="225" node_type="writer" parent_index="170">5.5. Class Definitions </paragraph>
 <paragraph index="226" node_type="writer" parent_index="170">5.5.1. BMM_MODEL_ELEMENT Class </paragraph>
 <paragraph index="227" node_type="writer" parent_index="170">5.5.2. BMM_PACKAGE_CONTAINER Class </paragraph>
 <paragraph index="228" node_type="writer" parent_index="170">5.5.3. BMM_PACKAGE Class </paragraph>
 <paragraph index="229" node_type="writer" parent_index="170">5.5.4. BMM_MODEL Class </paragraph>
 <paragraph index="230" node_type="writer" parent_index="170">5.5.5. BMM_MODULE Class </paragraph>
 <paragraph index="231" node_type="writer" parent_index="170">6. Types </paragraph>
 <paragraph index="232" node_type="writer" parent_index="170">6.1. Overview </paragraph>
 <paragraph index="233" node_type="writer" parent_index="170">6.2. Simple Type </paragraph>
 <paragraph index="234" node_type="writer" parent_index="170">6.2.1. Conformance </paragraph>
 <paragraph index="235" node_type="writer" parent_index="170">6.3. Generic Type </paragraph>
 <paragraph index="236" node_type="writer" parent_index="170">6.3.1. Conformance </paragraph>
 <paragraph index="237" node_type="writer" parent_index="170">6.4. Container Meta-types </paragraph>
 <paragraph index="238" node_type="writer" parent_index="170">6.4.1. Conformance </paragraph>
 <paragraph index="239" node_type="writer" parent_index="170">6.5. Bult-in Meta-types </paragraph>
 <paragraph index="240" node_type="writer" parent_index="170">6.5.1. Tuple Meta-type </paragraph>
 <paragraph index="241" node_type="writer" parent_index="170">6.5.1.1. Conformance </paragraph>
 <paragraph index="242" node_type="writer" parent_index="170">6.5.2. Signature Meta-type </paragraph>
 <paragraph index="243" node_type="writer" parent_index="170">6.5.2.1. Conformance </paragraph>
 <paragraph index="244" node_type="writer" parent_index="170">6.5.3. Status Meta-type </paragraph>
 <paragraph index="245" node_type="writer" parent_index="170">6.6. Type Conformance </paragraph>
 <paragraph index="246" node_type="writer" parent_index="170">6.7. Model Theoretic Questions </paragraph>
 <paragraph index="247" node_type="writer" parent_index="170">6.8. Class Definitions </paragraph>
 <paragraph index="248" node_type="writer" parent_index="170">6.8.1. BMM_TYPE Class </paragraph>
 <paragraph index="249" node_type="writer" parent_index="170">6.8.2. BMM_UNITARY_TYPE Class </paragraph>
 <paragraph index="250" node_type="writer" parent_index="170">6.8.3. BMM_EFFECTIVE_TYPE Class </paragraph>
 <paragraph index="251" node_type="writer" parent_index="170">6.8.4. BMM_PARAMETER_TYPE Class </paragraph>
 <paragraph index="252" node_type="writer" parent_index="170">6.8.5. BMM_MODEL_TYPE Class </paragraph>
 <paragraph index="253" node_type="writer" parent_index="170">6.8.6. BMM_SIMPLE_TYPE Class </paragraph>
 <paragraph index="254" node_type="writer" parent_index="170">6.8.7. BMM_GENERIC_TYPE Class </paragraph>
 <paragraph index="255" node_type="writer" parent_index="170">6.8.8. BMM_BUILTIN_TYPE Class </paragraph>
 <paragraph index="256" node_type="writer" parent_index="170">6.8.9. BMM_TUPLE_TYPE Class </paragraph>
 <paragraph index="257" node_type="writer" parent_index="170">6.8.10. BMM_SIGNATURE Class </paragraph>
 <paragraph index="258" node_type="writer" parent_index="170">6.8.11. BMM_PROPERTY_TYPE Class </paragraph>
 <paragraph index="259" node_type="writer" parent_index="170">6.8.12. BMM_ROUTINE_TYPE Class </paragraph>
 <paragraph index="260" node_type="writer" parent_index="170">6.8.13. BMM_FUNCTION_TYPE Class </paragraph>
 <paragraph index="261" node_type="writer" parent_index="170">6.8.14. BMM_PROCEDURE_TYPE Class </paragraph>
 <paragraph index="262" node_type="writer" parent_index="170">6.8.15. BMM_STATUS_TYPE Class </paragraph>
 <paragraph index="263" node_type="writer" parent_index="170">6.8.16. BMM_CONTAINER_TYPE Class </paragraph>
 <paragraph index="264" node_type="writer" parent_index="170">6.8.17. BMM_INDEXED_CONTAINER_TYPE Class </paragraph>
 <paragraph index="265" node_type="writer" parent_index="170">7. Classes </paragraph>
 <paragraph index="266" node_type="writer" parent_index="170">7.1. Overview </paragraph>
 <paragraph index="267" node_type="writer" parent_index="170">7.2. Simple Classes </paragraph>
 <paragraph index="268" node_type="writer" parent_index="170">7.3. Generic Classes </paragraph>
 <paragraph index="269" node_type="writer" parent_index="170">7.4. Range-Constrained Classes </paragraph>
 <paragraph index="270" node_type="writer" parent_index="170">7.4.1. Enumerated Types </paragraph>
 <paragraph index="271" node_type="writer" parent_index="170">7.4.2. Value-set Types </paragraph>
 <paragraph index="272" node_type="writer" parent_index="170">7.5. Class Qualifiers </paragraph>
 <paragraph index="273" node_type="writer" parent_index="170">7.5.1. Abstract Classes </paragraph>
 <paragraph index="274" node_type="writer" parent_index="170">7.5.2. Primitive Type Classes </paragraph>
 <paragraph index="275" node_type="writer" parent_index="170">7.6. Class Invariants </paragraph>
 <paragraph index="276" node_type="writer" parent_index="170">7.7. Inheritance </paragraph>
 <paragraph index="277" node_type="writer" parent_index="170">7.8. Model Theoretic Questions </paragraph>
 <paragraph index="278" node_type="writer" parent_index="170">7.9. Class Definitions </paragraph>
 <paragraph index="279" node_type="writer" parent_index="170">7.9.1. BMM_CLASS Class </paragraph>
 <paragraph index="280" node_type="writer" parent_index="170">7.9.2. BMM_SIMPLE_CLASS Class </paragraph>
 <paragraph index="281" node_type="writer" parent_index="170">7.9.3. BMM_GENERIC_CLASS Class </paragraph>
 <paragraph index="282" node_type="writer" parent_index="170">7.9.4. BMM_ENUMERATION Class </paragraph>
 <paragraph index="283" node_type="writer" parent_index="170">7.9.5. BMM_ENUMERATION_STRING Class </paragraph>
 <paragraph index="284" node_type="writer" parent_index="170">7.9.6. BMM_ENUMERATION_INTEGER Class </paragraph>
 <paragraph index="285" node_type="writer" parent_index="170">7.9.7. BMM_VALUE_SET_SPEC Class </paragraph>
 <paragraph index="286" node_type="writer" parent_index="170">8. Class Features </paragraph>
 <paragraph index="287" node_type="writer" parent_index="170">8.1. Overview </paragraph>
 <paragraph index="288" node_type="writer" parent_index="170">8.1.1. Feature Taxonomy </paragraph>
 <paragraph index="289" node_type="writer" parent_index="170">8.1.2. Class Model </paragraph>
 <paragraph index="290" node_type="writer" parent_index="170">8.1.3. Feature Groups and Visibility </paragraph>
 <paragraph index="291" node_type="writer" parent_index="170">8.1.4. Differential and Flat Form </paragraph>
 <paragraph index="292" node_type="writer" parent_index="170">8.1.5. Signatures </paragraph>
 <paragraph index="293" node_type="writer" parent_index="170">8.1.6. Synthesis due to Generic Parameter Substitution </paragraph>
 <paragraph index="294" node_type="writer" parent_index="170">8.2. Properties </paragraph>
 <paragraph index="295" node_type="writer" parent_index="170">8.2.1. Static Properties </paragraph>
 <paragraph index="296" node_type="writer" parent_index="170">8.2.1.1. Constants </paragraph>
 <paragraph index="297" node_type="writer" parent_index="170">8.2.1.2. Singletons </paragraph>
 <paragraph index="298" node_type="writer" parent_index="170">8.2.2. Writable Properties </paragraph>
 <paragraph index="299" node_type="writer" parent_index="170">8.2.2.1. Unitary versus Container Properties </paragraph>
 <paragraph index="300" node_type="writer" parent_index="170">8.2.3. Semantic Level </paragraph>
 <paragraph index="301" node_type="writer" parent_index="170">8.3. Functions and Procedures </paragraph>
 <paragraph index="302" node_type="writer" parent_index="170">8.3.1. Pre- and Post-conditions </paragraph>
 <paragraph index="303" node_type="writer" parent_index="170">8.3.2. Creators and Converters </paragraph>
 <paragraph index="304" node_type="writer" parent_index="170">8.3.3. Routine Body </paragraph>
 <paragraph index="305" node_type="writer" parent_index="170">8.4. Variables </paragraph>
 <paragraph index="306" node_type="writer" parent_index="170">8.5. Model Theoretic Questions </paragraph>
 <paragraph index="307" node_type="writer" parent_index="170">8.6. Class Definitions </paragraph>
 <paragraph index="308" node_type="writer" parent_index="170">8.6.1. BMM_FORMAL_ELEMENT Class </paragraph>
 <paragraph index="309" node_type="writer" parent_index="170">8.6.2. BMM_FEATURE Class </paragraph>
 <paragraph index="310" node_type="writer" parent_index="170">8.6.3. BMM_FEATURE_GROUP Class </paragraph>
 <paragraph index="311" node_type="writer" parent_index="170">8.6.4. BMM_VISIBILITY Class </paragraph>
 <paragraph index="312" node_type="writer" parent_index="170">8.6.5. BMM_INSTANTIABLE_FEATURE Class </paragraph>
 <paragraph index="313" node_type="writer" parent_index="170">8.6.6. BMM_STATIC Class </paragraph>
 <paragraph index="314" node_type="writer" parent_index="170">8.6.7. BMM_CONSTANT Class </paragraph>
 <paragraph index="315" node_type="writer" parent_index="170">8.6.8. BMM_SINGLETON Class </paragraph>
 <paragraph index="316" node_type="writer" parent_index="170">8.6.9. BMM_PROPERTY Class </paragraph>
 <paragraph index="317" node_type="writer" parent_index="170">8.6.10. BMM_UNITARY_PROPERTY Class </paragraph>
 <paragraph index="318" node_type="writer" parent_index="170">8.6.11. BMM_CONTAINER_PROPERTY Class </paragraph>
 <paragraph index="319" node_type="writer" parent_index="170">8.6.12. BMM_INDEXED_CONTAINER_PROPERTY Class </paragraph>
 <paragraph index="320" node_type="writer" parent_index="170">8.6.13. BMM_ROUTINE Class </paragraph>
 <paragraph index="321" node_type="writer" parent_index="170">8.6.14. BMM_FUNCTION Class </paragraph>
 <paragraph index="322" node_type="writer" parent_index="170">8.6.15. BMM_OPERATOR Class </paragraph>
 <paragraph index="323" node_type="writer" parent_index="170">8.6.16. BMM_OPERATOR_POSITION Enumeration </paragraph>
 <paragraph index="324" node_type="writer" parent_index="170">8.6.17. BMM_PROCEDURE Class </paragraph>
 <paragraph index="325" node_type="writer" parent_index="170">8.6.18. BMM_VARIABLE Class </paragraph>
 <paragraph index="326" node_type="writer" parent_index="170">8.6.19. BMM_WRITABLE_VARIABLE Class </paragraph>
 <paragraph index="327" node_type="writer" parent_index="170">8.6.20. BMM_LOCAL Class </paragraph>
 <paragraph index="328" node_type="writer" parent_index="170">8.6.21. BMM_RESULT Class </paragraph>
 <paragraph index="329" node_type="writer" parent_index="170">8.6.22. BMM_READONLY_VARIABLE Class </paragraph>
 <paragraph index="330" node_type="writer" parent_index="170">8.6.23. BMM_SELF Class </paragraph>
 <paragraph index="331" node_type="writer" parent_index="170">8.6.24. BMM_PARAMETER Class </paragraph>
 <paragraph index="332" node_type="writer" parent_index="170">8.6.25. BMM_PARAMETER_DIRECTION Enumeration </paragraph>
 <paragraph index="333" node_type="writer" parent_index="170">8.6.26. BMM_ROUTINE_DEFINITION Class </paragraph>
 <paragraph index="334" node_type="writer" parent_index="170">8.6.27. BMM_LOCAL_ROUTINE Class </paragraph>
 <paragraph index="335" node_type="writer" parent_index="170">8.6.28. BMM_EXTERNAL_ROUTINE Class </paragraph>
 <paragraph index="336" node_type="writer" parent_index="170">9. Literal Values </paragraph>
 <paragraph index="337" node_type="writer" parent_index="170">9.1. Overview </paragraph>
 <paragraph index="338" node_type="writer" parent_index="170">9.2. General Model </paragraph>
 <paragraph index="339" node_type="writer" parent_index="170">9.3. Container Literals </paragraph>
 <paragraph index="340" node_type="writer" parent_index="170">9.4. Literal Tuples </paragraph>
 <paragraph index="341" node_type="writer" parent_index="170">9.5. Type Extensions </paragraph>
 <paragraph index="342" node_type="writer" parent_index="170">9.6. Class Definitions </paragraph>
 <paragraph index="343" node_type="writer" parent_index="170">9.6.1. BMM_LITERAL_VALUE Class </paragraph>
 <paragraph index="344" node_type="writer" parent_index="170">9.6.2. BMM_CONTAINER_VALUE Class </paragraph>
 <paragraph index="345" node_type="writer" parent_index="170">9.6.3. BMM_INDEXED_CONTAINER_VALUE Class </paragraph>
 <paragraph index="346" node_type="writer" parent_index="170">9.6.4. BMM_UNITARY_VALUE Class </paragraph>
 <paragraph index="347" node_type="writer" parent_index="170">9.6.5. BMM_PRIMITIVE_VALUE Class </paragraph>
 <paragraph index="348" node_type="writer" parent_index="170">9.6.6. BMM_STRING_VALUE Class </paragraph>
 <paragraph index="349" node_type="writer" parent_index="170">9.6.7. BMM_INTEGER_VALUE Class </paragraph>
 <paragraph index="350" node_type="writer" parent_index="170">9.6.8. BMM_BOOLEAN_VALUE Class </paragraph>
 <paragraph index="351" node_type="writer" parent_index="170">9.6.9. BMM_INTERVAL_VALUE Class </paragraph>
 <paragraph index="352" node_type="writer" parent_index="170">10. Expressions </paragraph>
 <paragraph index="353" node_type="writer" parent_index="170">10.1. Overview </paragraph>
 <paragraph index="354" node_type="writer" parent_index="170">10.2. Terminal Entities </paragraph>
 <paragraph index="355" node_type="writer" parent_index="170">10.2.1. Simple Terminal Entities </paragraph>
 <paragraph index="356" node_type="writer" parent_index="170">10.2.1.1. Literals </paragraph>
 <paragraph index="357" node_type="writer" parent_index="170">10.2.1.2. Value Generators </paragraph>
 <paragraph index="358" node_type="writer" parent_index="170">10.2.1.3. Variables </paragraph>
 <paragraph index="359" node_type="writer" parent_index="170">10.2.1.4. Predicates </paragraph>
 <paragraph index="360" node_type="writer" parent_index="170">10.2.2. Decision Tables </paragraph>
 <paragraph index="361" node_type="writer" parent_index="170">10.3. Operator Expressions </paragraph>
 <paragraph index="362" node_type="writer" parent_index="170">10.4. Tuples </paragraph>
 <paragraph index="363" node_type="writer" parent_index="170">10.5. Usage in BMM Models </paragraph>
 <paragraph index="364" node_type="writer" parent_index="170">10.5.1. Simple Assertions </paragraph>
 <paragraph index="365" node_type="writer" parent_index="170">10.5.2. Existential and Universal Quantifier Invariants </paragraph>
 <paragraph index="366" node_type="writer" parent_index="170">10.6. Class Definitions </paragraph>
 <paragraph index="367" node_type="writer" parent_index="170">10.6.1. EL_EXPRESSION Class </paragraph>
 <paragraph index="368" node_type="writer" parent_index="170">10.6.2. EL_TERMINAL Class </paragraph>
 <paragraph index="369" node_type="writer" parent_index="170">10.6.3. EL_SIMPLE Class </paragraph>
 <paragraph index="370" node_type="writer" parent_index="170">10.6.4. EL_VALUE_GENERATOR Class </paragraph>
 <paragraph index="371" node_type="writer" parent_index="170">10.6.5. EL_TYPE_REF Class </paragraph>
 <paragraph index="372" node_type="writer" parent_index="170">10.6.6. EL_LITERAL Class </paragraph>
 <paragraph index="373" node_type="writer" parent_index="170">10.6.7. EL_VARIABLE Class </paragraph>
 <paragraph index="374" node_type="writer" parent_index="170">10.6.8. EL_WRITABLE_VARIABLE Class </paragraph>
 <paragraph index="375" node_type="writer" parent_index="170">10.6.9. EL_READONLY_VARIABLE Class </paragraph>
 <paragraph index="376" node_type="writer" parent_index="170">10.6.10. EL_FEATURE_REF Class </paragraph>
 <paragraph index="377" node_type="writer" parent_index="170">10.6.11. EL_PROPERTY_REF Class </paragraph>
 <paragraph index="378" node_type="writer" parent_index="170">10.6.12. EL_STATIC_REF Class </paragraph>
 <paragraph index="379" node_type="writer" parent_index="170">10.6.13. EL_AGENT_CALL Class </paragraph>
 <paragraph index="380" node_type="writer" parent_index="170">10.6.14. EL_FUNCTION_CALL Class </paragraph>
 <paragraph index="381" node_type="writer" parent_index="170">10.6.15. EL_AGENT Class </paragraph>
 <paragraph index="382" node_type="writer" parent_index="170">10.6.16. EL_FUNCTION_AGENT Class </paragraph>
 <paragraph index="383" node_type="writer" parent_index="170">10.6.17. EL_PROCEDURE_AGENT Class </paragraph>
 <paragraph index="384" node_type="writer" parent_index="170">10.6.18. EL_PREDICATE Class </paragraph>
 <paragraph index="385" node_type="writer" parent_index="170">10.6.19. EL_DEFINED Class </paragraph>
 <paragraph index="386" node_type="writer" parent_index="170">10.6.20. EL_ATTACHED Class </paragraph>
 <paragraph index="387" node_type="writer" parent_index="170">10.6.21. EL_DECISION_TABLE Class </paragraph>
 <paragraph index="388" node_type="writer" parent_index="170">10.6.22. EL_DECISION_BRANCH Class </paragraph>
 <paragraph index="389" node_type="writer" parent_index="170">10.6.23. EL_CONDITION_CHAIN Class </paragraph>
 <paragraph index="390" node_type="writer" parent_index="170">10.6.24. EL_CONDITIONAL_EXPRESSION Class </paragraph>
 <paragraph index="391" node_type="writer" parent_index="170">10.6.25. EL_CASE_TABLE Class </paragraph>
 <paragraph index="392" node_type="writer" parent_index="170">10.6.26. EL_CASE Class </paragraph>
 <paragraph index="393" node_type="writer" parent_index="170">10.6.27. EL_OPERATOR Class </paragraph>
 <paragraph index="394" node_type="writer" parent_index="170">10.6.28. EL_UNARY_OPERATOR Class </paragraph>
 <paragraph index="395" node_type="writer" parent_index="170">10.6.29. EL_BINARY_OPERATOR Class </paragraph>
 <paragraph index="396" node_type="writer" parent_index="170">10.6.30. EL_TUPLE Class </paragraph>
 <paragraph index="397" node_type="writer" parent_index="170">10.6.31. EL_TUPLE_ITEM Class </paragraph>
 <paragraph index="398" node_type="writer" parent_index="170">10.6.32. EL_CONSTRAINED Class </paragraph>
 <paragraph index="399" node_type="writer" parent_index="170">10.6.33. EL_BOOLEAN_EXPRESSION Class </paragraph>
 <paragraph index="400" node_type="writer" parent_index="170">11. Functional Elements </paragraph>
 <paragraph index="401" node_type="writer" parent_index="170">11.1. Overview </paragraph>
 <paragraph index="402" node_type="writer" parent_index="170">11.2. Agents </paragraph>
 <paragraph index="403" node_type="writer" parent_index="170">11.3. Calls </paragraph>
 <paragraph index="404" node_type="writer" parent_index="170">12. Statements </paragraph>
 <paragraph index="405" node_type="writer" parent_index="170">12.1. Overview </paragraph>
 <paragraph index="406" node_type="writer" parent_index="170">12.2. Variable Declaration </paragraph>
 <paragraph index="407" node_type="writer" parent_index="170">12.3. Assignment </paragraph>
 <paragraph index="408" node_type="writer" parent_index="170">12.4. Procedure Call </paragraph>
 <paragraph index="409" node_type="writer" parent_index="170">12.5. Action Tables </paragraph>
 <paragraph index="410" node_type="writer" parent_index="170">12.6. Assertions </paragraph>
 <paragraph index="411" node_type="writer" parent_index="170">12.7. Class Definitions </paragraph>
 <paragraph index="412" node_type="writer" parent_index="170">12.7.1. BMM_STATEMENT_ITEM Class </paragraph>
 <paragraph index="413" node_type="writer" parent_index="170">12.7.2. BMM_STATEMENT_BLOCK Class </paragraph>
 <paragraph index="414" node_type="writer" parent_index="170">12.7.3. BMM_STATEMENT Class </paragraph>
 <paragraph index="415" node_type="writer" parent_index="170">12.7.4. BMM_SIMPLE_STATEMENT Class </paragraph>
 <paragraph index="416" node_type="writer" parent_index="170">12.7.5. BMM_DECLARATION Class </paragraph>
 <paragraph index="417" node_type="writer" parent_index="170">12.7.6. BMM_ASSIGNMENT Class </paragraph>
 <paragraph index="418" node_type="writer" parent_index="170">12.7.7. BMM_PROCEDURE_CALL Class </paragraph>
 <paragraph index="419" node_type="writer" parent_index="170">12.7.8. BMM_ASSERTION Class </paragraph>
 <paragraph index="420" node_type="writer" parent_index="170">12.7.9. BMM_ACTION_TABLE Class </paragraph>
 <paragraph index="421" node_type="writer" parent_index="170">12.7.10. BMM_ACTION_DECISION_TABLE Class </paragraph>
 <paragraph index="422" node_type="writer" parent_index="170">13. Model Semantics </paragraph>
 <paragraph index="423" node_type="writer" parent_index="170">13.1. Inheritance </paragraph>
 <paragraph index="424" node_type="writer" parent_index="170">13.1.1. Simple Inheritance </paragraph>
 <paragraph index="425" node_type="writer" parent_index="170">13.1.2. Generic Inheritance </paragraph>
 <paragraph index="426" node_type="writer" parent_index="170">13.1.3. Multiple Inheritance </paragraph>
 <paragraph index="427" node_type="writer" parent_index="170">13.1.4. Inheritance and Invariants, Pre-conditions and Post-conditions </paragraph>
 <paragraph index="428" node_type="writer" parent_index="170">14. BMM Extensions </paragraph>
 <paragraph index="429" node_type="writer" parent_index="170">14.1. Overview </paragraph>
 <paragraph index="430" node_type="writer" parent_index="170">14.2. General Extensions </paragraph>
 <paragraph index="431" node_type="writer" parent_index="170">14.3. Feature Extensions </paragraph>
 <paragraph index="432" node_type="writer" parent_index="170">References </paragraph>
 <object index="435" name="content" object_type="section"/>
 <object index="437" name="preamble" object_type="section"/>
 <paragraph index="438" node_type="writer" parent_index="437"> </paragraph>
 <paragraph index="440" node_type="writer" parent_index="435">Basic Meta-Model (BMM)</paragraph>
 <object index="441" name="Table1" object_type="table"/>
 <paragraph index="443" node_type="writer" parent_index="441">Issuer: openEHR Specification Program</paragraph>
 <paragraph index="446" node_type="writer" parent_index="441">Release: LANG latest</paragraph>
 <paragraph index="449" node_type="writer" parent_index="441">Status: DEVELOPMENT</paragraph>
 <paragraph index="452" node_type="writer" parent_index="441">Revision: [latest_issue]</paragraph>
 <paragraph index="455" node_type="writer" parent_index="441">Date: [latest_issue_date]</paragraph>
 <paragraph index="458" node_type="writer" parent_index="441">Keywords: reflection, meta-model, UML, BMM</paragraph>
 <paragraph index="461" node_type="writer" parent_index="435">openEHR components </paragraph>
 <object index="462" name="Table2" object_type="table"/>
 <paragraph index="464" node_type="writer" parent_index="462">© 2016 - 2022 The openEHR Foundation</paragraph>
 <paragraph index="467" node_type="writer" parent_index="462">The openEHR Foundation is an independent, non-profit foundation, facilitating the sharing of health records by consumers and clinicians via open specifications, clinical models and open platform implementations.</paragraph>
 <paragraph index="470" node_type="writer" parent_index="462">Licence</paragraph>
 <paragraph index="473" node_type="writer" parent_index="462"> Creative Commons Attribution-NoDerivs 3.0 Unported. https://creativecommons.org/licenses/by-nd/3.0/</paragraph>
 <paragraph index="476" node_type="writer" parent_index="462">Support</paragraph>
 <paragraph index="479" node_type="writer" parent_index="462">Issues: Problem Reports
Web: specifications.openEHR.org</paragraph>
 <paragraph index="482" node_type="writer" parent_index="435">Amendment Record</paragraph>
 <object index="483" name="Table3" object_type="table"/>
 <paragraph index="485" node_type="writer" parent_index="483">Issue</paragraph>
 <paragraph index="488" node_type="writer" parent_index="483">Details</paragraph>
 <paragraph index="491" node_type="writer" parent_index="483">Raiser</paragraph>
 <paragraph index="494" node_type="writer" parent_index="483">Completed</paragraph>
 <paragraph index="497" node_type="writer" parent_index="483">LANG Release 1.1.0 (unreleased)</paragraph>
 <paragraph index="500" node_type="writer" parent_index="483">4.0.1</paragraph>
 <paragraph index="503" node_type="writer" parent_index="483">SPECLANG-8. Classify EL_DECISION_TABLE under EL_TERMINAL;
Add read-only and writable meta-types for variables and properties;
Add routine, function and property signature meta-types.</paragraph>
 <paragraph index="506" node_type="writer" parent_index="483">T Beale</paragraph>
 <paragraph index="509" node_type="writer" parent_index="483">29 Apr 2022</paragraph>
 <paragraph index="512" node_type="writer" parent_index="483">4.0.0</paragraph>
 <paragraph index="515" node_type="writer" parent_index="483">SPECLANG-8. Simplify meta-model of features to single inheritance;
change BMM_PROCEDURE to return a special type similar to Haskell, Kotlin. Revert some 3.1.0 changes.</paragraph>
 <paragraph index="518" node_type="writer" parent_index="483">T Beale</paragraph>
 <paragraph index="521" node_type="writer" parent_index="483">09 Jun 2021</paragraph>
 <paragraph index="524" node_type="writer" parent_index="483">LANG Release 1.0.0</paragraph>
 <paragraph index="527" node_type="writer" parent_index="483">3.1.0</paragraph>
 <paragraph index="530" node_type="writer" parent_index="483">SPECLANG-2. Add Basic Meta-Model (BMM) spec to LANG component.</paragraph>
 <paragraph index="533" node_type="writer" parent_index="483">openEHR SEC</paragraph>
 <paragraph index="536" node_type="writer" parent_index="483">11 May 2020</paragraph>
 <paragraph index="542" node_type="writer" parent_index="483">Add EL_SIMPLE to distinguish complex expressions from terminals and operator expressions; Adjust BMM_CONSTANT to support computed constants;
Add EL_DECISION_TABLE, BMM_ACTION_TABLE classes and descendants;
Add BMM_INTERVAL_VALUE;
Add BMM_FEATURE_GROUP and BMM_VISIBILITY classes;
Rename BMM_SCHEMA.bmm_schema to bmm_model;
Remove unintended inheritance from BMM_SCHEMA to P_BMM_PACKAGE_CONTAINER;
Improve documentation in Section 4.</paragraph>
 <paragraph index="545" node_type="writer" parent_index="483">T Beale</paragraph>
 <paragraph index="548" node_type="writer" parent_index="483">12 Oct 2020</paragraph>
 <paragraph index="554" node_type="writer" parent_index="483">Rename EL_ASSERTION to EL_BOOLEAN_EXPRESSION;
Extend literal meta-types to directly support container literals;
Add basic statement types to BMM;
Add external routine support;
Added note on multiple inheritance in Class Features section.</paragraph>
 <paragraph index="557" node_type="writer" parent_index="483">T Beale</paragraph>
 <paragraph index="560" node_type="writer" parent_index="483">25 Jun 2020</paragraph>
 <paragraph index="566" node_type="writer" parent_index="483">Remove inheritance to BMM_DEFINITIONS (assume static access);
Remove BMM_ENTITY class and 'Entities' section of document.</paragraph>
 <paragraph index="569" node_type="writer" parent_index="483">B Verhees,
T Beale</paragraph>
 <paragraph index="572" node_type="writer" parent_index="483">01 Jun 2020</paragraph>
 <paragraph index="578" node_type="writer" parent_index="483">Rename BMM_DEFINED_TYPE to BMM_EFFECTIVE_TYPE;
Rename BMM_ENTITY_TYPE to BMM_MODEL_TYPE;
Significant improvements to meta-type part of model;
Add Expression language meta-model;
Add abstract syntax examples to text;
Add description of default Any class and type;
Add BMM_MODEL.used_models;
Add creators and converters;
Add ROUTINE.body hook;
Add BMM_RESULT, EL_SCOPED_REF, EL_TYPE_REF;
Add BMM_MODULE.</paragraph>
 <paragraph index="581" node_type="writer" parent_index="483">T Beale</paragraph>
 <paragraph index="584" node_type="writer" parent_index="483">22 Apr 2020</paragraph>
 <paragraph index="590" node_type="writer" parent_index="483">Rename BMM_MODEL_ELEMENT to BMM_DECLARATION;
Rename BMM_VALUED to BMM_TYPED;
Rename BMM_REFERENCEABLE to BMM_FEATURE;
Introduce dual taxonomy for features based on scoped declarations and typing;
Add meta-model for functional entities. Re-structure packages. Modify BMM_FEATURE.signature to new meta-type, BMM_SIGNATURE.</paragraph>
 <paragraph index="593" node_type="writer" parent_index="483">T Beale</paragraph>
 <paragraph index="596" node_type="writer" parent_index="483">11 Nov 2019</paragraph>
 <paragraph index="602" node_type="writer" parent_index="483">Improve meta-model of Features: rename BMM_FORMAL_ELEMENT to BMM_REFERENCEABLE; move BMM_VALUE_RETURNING.type to BMM_EVALUABLE;
Add BMM_INDEXED_CONTAINER_TYPE, BMM_INDEXED_CONTAINER_PROPERTY, to support indexed containers like Hash&lt;K, V&gt;.</paragraph>
 <paragraph index="605" node_type="writer" parent_index="483">T Beale</paragraph>
 <paragraph index="608" node_type="writer" parent_index="483">10 Mar 2019</paragraph>
 <paragraph index="614" node_type="writer" parent_index="483">Improve meta-model of Enumerated types to include types restricted to a terminology or value set (may be used for terminology constraints);
Improve explanation and diagrams to do with types and classes.</paragraph>
 <paragraph index="617" node_type="writer" parent_index="483">T Beale</paragraph>
 <paragraph index="620" node_type="writer" parent_index="483">22 Feb 2019</paragraph>
 <paragraph index="626" node_type="writer" parent_index="483">Add feature elements BMM_ROUTINE, BMM_VALUED and descendants;
Change BMM_PROPERTY.is_mandatory to BMM_MUTABLE.is_nullable (reversed Boolean sense);
Made BMM_PACKAGE_CONTAINER abstract;
Moved name to BMM_MODEL_ELEMENT, replacing name in BMM_CLASS, BMM_PACKAGE, BMM_PROPERTY, and model_name in BMM_MODEL;
Marked BMM_PROPERTY.is_computed as obsolete (to be phased out);
Add BMM_PROPERTY.is_composition to distinguish part/whole from associations.</paragraph>
 <paragraph index="629" node_type="writer" parent_index="483">T Beale</paragraph>
 <paragraph index="632" node_type="writer" parent_index="483">15 Sep 2018</paragraph>
 <paragraph index="635" node_type="writer" parent_index="483">3.0.0</paragraph>
 <paragraph index="638" node_type="writer" parent_index="483">SPECLANG-2. Add Basic Meta-Model (BMM) spec to LANG component;
Separate P_BMM model and syntax to BMM Persistence specification;
refactor / tighten class model:
rename BMM_GENERIC_PARAMETER to BMM_PARAMETER_TYPE;
remove BMM_OPEN_TYPE; remove BMM_TYPE_ELEMENT;
add new type BMM_DEFINED_TYPE as parent of BMM_SIMPLE_TYPE and BMM_GENERIC_TYPE;
add new type BMM_UNITARY_TYPE as parent of BMM_DEFINED_TYPE and BMM_PARAMETER_TYPE;
redefine BMM_CLASS.ancestors to be of type BMM_DEFINED_TYPE;
redefine BMM_PARAMETER_TYPE.conforms_to to type_constraint of type BMM_DEFINED_TYPE;
correct BMM_CLASS.immediate_descendants to be of type List&lt;BMM_CLASS&gt;;
rename BMM_CLASSIFIER to BMM_ENTITY;
Support generic types as class ancestors;
Remove archetype-related meta-data.</paragraph>
 <paragraph index="641" node_type="writer" parent_index="483">T Beale</paragraph>
 <paragraph index="644" node_type="writer" parent_index="483">12 May 2018</paragraph>
 <paragraph index="647" node_type="writer" parent_index="483">2.2.2</paragraph>
 <paragraph index="650" node_type="writer" parent_index="483">Improve and update introductory text in the Overview section.</paragraph>
 <paragraph index="653" node_type="writer" parent_index="483">E Sundvall,
T Beale</paragraph>
 <paragraph index="656" node_type="writer" parent_index="483">03 Nov 2017</paragraph>
 <paragraph index="659" node_type="writer" parent_index="483">2.2.1</paragraph>
 <paragraph index="662" node_type="writer" parent_index="483">Remove BMM_CLASSIFIER.conformance_type_name;
Constrain BMM_GENERIC_PARAMETER.name to one character and upper case.</paragraph>
 <paragraph index="665" node_type="writer" parent_index="483">C Nanjo,
T Beale</paragraph>
 <paragraph index="668" node_type="writer" parent_index="483">02 Mar 2017</paragraph>
 <paragraph index="671" node_type="writer" parent_index="483">2.2.0</paragraph>
 <paragraph index="674" node_type="writer" parent_index="483">Rename BMM_CLASSIFIER.as_type_string to type_name and as_conformance_type_string to conformance_type_name.
Move and rename BMM_TYPE.as_display_type_string to BMM_CLASSIFIER.type_signature. Add redefinitions in relevant descendant classes.
Rename BMM_SIMPLE_TYPE_OPEN to BMM_OPEN_TYPE.
Add new class BMM_TYPE_ELEMENT in preparation for BMM 3 refactoring.
Rename BMM_SCHEMA to BMM_MODEL.</paragraph>
 <paragraph index="677" node_type="writer" parent_index="483">T Beale</paragraph>
 <paragraph index="680" node_type="writer" parent_index="483">20 Jun 2016</paragraph>
 <paragraph index="683" node_type="writer" parent_index="483">2.1.0</paragraph>
 <paragraph index="686" node_type="writer" parent_index="483">Initial writing based on ADL Workbench implementation.</paragraph>
 <paragraph index="689" node_type="writer" parent_index="483">T Beale</paragraph>
 <paragraph index="692" node_type="writer" parent_index="483">08 Feb 2016</paragraph>
 <paragraph index="695" node_type="writer" parent_index="435">Acknowledgements</paragraph>
 <paragraph index="696" node_type="writer" parent_index="435">Primary Author</paragraph>
 <paragraph index="697" node_type="writer" parent_index="435">Thomas Beale, Ars Semantica; openEHR Foundation Management Board.</paragraph>
 <paragraph index="698" node_type="writer" parent_index="435">Contributors</paragraph>
 <paragraph index="699" node_type="writer" parent_index="435">This specification has benefited from formal and informal input from the openEHR and wider health informatics community. The openEHR Foundation would like to recognise the following people for their contributions.</paragraph>
 <paragraph index="700" node_type="writer" parent_index="435">Matija Kejžar, Senior Engineer, Better, Slovenia</paragraph>
 <paragraph index="701" node_type="writer" parent_index="435">Patrick Langford, NeuronSong LLC, Utah, USA</paragraph>
 <paragraph index="702" node_type="writer" parent_index="435">Claude Nanjo MA African Studies, M Public Health, Cognitive Medical Systems Inc., California, USA</paragraph>
 <paragraph index="703" node_type="writer" parent_index="435">Harold Solbrig, Mayo Clinic, Rochester, USA</paragraph>
 <paragraph index="704" node_type="writer" parent_index="435">Erik Sundvall PhD, Linkoping University, Sweden</paragraph>
 <paragraph index="705" node_type="writer" parent_index="435">Bert Verhees, ROSA Software, The Netherlands.</paragraph>
 <paragraph index="706" node_type="writer" parent_index="435">Trademarks</paragraph>
 <paragraph index="707" node_type="writer" parent_index="435">'openEHR' is a registered trademark of the openEHR Foundation;</paragraph>
 <paragraph index="708" node_type="writer" parent_index="435">'Java' is a registered trademark of Oracle Corporation;</paragraph>
 <paragraph index="709" node_type="writer" parent_index="435">'C#' is a registered trademark of Microsoft;</paragraph>
 <paragraph index="710" node_type="writer" parent_index="435">'OMG' and 'UML' are registered trademarks of the Object Management Group;</paragraph>
 <paragraph index="711" node_type="writer" parent_index="435">'MagicDraw' is a registered trademark of NoMagic Inc;</paragraph>
 <paragraph index="712" node_type="writer" parent_index="435">'Rational Software Architect' is a registered trademark of IBM Corporation.</paragraph>
 <paragraph index="713" node_type="writer" parent_index="435">1. Preface</paragraph>
 <paragraph index="714" node_type="writer" parent_index="435">1.1. Purpose</paragraph>
 <paragraph index="715" node_type="writer" parent_index="435">This document describes the Basic Meta-Model (BMM), a model of object models. It may be considered as an approximate replacement for the UML XMI. It is human-readable and writable, and supports generic types (open and closed), container types, and multiple inheritance. The related BMM Persistence specification defines an object model for a serialised schema form. The latter enables serialisation of a BMM into a concrete syntax such as JSON, ODIN or XML.</paragraph>
 <paragraph index="716" node_type="writer" parent_index="435">1.2. Status</paragraph>
 <paragraph index="717" node_type="writer" parent_index="435">This specification is in the DEVELOPMENT state. The development version of this document can be found at https://specifications.openehr.org/releases/LANG/latest/bmm.html.</paragraph>
 <paragraph index="718" node_type="writer" parent_index="435">Known omissions or questions are indicated in the text with a 'to be determined' paragraph, as follows:</paragraph>
 <paragraph index="719" node_type="writer" parent_index="435">TBD: (example To Be Determined paragraph)</paragraph>
 <object index="720" name="Table4" object_type="table"/>
 <paragraph index="722" node_type="writer" parent_index="720">Note</paragraph>
 <paragraph index="725" node_type="writer" parent_index="720">Other than for working with particular tools designed to use BMM, BMM is not a required formalism for implementing openEHR, and other methods of accessing models computably may be used, including UML and software implementations of the openEHR Reference Model. </paragraph>
 <paragraph index="728" node_type="writer" parent_index="435">1.3. Feedback</paragraph>
 <paragraph index="729" node_type="writer" parent_index="435">Feedback may be provided on the openEHR languages specifications forum.</paragraph>
 <paragraph index="730" node_type="writer" parent_index="435">Issues may be raised on the specifications Problem Report tracker.</paragraph>
 <paragraph index="731" node_type="writer" parent_index="435">To see changes made due to previously reported issues, see the LANG component Change Request tracker.</paragraph>
 <paragraph index="732" node_type="writer" parent_index="435">1.4. Conformance</paragraph>
 <paragraph index="733" node_type="writer" parent_index="435">Conformance of a data or software artifact to an openEHR specification is determined by a formal test of that artifact against the relevant openEHR Implementation Technology Specification(s) (ITSs), such as an IDL interface or an XML-schema. Since ITSs are formal derivations from underlying models, ITS conformance indicates model conformance.</paragraph>
 <paragraph index="734" node_type="writer" parent_index="435">1.5. Previous Versions</paragraph>
 <paragraph index="735" node_type="writer" parent_index="435">1.5.1. Version 3.0.0</paragraph>
 <paragraph index="736" node_type="writer" parent_index="435">This version made major changes to the BMM_TYPE hierarchy and semantics, enabling generic inheritance by generic and non-generic classes to be represented.</paragraph>
 <paragraph index="737" node_type="writer" parent_index="435">1.5.2. Version 3.1.0</paragraph>
 <paragraph index="738" node_type="writer" parent_index="435">This version adds meta-classes for computational elements to BMM, including:</paragraph>
 <paragraph index="739" node_type="writer" parent_index="435">routines, variables, constants;</paragraph>
 <paragraph index="740" node_type="writer" parent_index="435">expressions (including assertions);</paragraph>
 <paragraph index="741" node_type="writer" parent_index="435">statements.</paragraph>
 <paragraph index="742" node_type="writer" parent_index="435">It makes various adjustments to the existing model attributes and classes. The BMM remains compatible with P_BMM 2.x, i.e. any existing .bmm file can be parsed to create a v 3.1.0 BMM instance.</paragraph>
 <paragraph index="743" node_type="writer" parent_index="435">1.6. A Note on Language</paragraph>
 <paragraph index="744" node_type="writer" parent_index="435">The elements of meta-models are sometimes named confusingly in the literature and within various programming language technologies. In this specification, we use the following terms:</paragraph>
 <paragraph index="745" node_type="writer" parent_index="435">class </paragraph>
 <paragraph index="746" node_type="writer" parent_index="435">generally refers to a class defined in a model expressed in BMM, i.e. an instance of a BMM meta-class;</paragraph>
 <paragraph index="747" node_type="writer" parent_index="435">meta-class </paragraph>
 <paragraph index="748" node_type="writer" parent_index="435">refers to a class in the BMM itself, such as BMM_CLASS, in order to clearly distinguish it from classes defined in models represented using BMM;</paragraph>
 <paragraph index="749" node_type="writer" parent_index="435">feature (of a class) </paragraph>
 <paragraph index="750" node_type="writer" parent_index="435">any stored or computed element of a class, including constants, attributes (properties) and routines (methods);</paragraph>
 <paragraph index="751" node_type="writer" parent_index="435">property </paragraph>
 <paragraph index="752" node_type="writer" parent_index="435">a stored class feature; also known as 'attribute';</paragraph>
 <paragraph index="753" node_type="writer" parent_index="435">routine </paragraph>
 <paragraph index="754" node_type="writer" parent_index="435">a computed class feature that may be either value-returning (a function) or work-performing (a procedure);</paragraph>
 <paragraph index="755" node_type="writer" parent_index="435">function </paragraph>
 <paragraph index="756" node_type="writer" parent_index="435">a routine that computes and returns a value; typically causes no side-effects in the object;</paragraph>
 <paragraph index="757" node_type="writer" parent_index="435">procedure </paragraph>
 <paragraph index="758" node_type="writer" parent_index="435">a routine that performs a computation; typically has side-effects;</paragraph>
 <paragraph index="759" node_type="writer" parent_index="435">generic (class or type) </paragraph>
 <paragraph index="760" node_type="writer" parent_index="435">a kind of class or type that has parameters of other types; known as 'template' type in some programming languages;</paragraph>
 <paragraph index="761" node_type="writer" parent_index="435">type </paragraph>
 <paragraph index="762" node_type="writer" parent_index="435">generally refers to a type defined in a model expressed in BMM, i.e. an instance of a BMM meta-type;</paragraph>
 <paragraph index="763" node_type="writer" parent_index="435">meta-type </paragraph>
 <paragraph index="764" node_type="writer" parent_index="435">refers to a type in the BMM itself, which is either a class (such as BMM_CLASS) or generically derived (meta-)type in the sense of being an instance generator, where the instances will be concrete type definitions in models represented using BMM.</paragraph>
 <paragraph index="765" node_type="writer" parent_index="435">1.7. Tooling</paragraph>
 <paragraph index="766" node_type="writer" parent_index="435">The openEHR Archie Library fully implements this specification in Java and may be used to build UI tools for compiling, viewing and editing BMM models.</paragraph>
 <paragraph index="767" node_type="writer" parent_index="435">The openEHR ADL Workbench (AWB) fully implements this specification, and provides a convenient way of illustrating BMM semantics. The screenshots used in this specification are all from the ADL Workbench. The tool is written in the Eiffel language, and is available as open source on Github. The BMM libraries can be found in the EOMF Github repository.</paragraph>
 <paragraph index="768" node_type="writer" parent_index="435">2. Overview</paragraph>
 <paragraph index="769" node_type="writer" parent_index="435">2.1. Introduction</paragraph>
 <paragraph index="770" node_type="writer" parent_index="435">One of the key needs in any open computing environment is a computable representation of its own models. This is for a number of purposes, including reasoning about them, performing validation and consistency checking, building software and generating documentation. This is particularly true of openEHR and other archetype-based frameworks, where a further need is to be able to validate archetypes and templates with respect to the reference model, and also to validate runtime instance data against operational templates and the reference model.</paragraph>
 <paragraph index="771" node_type="writer" parent_index="435">A number of computable representations of the openEHR published models have been available in the past. Currently models are represented in two computable forms, namely UML and BMM (i.e. the format described in this specification).</paragraph>
 <paragraph index="772" node_type="writer" parent_index="435">The primary use of the UML expression is for specification publishing. In this role, UML diagrams and static models are built, and then post-processed to correct signatures of class properties and functions. The post-processing corrects UML’s shortcomings and errors in non-singular relations, generic (template) types, and qualified attributes. The result can be used for publishing documentation with feature signatures that are formally correct and will be understood by developers in most programming languages. It can also be serialised and used computably, e.g. in other visualisation or modelling tools. UML’s own serial format, XMI is thus generally unsuitable for such uses, due to the formal errors, as well as its excessive complexity. XMI is also notoriously non-standard across UML tools.</paragraph>
 <paragraph index="773" node_type="writer" parent_index="435">As a result, openEHR introduced the Basic Meta-Model (BMM) in 2009 as a way of representing correct object-oriented semantics of information models for use in tools, along with a serial format by default expressed in the openEHR ODIN syntax.</paragraph>
 <paragraph index="774" node_type="writer" parent_index="435">The BMM provides a standalone alternative to UML/XMI which correctly represents all types, including open and closed generic types, inheritance of generic types, and various other problems with UML. As a meta-model it is adapted to the task, i.e. representing entity types that can appear in object models, rather than the over-generalised semantics of the UML meta-model. This reduced scope, and the fact that it contains no diagram semantics enables its serial form to be human-readable.</paragraph>
 <paragraph index="775" node_type="writer" parent_index="435">2.2. Features</paragraph>
 <paragraph index="776" node_type="writer" parent_index="435">The Basic Meta-Model supports the representation of object models in the ISO RM/ODP information and computational points of view, i.e. in programming terms:</paragraph>
 <paragraph index="777" node_type="writer" parent_index="435">definition of classes, properties and methods;</paragraph>
 <paragraph index="778" node_type="writer" parent_index="435">delayed routine calls as first-class objects;</paragraph>
 <paragraph index="779" node_type="writer" parent_index="435">expressions.</paragraph>
 <paragraph index="780" node_type="writer" parent_index="435">It is designed to enable both human authoring and machine processing, including e.g. extraction of BMM textual schemas from a UML tool or programming language classes. The semantics of the model are heavily influenced by the formal approach to object-orientation described by Bertrand Meyer in Object-oriented Software Construction (Meyer, 1997) and also the Eiffel language, which is significantly better basis for object modelling than the UML 2.x meta-model. The BMM consequently departs from UML in a number of significant ways, and also from the OOSC/Eiffel approach in some aspects (e.g. direct meta-type suport for container types). Its key features are as follows:</paragraph>
 <paragraph index="781" node_type="writer" parent_index="435">OO+FP: the Basic Meta-Model is directly based on a combination of Object-oriented class model, functional programming concepts and expression language, rather than being a highly general model like the UML meta-model;</paragraph>
 <paragraph index="782" node_type="writer" parent_index="435">Proper type meta-model: types and Classes are distinguished in the meta-model, unlike UML which has no proper formal concept of type beyond a textual name;</paragraph>
 <paragraph index="783" node_type="writer" parent_index="435">Full generic types: types as first-order entities enables the proper representation of generic typing and inheritance from open, closed, or partially open generic types, unlike in UML;</paragraph>
 <paragraph index="784" node_type="writer" parent_index="435">Container types: such as List&lt;T&gt; and Hash&lt;K,V&gt; have their own meta-types;</paragraph>
 <paragraph index="785" node_type="writer" parent_index="435">Enumerated types: supported via the notion of 'range-constrained' classes and also references to external value sets;</paragraph>
 <paragraph index="786" node_type="writer" parent_index="435">Built-in Expression Language: fully defined expression meta-model supporting literals, properties, variables, function calls and agents; includes qualifiers;</paragraph>
 <paragraph index="787" node_type="writer" parent_index="435">Design by contract (DbC): formally supported via class invariants and routine pre- and post-conditions;</paragraph>
 <paragraph index="788" node_type="writer" parent_index="435">Operator / function aliasing: support for mapping symbolic operators to function definitions.</paragraph>
 <paragraph index="789" node_type="writer" parent_index="435">Functional elements are supported via the inclusion of meta-types representing signatures and tuples, enabling the construction of delayed agent calls, known here as agents, and function applications (i.e. function calls).</paragraph>
 <paragraph index="790" node_type="writer" parent_index="435">Note that there is no BMM entity for graphical diagramming semantics. Thus, there is no idea of 'association' distinct from an 'attribute', as per UML, which treats lines between class boxes as formal elements.</paragraph>
 <paragraph index="791" node_type="writer" parent_index="435">2.3. Current State of the Art</paragraph>
 <paragraph index="792" node_type="writer" parent_index="435">2.3.1. UML</paragraph>
 <paragraph index="793" node_type="writer" parent_index="435">One would expect that the IT industry would have fully computable representations of models and diagramming solved, but it is not yet the case. UML 2.x and its associated serialisation format XMI 2.x should in theory mean that complete, interoperable machine expressions of object models would be available in all tools. However the evolution of UML and XMI has not been toward a clear meta-model and language for each of its sub-languages (i.e. static class model, state machine, interaction diagram etc) but rather toward a single universal model of everything in which elements of all of its needs are confusingly buried.</paragraph>
 <paragraph index="794" node_type="writer" parent_index="435">The UML 2.x specifications are exceedingly complex: UML 2.1.2 was specified by two documents, 'Superstructure' (738pp) and 'Infrastructure' (224pp); the UML 2.5.1 specification is only slightly smaller at 796 pages (see the OMG UML page for current specifications). The XMI 2.x specification is correspondingly complex, which seems to have so far prevented reliable tool interoperability (recognised as a critical issue by OMG in 2015). Despite the complexity, there are significant limitations in the UML meta-model, including:</paragraph>
 <paragraph index="795" node_type="writer" parent_index="435">the composite or association nature of a class property only being known if it is represented as an association, i.e. a line linking two classes on a UML diagram;</paragraph>
 <paragraph index="796" node_type="writer" parent_index="435">the notion of type is not adequately formalised;</paragraph>
 <paragraph index="797" node_type="writer" parent_index="435">the meta-model of generic types and container properties is problematic and does not map well to object programming languages;</paragraph>
 <paragraph index="798" node_type="writer" parent_index="435">the Design By Contract (DbC) concept (i.e. pre-, post-conditions, class invariants), crucial for proper specifications, is in theory supported via the use of OCL 2.0 constraints in class definitions, but OCL suffers from the same underlying semantic weaknesses as UML;</paragraph>
 <paragraph index="799" node_type="writer" parent_index="435">there is no direct support for functional entities, i.e. routine calls as objects (aka 'lambdas').</paragraph>
 <paragraph index="800" node_type="writer" parent_index="435">Experience with various UML tools (up till 2015) highlighted the following problems:</paragraph>
 <paragraph index="801" node_type="writer" parent_index="435">poor support for OCL and design by contract in most tools;</paragraph>
 <paragraph index="802" node_type="writer" parent_index="435">variable support for generic (i.e. template) classes; even those tools that properly implement the UML 2.5 specification are still very hard to use for defining generic classes because of problems in the specification that remain unaddressed;</paragraph>
 <paragraph index="803" node_type="writer" parent_index="435">problems with qualified attributes, which are used to represent identifier references to objects rather than direct references;</paragraph>
 <paragraph index="804" node_type="writer" parent_index="435">variable support for XSD generation across tools, where the results are wildly wrong in some tools;</paragraph>
 <paragraph index="805" node_type="writer" parent_index="435">in some tools, it is impossible to define an abstract formal model - the only option is to select a particular programming language profile such as Java or C# and thus get locked into the limitations of those languages (messy type systems, weak inheritance semantics, language-specific notion of types such as Array&lt;T&gt;, List&lt;T&gt;, etc.).</paragraph>
 <paragraph index="806" node_type="writer" parent_index="435">Since 2015, the quality of some UML tools has improved, and the XMI generated by some is more reliable. However, XMI generated by different tools is not the same for identical models, and some XMI importers offer numerous switches in order to process the XMI of another tool properly. XMI thus still needs to be processed with care.</paragraph>
 <paragraph index="807" node_type="writer" parent_index="435">Nevertheless, a small number of tools, including MagicDraw (currently used for representing openEHR models for the specifications) and Rational Software Architect (RSA), appear to implement UML 2.5 faithfully. This means that despite the limitations of UML 2.5 (as noted above), models expressed in it can be mostly correctly interpreted and corrected by post-processing for purposes such as code generation and specifications publishing.</paragraph>
 <object index="808" name="Table5" object_type="table"/>
 <paragraph index="810" node_type="writer" parent_index="808">Note</paragraph>
 <paragraph index="813" node_type="writer" parent_index="808">Other tools may perform as well or better, and in any case, all tools change over time. No endorsement of a particular tool is intended here. </paragraph>
 <paragraph index="816" node_type="writer" parent_index="435">2.3.2. XML Schema</paragraph>
 <paragraph index="817" node_type="writer" parent_index="435">For some, W3C XML schema represents a way of expressing object models, but it is not semantically suitable for this purpose, primarily due to its problematic non-object-oriented inheritance semantics, lack of generic classes, lack of representation of non-data members, and only marginal support for design by contract. It can be and is often used (including in openEHR) as a derivative serialisation representation.</paragraph>
 <paragraph index="818" node_type="writer" parent_index="435">2.4. Computational Model</paragraph>
 <paragraph index="819" node_type="writer" parent_index="435">The BMM is specified as a structural model representing an abstract syntax tree (AST), which is the result of either in-memory construction (such as by a model authoring tool) or by parsing of a serialised representation of a BMM model. It does not specify an abstract syntax, and indeed, more than one concrete syntax could be parsed to a BMM instance.</paragraph>
 <object index="820" name="Table6" object_type="table"/>
 <paragraph index="822" node_type="writer" parent_index="820">Note</paragraph>
 <paragraph index="825" node_type="writer" parent_index="820">for the purposes of explanation, an abstract syntax is used throughout this document that draws freely from mainstream modelling and programming languages. </paragraph>
 <paragraph index="828" node_type="writer" parent_index="435">2.5. Purpose of the BMM</paragraph>
 <paragraph index="829" node_type="writer" parent_index="435">2.5.1. Class Model Representation</paragraph>
 <paragraph index="830" node_type="writer" parent_index="435">The BMM from version 3.0.0 on may be used to represent a full class model at an interface level (i.e. without code for methods) including classes, types, and class feature types including property (i.e. attribute), symbolic constant, manifest value, functions, operators, and procedures.</paragraph>
 <paragraph index="831" node_type="writer" parent_index="435">2.5.2. Meta-Model for Expressions Language</paragraph>
 <paragraph index="832" node_type="writer" parent_index="435">The BMM provides a system of meta-types that act as the basis for a typed expression language. These include references to static entities in scope (constants, variables, properties), literal values, construction of agents (lambda terms), and function calls (lambda applications).</paragraph>
 <paragraph index="833" node_type="writer" parent_index="435">2.5.3. Information Model Representation</paragraph>
 <paragraph index="834" node_type="writer" parent_index="435">Until version 3.0.0, BMM supported only the information point of view, i.e. no computational interface, and in that form, it is often used to express models of data. Tools based on BMM can provide views of an object model expressed in BMM that are particularly useful to information modelling, such as the 'closure' view show below. This is a computed reachability graph of a fully inheritance-flattened class and all properties, including recursive references.</paragraph>
 <object index="835" name="awb_class_closure" object_type="section"/>
 <paragraph index="836" node_type="writer" parent_index="835"> </paragraph>
 <paragraph index="837" node_type="writer" parent_index="835">Figure 1. BMM class - closure view</paragraph>
 <paragraph index="839" node_type="writer" parent_index="435">2.5.4. Archetype Modelling</paragraph>
 <paragraph index="840" node_type="writer" parent_index="435">One of the uses of the BMM in the openEHR ADL Workbench and other similar tools is to provide a computable form of the information model for use with domain-level content models, such as archetypes. The following shows an archetype for which each node has its class shown (in colour), and additionally, the inclusion of non-archetyped attributes from the classes of the archetype nodes.</paragraph>
 <object index="841" name="archetype_rm" object_type="section"/>
 <paragraph index="842" node_type="writer" parent_index="841"> </paragraph>
 <paragraph index="843" node_type="writer" parent_index="841">Figure 2. ADL archetype with BMM class properties</paragraph>
 <paragraph index="845" node_type="writer" parent_index="435">Newer tools are able to include the computational features.</paragraph>
 <paragraph index="846" node_type="writer" parent_index="435">The openEHR project makes extensive use of BMM for representing its models for use in tools. The full set of openEHR models in BMM format may be found in the specfications-ITS-BMM repository on Github.</paragraph>
 <paragraph index="847" node_type="writer" parent_index="435">3. Package Structure</paragraph>
 <paragraph index="848" node_type="writer" parent_index="435">3.1. Overview</paragraph>
 <paragraph index="849" node_type="writer" parent_index="435">The BMM packages are as follows:</paragraph>
 <paragraph index="850" node_type="writer" parent_index="435">org.openehr.lang.bmm: the BMM</paragraph>
 <paragraph index="851" node_type="writer" parent_index="435">model_access: the interface to most features including schema load/reload, generally used by an application as a reflection library;</paragraph>
 <paragraph index="852" node_type="writer" parent_index="435">core: the core BMM classes used for in-memory representation of an object model. This consists of a number of sub-packages:</paragraph>
 <paragraph index="853" node_type="writer" parent_index="435">model: meta-types representing models and packages;</paragraph>
 <paragraph index="854" node_type="writer" parent_index="435">entity: meta-types representing classes and types including enumeration types, represented in the range_constrained sub-package;</paragraph>
 <paragraph index="855" node_type="writer" parent_index="435">feature: meta-types representing classes features, i.e. constants, routines, properties;</paragraph>
 <paragraph index="856" node_type="writer" parent_index="435">literal_value: meta-types representing literal values;</paragraph>
 <paragraph index="857" node_type="writer" parent_index="435">expression: an expression meta-model sufficient for expressing first-order predicate logic expressions, including class invariants and pre- and post-conditions.</paragraph>
 <paragraph index="858" node_type="writer" parent_index="435">Related packages are:</paragraph>
 <paragraph index="859" node_type="writer" parent_index="435">the org.openehr.lang.bmm_persistence package, described in the BMM Persistence specification, which contains the BMM Persistence classes.</paragraph>
 <paragraph index="860" node_type="writer" parent_index="435">These are illustrated below.</paragraph>
 <object index="861" name="package_overview" object_type="section"/>
 <paragraph index="862" node_type="writer" parent_index="861"> </paragraph>
 <paragraph index="863" node_type="writer" parent_index="861">Figure 3. Package Overview</paragraph>
 <paragraph index="865" node_type="writer" parent_index="435">3.2. Class Definitions</paragraph>
 <paragraph index="866" node_type="writer" parent_index="435">3.2.1. BMM_DEFINITIONS Class</paragraph>
 <object index="867" name="Table7" object_type="table"/>
 <paragraph index="869" node_type="writer" parent_index="867">Class</paragraph>
 <paragraph index="872" node_type="writer" parent_index="867">BMM_DEFINITIONS</paragraph>
 <paragraph index="875" node_type="writer" parent_index="867">Description</paragraph>
 <paragraph index="878" node_type="writer" parent_index="867">Definitions used by all BMM packages.</paragraph>
 <paragraph index="881" node_type="writer" parent_index="867">Inherit</paragraph>
 <paragraph index="884" node_type="writer" parent_index="867">BASIC_DEFINITIONS</paragraph>
 <paragraph index="887" node_type="writer" parent_index="867">Constants</paragraph>
 <paragraph index="890" node_type="writer" parent_index="867">Signature</paragraph>
 <paragraph index="893" node_type="writer" parent_index="867">Meaning</paragraph>
 <paragraph index="896" node_type="writer" parent_index="867">1..1</paragraph>
 <paragraph index="899" node_type="writer" parent_index="867">Bmm_internal_version: String</paragraph>
 <paragraph index="902" node_type="writer" parent_index="867">Current internal version of BMM meta-model, used to determine if a given schema can be processed by a given implementation of the model.</paragraph>
 <paragraph index="905" node_type="writer" parent_index="867">1..1</paragraph>
 <paragraph index="908" node_type="writer" parent_index="867">Schema_name_delimiter: String = &quot;::&quot;</paragraph>
 <paragraph index="911" node_type="writer" parent_index="867">Delimiter used to separate schema id from package path in a fully qualified path.</paragraph>
 <paragraph index="914" node_type="writer" parent_index="867">1..1</paragraph>
 <paragraph index="917" node_type="writer" parent_index="867">Package_name_delimiter: String = &quot;.&quot;</paragraph>
 <paragraph index="920" node_type="writer" parent_index="867">Delimiter used to separate package names in a package path.</paragraph>
 <paragraph index="923" node_type="writer" parent_index="867">1..1</paragraph>
 <paragraph index="926" node_type="writer" parent_index="867">Bmm_schema_file_extension: String = &quot;.bmm&quot;</paragraph>
 <paragraph index="929" node_type="writer" parent_index="867">Extension used for BMM files.</paragraph>
 <paragraph index="932" node_type="writer" parent_index="867">1..1</paragraph>
 <paragraph index="935" node_type="writer" parent_index="867">Type_delimiter: Character = ':'</paragraph>
 <paragraph index="938" node_type="writer" parent_index="867">Appears between a name and a type in a declaration or type signature.</paragraph>
 <paragraph index="941" node_type="writer" parent_index="867">1..1</paragraph>
 <paragraph index="944" node_type="writer" parent_index="867">Generic_left_delimiter: Character = '&lt;'</paragraph>
 <paragraph index="947" node_type="writer" parent_index="867">Left delimiter for generic class and generic type names, as used in List&lt;T&gt;.</paragraph>
 <paragraph index="950" node_type="writer" parent_index="867">1..1</paragraph>
 <paragraph index="953" node_type="writer" parent_index="867">Generic_right_delimiter: Character = '&gt;'</paragraph>
 <paragraph index="956" node_type="writer" parent_index="867">Right delimiter for generic class and generic type names, as used in List&lt;T&gt;.</paragraph>
 <paragraph index="959" node_type="writer" parent_index="867">1..1</paragraph>
 <paragraph index="962" node_type="writer" parent_index="867">Generic_separator: Character = ','</paragraph>
 <paragraph index="965" node_type="writer" parent_index="867">Separator used in Generic types.</paragraph>
 <paragraph index="968" node_type="writer" parent_index="867">1..1</paragraph>
 <paragraph index="971" node_type="writer" parent_index="867">Generic_constraint_delimiter: Character = ':'</paragraph>
 <paragraph index="974" node_type="writer" parent_index="867">Delimiter between formal type parameter and constraint type, as used in Sortable&lt;T: Ordered&gt;.</paragraph>
 <paragraph index="977" node_type="writer" parent_index="867">1..1</paragraph>
 <paragraph index="980" node_type="writer" parent_index="867">Tuple_left_delim: Character = '['</paragraph>
 <paragraph index="983" node_type="writer" parent_index="867">Left delimiter of a Tuple type and also instance. Example:</paragraph>
 <paragraph index="984" node_type="writer" parent_index="867">[Integer, String] - a tuple type;</paragraph>
 <paragraph index="985" node_type="writer" parent_index="867">[3, &quot;Quixote&quot;] - a tuple.</paragraph>
 <paragraph index="988" node_type="writer" parent_index="867">1..1</paragraph>
 <paragraph index="991" node_type="writer" parent_index="867">Tuple_right_delim: Character = ']'</paragraph>
 <paragraph index="994" node_type="writer" parent_index="867">Right delimiter of a Tuple type and also instance.</paragraph>
 <paragraph index="997" node_type="writer" parent_index="867">1..1</paragraph>
 <paragraph index="1000" node_type="writer" parent_index="867">Tuple_separator: Character = ','</paragraph>
 <paragraph index="1003" node_type="writer" parent_index="867">Separator used in Tuple types and instances.</paragraph>
 <paragraph index="1006" node_type="writer" parent_index="867">1..1</paragraph>
 <paragraph index="1009" node_type="writer" parent_index="867">Constraint_left_delim: Character = '«'</paragraph>
 <paragraph index="1012" node_type="writer" parent_index="867">Left delimiter used in serial form of instance constrained enumeration.</paragraph>
 <paragraph index="1015" node_type="writer" parent_index="867">1..1</paragraph>
 <paragraph index="1018" node_type="writer" parent_index="867">Constraint_right_delim: Character = '»'</paragraph>
 <paragraph index="1021" node_type="writer" parent_index="867">Right delimiter used in serial form of instance constrained enumeration.</paragraph>
 <paragraph index="1024" node_type="writer" parent_index="867">1..1</paragraph>
 <paragraph index="1027" node_type="writer" parent_index="867">Metadata_bmm_version: String = &quot;bmm_version&quot;</paragraph>
 <paragraph index="1030" node_type="writer" parent_index="867">Attribute name of logical attribute 'bmm_version' in .bmm schema file.</paragraph>
 <paragraph index="1033" node_type="writer" parent_index="867">1..1</paragraph>
 <paragraph index="1036" node_type="writer" parent_index="867">Metadata_schema_name: String = &quot;schema_name&quot;</paragraph>
 <paragraph index="1039" node_type="writer" parent_index="867">Attribute name of logical attribute 'schema_name' in .bmm schema file.</paragraph>
 <paragraph index="1042" node_type="writer" parent_index="867">1..1</paragraph>
 <paragraph index="1045" node_type="writer" parent_index="867">Metadata_rm_publisher: String = &quot;rm_publisher&quot;</paragraph>
 <paragraph index="1048" node_type="writer" parent_index="867">Attribute name of logical attribute 'rm_publisher' in .bmm schema file.</paragraph>
 <paragraph index="1051" node_type="writer" parent_index="867">1..1</paragraph>
 <paragraph index="1054" node_type="writer" parent_index="867">Metadata_rm_release: String = &quot;rm_release&quot;</paragraph>
 <paragraph index="1057" node_type="writer" parent_index="867">Attribute name of logical attribute 'rm_release' in .bmm schema file.</paragraph>
 <paragraph index="1060" node_type="writer" parent_index="867">1..1</paragraph>
 <paragraph index="1063" node_type="writer" parent_index="867">Metadata_schema_revision: String = &quot;schema_revision&quot;</paragraph>
 <paragraph index="1066" node_type="writer" parent_index="867">Attribute name of logical attribute 'schema_revision' in .bmm schema file.</paragraph>
 <paragraph index="1069" node_type="writer" parent_index="867">1..1</paragraph>
 <paragraph index="1072" node_type="writer" parent_index="867">Metadata_schema_lifecycle_state: String = &quot;schema_lifecycle_state&quot;</paragraph>
 <paragraph index="1075" node_type="writer" parent_index="867">Attribute name of logical attribute 'schema_lifecycle_state' in .bmm schema file.</paragraph>
 <paragraph index="1078" node_type="writer" parent_index="867">1..1</paragraph>
 <paragraph index="1081" node_type="writer" parent_index="867">Metadata_schema_description: String = &quot;schema_description&quot;</paragraph>
 <paragraph index="1084" node_type="writer" parent_index="867">Attribute name of logical attribute 'schema_description' in .bmm schema file.</paragraph>
 <paragraph index="1087" node_type="writer" parent_index="867">1..1</paragraph>
 <paragraph index="1090" node_type="writer" parent_index="867">Metadata_schema_path: String = &quot;schema_path&quot;</paragraph>
 <paragraph index="1093" node_type="writer" parent_index="867">Path of schema file.</paragraph>
 <paragraph index="1096" node_type="writer" parent_index="867">Functions</paragraph>
 <paragraph index="1099" node_type="writer" parent_index="867">Signature</paragraph>
 <paragraph index="1102" node_type="writer" parent_index="867">Meaning</paragraph>
 <paragraph index="1105" node_type="writer" parent_index="867">1..1</paragraph>
 <paragraph index="1108" node_type="writer" parent_index="867">Any_class (): BMM_SIMPLE_CLASS</paragraph>
 <paragraph index="1111" node_type="writer" parent_index="867">built-in class definition corresponding to the top `Any' class.</paragraph>
 <paragraph index="1114" node_type="writer" parent_index="867">1..1</paragraph>
 <paragraph index="1117" node_type="writer" parent_index="867">Any_type (): BMM_SIMPLE_TYPE</paragraph>
 <paragraph index="1120" node_type="writer" parent_index="867">Built-in type definition corresponding to the top `Any' type.</paragraph>
 <paragraph index="1123" node_type="writer" parent_index="867">1..1</paragraph>
 <paragraph index="1126" node_type="writer" parent_index="867">create_schema_id (
a_model_publisher,
a_schema_name,
a_model_release: String[1]
): String</paragraph>
 <paragraph index="1129" node_type="writer" parent_index="867">Create schema id, formed from:</paragraph>
 <paragraph index="1130" node_type="writer" parent_index="867">a_model_publisher '-' a_schema_name '-' a_model_release</paragraph>
 <paragraph index="1131" node_type="writer" parent_index="867">e.g. openehr_rm_1.0.3, openehr_test_1.0.1, iso_13606_1_2008_2.1.2.</paragraph>
 <paragraph index="1134" node_type="writer" parent_index="435">4. Model Access Package</paragraph>
 <paragraph index="1135" node_type="writer" parent_index="435">4.1. Overview</paragraph>
 <object index="1136" name="Table8" object_type="table"/>
 <paragraph index="1138" node_type="writer" parent_index="1136">Note</paragraph>
 <paragraph index="1141" node_type="writer" parent_index="1136">This package is considered informative within this specification. </paragraph>
 <paragraph index="1144" node_type="writer" parent_index="435">The org.openehr.lang.bmm.model_access package provides an interface for the application to load BMM schemas and convert them to BMM model form, and is shown below. In this model, a schema is the serial form of a model or part of a model (i.e. instances of a persistence model like the lang.bmm_persistence model P_XXX classes). One or more schema files are parsed, validated and then converted to create a single BMM_MODEL instance.</paragraph>
 <object index="1145" name="model_access_package" object_type="section"/>
 <paragraph index="1146" node_type="writer" parent_index="1145"> </paragraph>
 <paragraph index="1147" node_type="writer" parent_index="1145">Figure 4. lang.bmm.model_access Package</paragraph>
 <paragraph index="1149" node_type="writer" parent_index="435">More than one format for representing serialised BMM models is possible, each having its load, validation and error-reporting logic. The common elements of the load, validate and convert logic are defined by the non format-specific classes in the package, with specific forms of the classes BMM_SCHEMA_DESCRIPTOR and BMM_SCHEMA required for each concrete format. The package above shows the relevant classes for the P_BMM version 2.x format, which is normally saved in .bmm files. Other formats may be saved in files with different extensions.</paragraph>
 <paragraph index="1150" node_type="writer" parent_index="435">The singleton class BMM_MODEL_ACCESS acts as the entry point for client software to obtain access to loaded BMM models. Since the latter start as schema files which are typically nested according to an 'include' hierarchy, they must be parsed, validated and merged to create each 'top-level' model. The schemas are accessed via instances of the BMM_SCHEMA_DESCRIPTOR object, one for each schema file. The load() routine of this class loads a BMM schema file by direct deserialisation.</paragraph>
 <paragraph index="1151" node_type="writer" parent_index="435">If the file is structurally correct (say ODIN, JSON etc), an in-memory schema instance will result (e.g. P_BMM_SCHEMA in the case of the P_BMM format), and its validate_created method called. If this succeeds, BMM_SCHEMA_DESCRIPTOR.bmm_schema will be set to this instance, of type BMM_SCHEMA. Subsequently, BMM_SCHEMA.merge() will be called repeatedly, which results in each bmm_schema instance being the merged result of its include children and itself. After merging, BMM_SCHEMA_DESCRIPTOR.validate_merged() will be called, and if successful, a call to create_model() will result in BMM_SCHEMA_DESCRIPTOR.model being populated.</paragraph>
 <paragraph index="1152" node_type="writer" parent_index="435">Each successfully loaded model is thus instantiated as a BMM_MODEL, and retrievable by calling BMM_MODEL_ACCESS.bmm_model() with a model key, which is a model identifier with full, partial or no version part. In the latter cases, the most recent version model is retrieved for the key. For example, the keys &quot;openEHR_EHR_1.0.4&quot;, &quot;openEHR_EHR_1.0&quot;, &quot;openEHR_EHR_1&quot;, and &quot;openEHR_EHR&quot; will all match the &quot;openEHR_EHR_1.0.4&quot; model, assuming it is the most recent version available. This is convenient for matching models to artefacts (e.g. archetypes) that only mention the model publisher and name, but no version.</paragraph>
 <paragraph index="1153" node_type="writer" parent_index="435">The following screenshot shows the BMM schema configuration dialog in the openEHR ADL Workbench, including some meta-data, validation status etc, and also the schema nesting structure. A single hierarchy of schemas corresponds to a single instantiated BMM model.</paragraph>
 <object index="1154" name="awb_schemas_config" object_type="section"/>
 <paragraph index="1155" node_type="writer" parent_index="1154"> </paragraph>
 <paragraph index="1156" node_type="writer" parent_index="1154">Figure 5. BMM schema configuration</paragraph>
 <paragraph index="1158" node_type="writer" parent_index="435">The screenshot below shows a number of merged BMM models loaded into the AWB, including some of the packages and classes for the openehr_ehr_extract_1.0.4 model.</paragraph>
 <object index="1159" name="awb_loaded_bmm_schemas" object_type="section"/>
 <paragraph index="1160" node_type="writer" parent_index="1159"> </paragraph>
 <paragraph index="1161" node_type="writer" parent_index="1159">Figure 6. BMM schemas loaded</paragraph>
 <paragraph index="1163" node_type="writer" parent_index="435">4.2. Class Definitions</paragraph>
 <paragraph index="1164" node_type="writer" parent_index="435">4.2.1. BMM_MODEL_ACCESS Class</paragraph>
 <object index="1165" name="Table9" object_type="table"/>
 <paragraph index="1167" node_type="writer" parent_index="1165">Class</paragraph>
 <paragraph index="1170" node_type="writer" parent_index="1165">BMM_MODEL_ACCESS</paragraph>
 <paragraph index="1173" node_type="writer" parent_index="1165">Description</paragraph>
 <paragraph index="1176" node_type="writer" parent_index="1165">Access to BMM models that have been loaded and validated from one or more schema sets.</paragraph>
 <paragraph index="1179" node_type="writer" parent_index="1165">Attributes</paragraph>
 <paragraph index="1182" node_type="writer" parent_index="1165">Signature</paragraph>
 <paragraph index="1185" node_type="writer" parent_index="1165">Meaning</paragraph>
 <paragraph index="1188" node_type="writer" parent_index="1165">0..1</paragraph>
 <paragraph index="1191" node_type="writer" parent_index="1165">schema_directories: List&lt;String&gt;</paragraph>
 <paragraph index="1194" node_type="writer" parent_index="1165">List of directories where all the schemas loaded here are found.</paragraph>
 <paragraph index="1197" node_type="writer" parent_index="1165">0..1</paragraph>
 <paragraph index="1200" node_type="writer" parent_index="1165">all_schemas: Hash&lt;String,BMM_SCHEMA_DESCRIPTOR&gt;</paragraph>
 <paragraph index="1203" node_type="writer" parent_index="1165">All schemas found and loaded from schema_directory. Keyed by schema_id.</paragraph>
 <paragraph index="1206" node_type="writer" parent_index="1165">0..1</paragraph>
 <paragraph index="1209" node_type="writer" parent_index="1165">bmm_models: Hash&lt;String,BMM_MODEL&gt;</paragraph>
 <paragraph index="1212" node_type="writer" parent_index="1165">Top-level (root) models in use, keyed by model_id.</paragraph>
 <paragraph index="1215" node_type="writer" parent_index="1165">0..1</paragraph>
 <paragraph index="1218" node_type="writer" parent_index="1165">matching_bmm_models: Hash&lt;String,BMM_MODEL&gt;</paragraph>
 <paragraph index="1221" node_type="writer" parent_index="1165">Validated models, keyed by model_id() and any shorter forms of id, with some or no versioning information. For example, the keys &quot;openEHR_EHR_1.0.4&quot;, &quot;openEHR_EHR_1.0&quot;, &quot;openEHR_EHR_1&quot;, and &quot;openEHR_EHR&quot; will all match the &quot;openEHR_EHR_1.0.4&quot; model, assuming it is the most recent version available.</paragraph>
 <paragraph index="1224" node_type="writer" parent_index="1165">Functions</paragraph>
 <paragraph index="1227" node_type="writer" parent_index="1165">Signature</paragraph>
 <paragraph index="1230" node_type="writer" parent_index="1165">Meaning</paragraph>
 <paragraph index="1233" node_type="writer" parent_index="1165">0..1</paragraph>
 <paragraph index="1236" node_type="writer" parent_index="1165">initialise_with_load_list (
a_schema_dirs: List&lt;String&gt;[1],
a_schema_load_list: List&lt;String&gt;[0..1]
)</paragraph>
 <paragraph index="1239" node_type="writer" parent_index="1165">Initialise with a specific schema load list, usually a sub-set of schemas that will be found in a specified directories a_schema_dirs.</paragraph>
 <paragraph index="1242" node_type="writer" parent_index="1165">0..1</paragraph>
 <paragraph index="1245" node_type="writer" parent_index="1165">initialise_all (
a_schema_dirs: List&lt;String&gt;[1]
)</paragraph>
 <paragraph index="1248" node_type="writer" parent_index="1165">Load all schemas found in a specified directories a_schema_dirs.</paragraph>
 <paragraph index="1251" node_type="writer" parent_index="1165">0..1</paragraph>
 <paragraph index="1254" node_type="writer" parent_index="1165">reload_schemas</paragraph>
 <paragraph index="1257" node_type="writer" parent_index="1165">Reload BMM schemas.</paragraph>
 <paragraph index="1260" node_type="writer" parent_index="1165">1..1</paragraph>
 <paragraph index="1263" node_type="writer" parent_index="1165">bmm_model (
a_model_key: String[1]
): BMM_MODEL</paragraph>
 <paragraph index="1266" node_type="writer" parent_index="1165">Return model containing the model key which is a model_id or any shorter form e.g. model id minus the version. If a shorter key is used, the BMM_MODEL with the most recent version will be selected. Uses matching_bmm_models table to find matches if partial version information is supplied in key.</paragraph>
 <paragraph index="1269" node_type="writer" parent_index="1165">1..1</paragraph>
 <paragraph index="1272" node_type="writer" parent_index="1165">has_bmm_model (
a_model_key: String[1]
): Boolean</paragraph>
 <paragraph index="1275" node_type="writer" parent_index="1165">True if a model for a model_key is available. A model key is a model_id or any shorter form e.g. model id minus the version. If a shorter key is used, the Result s True if a BMM_MODEL with any version exists.</paragraph>
 <paragraph index="1278" node_type="writer" parent_index="435">4.2.2. BMM_SCHEMA_DESCRIPTOR Class</paragraph>
 <object index="1279" name="Table10" object_type="table"/>
 <paragraph index="1281" node_type="writer" parent_index="1279">Class</paragraph>
 <paragraph index="1284" node_type="writer" parent_index="1279">BMM_SCHEMA_DESCRIPTOR (abstract)</paragraph>
 <paragraph index="1287" node_type="writer" parent_index="1279">Description</paragraph>
 <paragraph index="1290" node_type="writer" parent_index="1279">Descriptor for a BMM schema. Contains a meta-data table of attributes obtained from a mini-ODIN parse of the schema file.</paragraph>
 <paragraph index="1293" node_type="writer" parent_index="1279">Attributes</paragraph>
 <paragraph index="1296" node_type="writer" parent_index="1279">Signature</paragraph>
 <paragraph index="1299" node_type="writer" parent_index="1279">Meaning</paragraph>
 <paragraph index="1302" node_type="writer" parent_index="1279">0..1</paragraph>
 <paragraph index="1305" node_type="writer" parent_index="1279">bmm_schema: BMM_SCHEMA</paragraph>
 <paragraph index="1308" node_type="writer" parent_index="1279">Persistent form of model.</paragraph>
 <paragraph index="1311" node_type="writer" parent_index="1279">0..1</paragraph>
 <paragraph index="1314" node_type="writer" parent_index="1279">bmm_model: BMM_MODEL</paragraph>
 <paragraph index="1317" node_type="writer" parent_index="1279">Computable form of model.</paragraph>
 <paragraph index="1320" node_type="writer" parent_index="1279">1..1</paragraph>
 <paragraph index="1323" node_type="writer" parent_index="1279">schema_id: String</paragraph>
 <paragraph index="1326" node_type="writer" parent_index="1279">Schema id, formed by</paragraph>
 <paragraph index="1327" node_type="writer" parent_index="1279">{BMM_DEFINITIONS}.create_schema_id( meta_data.item({BMM_DEFINITIONS}.Metadata_model_publisher), meta_data.item({BMM_DEFINITIONS}.Metadata_schema_name), meta_data.item({BMM_DEFINITIONS}.Metadata_model_release)</paragraph>
 <paragraph index="1328" node_type="writer" parent_index="1279">e.g. openehr_rm_1.0.3, openehr_test_1.0.1, iso_13606_1_2008_2.1.2.</paragraph>
 <paragraph index="1331" node_type="writer" parent_index="1279">1..1</paragraph>
 <paragraph index="1334" node_type="writer" parent_index="1279">meta_data: Hash&lt;String, String&gt;</paragraph>
 <paragraph index="1337" node_type="writer" parent_index="1279">Table of {key, value} of schema meta-data, keys are string values defined by {BMM_DEFINITIONS}.Metadata_* constants.</paragraph>
 <paragraph index="1340" node_type="writer" parent_index="1279">0..1</paragraph>
 <paragraph index="1343" node_type="writer" parent_index="1279">includes: List&lt;String&gt;</paragraph>
 <paragraph index="1346" node_type="writer" parent_index="1279">Identifiers of schemas included by this schema.</paragraph>
 <paragraph index="1349" node_type="writer" parent_index="1279">Functions</paragraph>
 <paragraph index="1352" node_type="writer" parent_index="1279">Signature</paragraph>
 <paragraph index="1355" node_type="writer" parent_index="1279">Meaning</paragraph>
 <paragraph index="1358" node_type="writer" parent_index="1279">1..1</paragraph>
 <paragraph index="1361" node_type="writer" parent_index="1279">is_top_level (): Boolean</paragraph>
 <paragraph index="1364" node_type="writer" parent_index="1279">True if this is a top-level schema, i.e. is the root schema of a 'model'. True if bmm_schema /= Void and then bmm_schema.model_name /= Void.</paragraph>
 <paragraph index="1367" node_type="writer" parent_index="1279">1..1</paragraph>
 <paragraph index="1370" node_type="writer" parent_index="1279">is_bmm_compatible (): Boolean</paragraph>
 <paragraph index="1373" node_type="writer" parent_index="1279">True if the BMM version found in the schema (or assumed, if none) is compatible with that in this software.</paragraph>
 <paragraph index="1376" node_type="writer" parent_index="1279">0..1</paragraph>
 <paragraph index="1379" node_type="writer" parent_index="1279">load</paragraph>
 <paragraph index="1382" node_type="writer" parent_index="1279">Load schema into in-memory form, i.e. a P_BMM_SCHEMA instance, if structurally valid. If successful, p_schema will be set.</paragraph>
 <paragraph index="1385" node_type="writer" parent_index="1279">0..1</paragraph>
 <paragraph index="1388" node_type="writer" parent_index="1279">validate_merged</paragraph>
 <paragraph index="1391" node_type="writer" parent_index="1279">Validate loaded schema and report errors.</paragraph>
 <paragraph index="1394" node_type="writer" parent_index="1279">0..1</paragraph>
 <paragraph index="1397" node_type="writer" parent_index="1279">validate_includes (
all_schemas_list: List&lt;String&gt;[0..1]
)</paragraph>
 <paragraph index="1400" node_type="writer" parent_index="1279">Validate includes list for this schema, to see if each mentioned schema exists in all_schemas list.</paragraph>
 <paragraph index="1403" node_type="writer" parent_index="1279">0..1</paragraph>
 <paragraph index="1406" node_type="writer" parent_index="1279">create_model</paragraph>
 <paragraph index="1409" node_type="writer" parent_index="1279">Create schema, i.e. the BMM_MODEL from one P_BMM_SCHEMA schema.</paragraph>
 <paragraph index="1412" node_type="writer" parent_index="435">4.2.3. BMM_MODEL_METADATA Class</paragraph>
 <object index="1413" name="Table11" object_type="table"/>
 <paragraph index="1415" node_type="writer" parent_index="1413">Class</paragraph>
 <paragraph index="1418" node_type="writer" parent_index="1413">BMM_MODEL_METADATA</paragraph>
 <paragraph index="1421" node_type="writer" parent_index="1413">Description</paragraph>
 <paragraph index="1424" node_type="writer" parent_index="1413">Core properties of BMM_MODEL, may be used in a serial representation as well, such as P_BMM_SCHEMA.</paragraph>
 <paragraph index="1427" node_type="writer" parent_index="1413">Attributes</paragraph>
 <paragraph index="1430" node_type="writer" parent_index="1413">Signature</paragraph>
 <paragraph index="1433" node_type="writer" parent_index="1413">Meaning</paragraph>
 <paragraph index="1436" node_type="writer" parent_index="1413">1..1</paragraph>
 <paragraph index="1439" node_type="writer" parent_index="1413">rm_publisher: String</paragraph>
 <paragraph index="1442" node_type="writer" parent_index="1413">Publisher of model expressed in the schema.</paragraph>
 <paragraph index="1445" node_type="writer" parent_index="1413">1..1</paragraph>
 <paragraph index="1448" node_type="writer" parent_index="1413">rm_release: String</paragraph>
 <paragraph index="1451" node_type="writer" parent_index="1413">Release of model expressed in the schema as a 3-part numeric, e.g. &quot;3.1.0&quot; .</paragraph>
 <paragraph index="1454" node_type="writer" parent_index="435">4.2.4. BMM_SCHEMA Class</paragraph>
 <object index="1455" name="Table12" object_type="table"/>
 <paragraph index="1457" node_type="writer" parent_index="1455">Class</paragraph>
 <paragraph index="1460" node_type="writer" parent_index="1455">BMM_SCHEMA (abstract)</paragraph>
 <paragraph index="1463" node_type="writer" parent_index="1455">Description</paragraph>
 <paragraph index="1466" node_type="writer" parent_index="1455">Abstract parent of any persistable form of a BMM model, e.g. P_BMM_SCHEMA.</paragraph>
 <paragraph index="1469" node_type="writer" parent_index="1455">Inherit</paragraph>
 <paragraph index="1472" node_type="writer" parent_index="1455">BMM_MODEL_METADATA</paragraph>
 <paragraph index="1475" node_type="writer" parent_index="1455">Attributes</paragraph>
 <paragraph index="1478" node_type="writer" parent_index="1455">Signature</paragraph>
 <paragraph index="1481" node_type="writer" parent_index="1455">Meaning</paragraph>
 <paragraph index="1484" node_type="writer" parent_index="1455">1..1</paragraph>
 <paragraph index="1487" node_type="writer" parent_index="1455">bmm_version: String</paragraph>
 <paragraph index="1490" node_type="writer" parent_index="1455">Version of BMM model, enabling schema evolution reasoning. Persisted attribute.</paragraph>
 <paragraph index="1493" node_type="writer" parent_index="1455">0..1</paragraph>
 <paragraph index="1496" node_type="writer" parent_index="1455">includes: Hash&lt;String,BMM_INCLUDE_SPEC&gt;</paragraph>
 <paragraph index="1499" node_type="writer" parent_index="1455">Inclusion list of any form of BMM model, in the form of a hash of individual include specifications, each of which at least specifies the id of another schema, and may specify a namespace via which types from the included schemas are known in this schema. Persisted attribute.</paragraph>
 <paragraph index="1502" node_type="writer" parent_index="1455">0..1</paragraph>
 <paragraph index="1505" node_type="writer" parent_index="1455">bmm_model: BMM_MODEL</paragraph>
 <paragraph index="1508" node_type="writer" parent_index="1455">Generated by create_bmm_model from persisted elements.</paragraph>
 <paragraph index="1511" node_type="writer" parent_index="1455">1..1</paragraph>
 <paragraph index="1514" node_type="writer" parent_index="1455">state: BMM_SCHEMA_STATE</paragraph>
 <paragraph index="1517" node_type="writer" parent_index="1455">Current processing state.</paragraph>
 <paragraph index="1520" node_type="writer" parent_index="1455">0..1</paragraph>
 <paragraph index="1523" node_type="writer" parent_index="1455">model_name: String</paragraph>
 <paragraph index="1526" node_type="writer" parent_index="1455">Name of this model, if this schema is a model root point. Not set for sub-schemas that are not considered models on their own.</paragraph>
 <paragraph index="1529" node_type="writer" parent_index="1455">1..1</paragraph>
 <paragraph index="1532" node_type="writer" parent_index="1455">schema_name: String</paragraph>
 <paragraph index="1535" node_type="writer" parent_index="1455">Name of model expressed in schema; a 'schema' usually contains all of the packages of one 'model' of a publisher. A publisher with more than one model can have multiple schemas.</paragraph>
 <paragraph index="1538" node_type="writer" parent_index="1455">1..1</paragraph>
 <paragraph index="1541" node_type="writer" parent_index="1455">schema_revision: String</paragraph>
 <paragraph index="1544" node_type="writer" parent_index="1455">Revision of schema.</paragraph>
 <paragraph index="1547" node_type="writer" parent_index="1455">1..1</paragraph>
 <paragraph index="1550" node_type="writer" parent_index="1455">schema_lifecycle_state: String</paragraph>
 <paragraph index="1553" node_type="writer" parent_index="1455">Schema development lifecycle state.</paragraph>
 <paragraph index="1556" node_type="writer" parent_index="1455">1..1</paragraph>
 <paragraph index="1559" node_type="writer" parent_index="1455">schema_author: String</paragraph>
 <paragraph index="1562" node_type="writer" parent_index="1455">Primary author of schema.</paragraph>
 <paragraph index="1565" node_type="writer" parent_index="1455">1..1</paragraph>
 <paragraph index="1568" node_type="writer" parent_index="1455">schema_description: String</paragraph>
 <paragraph index="1571" node_type="writer" parent_index="1455">Description of schema.</paragraph>
 <paragraph index="1574" node_type="writer" parent_index="1455">0..1</paragraph>
 <paragraph index="1577" node_type="writer" parent_index="1455">schema_contributors: List&lt;String&gt;</paragraph>
 <paragraph index="1580" node_type="writer" parent_index="1455">Contributing authors of schema.</paragraph>
 <paragraph index="1583" node_type="writer" parent_index="1455">Functions</paragraph>
 <paragraph index="1586" node_type="writer" parent_index="1455">Signature</paragraph>
 <paragraph index="1589" node_type="writer" parent_index="1455">Meaning</paragraph>
 <paragraph index="1592" node_type="writer" parent_index="1455">0..1
(abstract)</paragraph>
 <paragraph index="1595" node_type="writer" parent_index="1455">validate_created

Pre_state: state = State_created
Post_state: passed implies state = State_validated_created</paragraph>
 <paragraph index="1598" node_type="writer" parent_index="1455">Do some basic validation post initial creation</paragraph>
 <paragraph index="1599" node_type="writer" parent_index="1455">check that package structure is regular:</paragraph>
 <paragraph index="1600" node_type="writer" parent_index="1455">only top-level packages can have qualified names</paragraph>
 <paragraph index="1601" node_type="writer" parent_index="1455">no top-level package name can be a direct parent or child of another (child package must be declared under the parent)</paragraph>
 <paragraph index="1602" node_type="writer" parent_index="1455">check that all classes are mentioned in the package structure</paragraph>
 <paragraph index="1603" node_type="writer" parent_index="1455">check that all models refer to valid packages</paragraph>
 <paragraph index="1606" node_type="writer" parent_index="1455">0..1
(abstract)</paragraph>
 <paragraph index="1609" node_type="writer" parent_index="1455">load_finalise

Pre_state: state = State_validated_created
Post_state: state = State_includes_processed or state = State_includes_pending</paragraph>
 <paragraph index="1612" node_type="writer" parent_index="1455">Finalisation work:</paragraph>
 <paragraph index="1613" node_type="writer" parent_index="1455">convert packages to canonical form, i.e. full hierarchy with no packages with names like aa.bb.cc</paragraph>
 <paragraph index="1614" node_type="writer" parent_index="1455">set up include processing list</paragraph>
 <paragraph index="1617" node_type="writer" parent_index="1455">0..1
(abstract)</paragraph>
 <paragraph index="1620" node_type="writer" parent_index="1455">merge (
other: BMM_SCHEMA[1]
)

Pre_state: state = State_includes_pending
Pre_other_valid: includes_to_process.has (included_schema.schema_id)</paragraph>
 <paragraph index="1623" node_type="writer" parent_index="1455">Merge in class and package definitions from other, except where the current schema already has a definition for the given type or package.</paragraph>
 <paragraph index="1626" node_type="writer" parent_index="1455">0..1
(abstract)</paragraph>
 <paragraph index="1629" node_type="writer" parent_index="1455">validate</paragraph>
 <paragraph index="1632" node_type="writer" parent_index="1455">Main validation prior to generation of bmm_model.</paragraph>
 <paragraph index="1635" node_type="writer" parent_index="1455">0..1
(abstract)</paragraph>
 <paragraph index="1638" node_type="writer" parent_index="1455">create_bmm_model

Pre_state: state = P_BMM_PACKAGE_STATE.State_includes_processed</paragraph>
 <paragraph index="1641" node_type="writer" parent_index="1455">Populate bmm_model from schema.</paragraph>
 <paragraph index="1644" node_type="writer" parent_index="1455">1..1</paragraph>
 <paragraph index="1647" node_type="writer" parent_index="1455">read_to_validate (): Boolean

Post_state: state = State_includes_processed</paragraph>
 <paragraph index="1650" node_type="writer" parent_index="1455">True when validation may be commenced.</paragraph>
 <paragraph index="1653" node_type="writer" parent_index="1455">1..1</paragraph>
 <paragraph index="1656" node_type="writer" parent_index="1455">schema_id (): String</paragraph>
 <paragraph index="1659" node_type="writer" parent_index="1455">Identifier of this schema, used for stating inclusions and identifying files. Formed as:</paragraph>
 <paragraph index="1660" node_type="writer" parent_index="1455">{BMM_DEFINITIONS}.create_schema_id ( rm_publisher, schema_name, rm_release)</paragraph>
 <paragraph index="1661" node_type="writer" parent_index="1455">E.g. &quot;openehr_rm_ehr_1.0.4&quot;.</paragraph>
 <paragraph index="1664" node_type="writer" parent_index="435">4.2.5. BMM_SCHEMA_STATE Enumeration</paragraph>
 <object index="1665" name="Table13" object_type="table"/>
 <paragraph index="1667" node_type="writer" parent_index="1665">Enumeration</paragraph>
 <paragraph index="1670" node_type="writer" parent_index="1665">BMM_SCHEMA_STATE</paragraph>
 <paragraph index="1673" node_type="writer" parent_index="1665">Description</paragraph>
 <paragraph index="1676" node_type="writer" parent_index="1665">Enumeration of processing states of a BMM_SCHEMA used by creation and validation routines in BMM_SCHEMA.</paragraph>
 <paragraph index="1679" node_type="writer" parent_index="1665">Attributes</paragraph>
 <paragraph index="1682" node_type="writer" parent_index="1665">Signature</paragraph>
 <paragraph index="1685" node_type="writer" parent_index="1665">Meaning</paragraph>
 <paragraph index="1691" node_type="writer" parent_index="1665">State_created</paragraph>
 <paragraph index="1694" node_type="writer" parent_index="1665">Initial state directly after instantiation of schema.</paragraph>
 <paragraph index="1700" node_type="writer" parent_index="1665">State_validated_created</paragraph>
 <paragraph index="1703" node_type="writer" parent_index="1665">Initial validation pass after instantiation.</paragraph>
 <paragraph index="1709" node_type="writer" parent_index="1665">State_includes_pending</paragraph>
 <paragraph index="1712" node_type="writer" parent_index="1665">State of schema processing if there are still included schemas to process.</paragraph>
 <paragraph index="1718" node_type="writer" parent_index="1665">State_includes_processed</paragraph>
 <paragraph index="1721" node_type="writer" parent_index="1665">State when all included schemas have been processed.</paragraph>
 <paragraph index="1724" node_type="writer" parent_index="435">4.2.6. BMM_INCLUDE_SPEC Class</paragraph>
 <object index="1725" name="Table14" object_type="table"/>
 <paragraph index="1727" node_type="writer" parent_index="1725">Class</paragraph>
 <paragraph index="1730" node_type="writer" parent_index="1725">BMM_INCLUDE_SPEC</paragraph>
 <paragraph index="1733" node_type="writer" parent_index="1725">Description</paragraph>
 <paragraph index="1736" node_type="writer" parent_index="1725">Schema inclusion structure.</paragraph>
 <paragraph index="1739" node_type="writer" parent_index="1725">Attributes</paragraph>
 <paragraph index="1742" node_type="writer" parent_index="1725">Signature</paragraph>
 <paragraph index="1745" node_type="writer" parent_index="1725">Meaning</paragraph>
 <paragraph index="1748" node_type="writer" parent_index="1725">1..1</paragraph>
 <paragraph index="1751" node_type="writer" parent_index="1725">id: String</paragraph>
 <paragraph index="1754" node_type="writer" parent_index="1725">Full identifier of the included schema, e.g. &quot;openehr_primitive_types_1.0.2&quot;.</paragraph>
 <paragraph index="1757" node_type="writer" parent_index="435">5. Model Structure</paragraph>
 <paragraph index="1758" node_type="writer" parent_index="435">5.1. Overview</paragraph>
 <paragraph index="1759" node_type="writer" parent_index="435">The core package defines the main BMM meta-model, within which the model sub-package defines the top-level structure of a model which is an instance of the BMM. The UML for this package is shown below.</paragraph>
 <object index="1760" name="core_model" object_type="section"/>
 <paragraph index="1761" node_type="writer" parent_index="1760"> </paragraph>
 <paragraph index="1762" node_type="writer" parent_index="1760">Figure 7. base.bmm.core.model Package - Model structure</paragraph>
 <paragraph index="1764" node_type="writer" parent_index="435">5.2. Naming Convention</paragraph>
 <paragraph index="1765" node_type="writer" parent_index="435">In a BMM model, names typically appear in the common case-sensitive form used by the model users, and may therefore follow one of a number of common conventions, including 'camel case', 'snake-case' and so on. When used computationally within an instantiated BMM model, it is assumed that case-insensitive matching is used. This means that the class name &quot;Hashable&quot; refers to the same class as &quot;HASHABLE&quot;. Note however that underscores are not removed during matching, so that the classes &quot;HashMap&quot; and &quot;HASH_MAP&quot; are understood as different classes.</paragraph>
 <object index="1766" name="Table15" object_type="table"/>
 <paragraph index="1768" node_type="writer" parent_index="1766">Note</paragraph>
 <paragraph index="1771" node_type="writer" parent_index="1766">a future version of BMM may define an option to import schemas using differing naming styles, with transformation into a single style for the target model. </paragraph>
 <paragraph index="1774" node_type="writer" parent_index="435">5.3. Model Semantics</paragraph>
 <paragraph index="1775" node_type="writer" parent_index="435">In BMM, a model is understood as a set of package and module definitions that are developed and maintained as a unit, by some organisation, and usually having an associated hierarchical namespace. The abstract BMM_MODULE class is the ancestor for any kind of module, which is understood as a container for features of various kinds, including the usual properties, routines, and so on. A BMM model is structured in the same general way as a UML model, i.e. with a hierarchical package containment structure and a set of module definitions, where a commonly used type of module is the class. The following illustrates the structure of a typical 'class' or 'object' model.</paragraph>
 <object index="1776" name="bmm_structure" object_type="section"/>
 <paragraph index="1777" node_type="writer" parent_index="1776"> </paragraph>
 <paragraph index="1778" node_type="writer" parent_index="1776">Figure 8. BMM model structure</paragraph>
 <paragraph index="1780" node_type="writer" parent_index="435">The BMM_MODEL class defines the single instance of each distinct BMM model that may exist within a collection of models, such as shown in the model_access package above. It provides an interface that enables any class definition to be retrieved, as well as various accessor functions to interrogate the model. A BMM Model has a name (the inherited name attribute) that is used to identify the model as a whole within a system using multiple models. It contains a number of other meta-data attributes describing authorship etc, and otherwise contains a list of package and class definitions.</paragraph>
 <paragraph index="1781" node_type="writer" parent_index="435">5.3.1. Packages</paragraph>
 <paragraph index="1782" node_type="writer" parent_index="435">In BMM, packages have the same role as in UML - as non-semantic organisational logical containers of classes, usually corresponding to file system folders in software implementations. They provide an organisational convenience, and in an instantiated BMM model, contain references to class definitions. A model validity checker ensures that every class is contained within exactly one package.</paragraph>
 <paragraph index="1783" node_type="writer" parent_index="435">Package paths are only used in BMM to specify package structures in the serialised form in an efficient way, i.e. by using paths to avoid defining a hierarchy in which only lower packages contain classes. They are not used as namespaces as in UML. Consequently, all classes in a BMM model should be uniquely named.</paragraph>
 <paragraph index="1784" node_type="writer" parent_index="435">5.3.2. Use of other Models</paragraph>
 <paragraph index="1785" node_type="writer" parent_index="435">A model may use another model. This is the same kind of relationship denoted by the 'import' keyword in many programming languages. In BMM, the use of other models is declared once only, in the using model, rather than on a per-class level as in some languages (e.g. Java). The use of another model makes its contents available for use in declarations (e.g. inheritance) and expressions within the using model. This is achieved by populating the BMM_CLASS.scope attribute with a reference to the used model. In a serial form, a typical syntax such as other_model_name::Class would be used.</paragraph>
 <paragraph index="1786" node_type="writer" parent_index="435">5.3.3. Documentation</paragraph>
 <paragraph index="1787" node_type="writer" parent_index="435">A documentation attribute is inherited from BMM_MODEL_ELEMENT into BMM_MODULE, BMM_FEATURE and `BMM_PACKAGE_CONTAINER, enabling packages, classes, routines and properties to be individually documented using a keyed table (i.e. Hash) of values.</paragraph>
 <paragraph index="1788" node_type="writer" parent_index="435">It is strongly recommended to use the following key /type combinations for the relevant purposes:</paragraph>
 <paragraph index="1789" node_type="writer" parent_index="435">&quot;purpose&quot;: String</paragraph>
 <paragraph index="1790" node_type="writer" parent_index="435">&quot;keywords&quot;: List&lt;String&gt;</paragraph>
 <paragraph index="1791" node_type="writer" parent_index="435">&quot;use&quot;: String</paragraph>
 <paragraph index="1792" node_type="writer" parent_index="435">&quot;misuse&quot;: String</paragraph>
 <paragraph index="1793" node_type="writer" parent_index="435">&quot;references&quot;: String</paragraph>
 <paragraph index="1794" node_type="writer" parent_index="435">Other keys and value types may be freely added.</paragraph>
 <paragraph index="1795" node_type="writer" parent_index="435">5.3.4. Other Meta-data</paragraph>
 <paragraph index="1796" node_type="writer" parent_index="435">The BMM_MODEL_ELEMENT meta-class also defines the attribute extensions of type Hash&lt;String, Any&gt;, to enable representation of meta-data of any type on any model node. This provides a means of extending BMM.</paragraph>
 <paragraph index="1797" node_type="writer" parent_index="435">5.4. The Any Class and Type</paragraph>
 <paragraph index="1798" node_type="writer" parent_index="435">While a BMM model defines a model in terms of class declarations, it must always have a top class named Any from which all others inherit. Similar to the root class in a typical OOPL type systems (sometimes called 'Object'), the Any class defines semantics true for all objects such as equality (i.e. semantics for an '=' operator) and copying.</paragraph>
 <paragraph index="1799" node_type="writer" parent_index="435">A BMM model may define its own Any class, but if it does not, the BMM_MODEL instance representing the model will produce a standard 'Any' class via the any_class_definition() method. This will create the following structure, including a default package structure, and an Any type.</paragraph>
 <object index="1800" name="bmm_any_class" object_type="section"/>
 <paragraph index="1801" node_type="writer" parent_index="1800"> </paragraph>
 <paragraph index="1802" node_type="writer" parent_index="1800">Figure 9. Default Any class</paragraph>
 <paragraph index="1804" node_type="writer" parent_index="435">The Any type defined by the model’s Any class, or else the default one above, will be used as the inheritance parent for every class in the model that doesn’t have any other inheritance parent. As a result, the inheritance graph will always have the Any type as its top node.</paragraph>
 <paragraph index="1805" node_type="writer" parent_index="435">5.5. Class Definitions</paragraph>
 <paragraph index="1806" node_type="writer" parent_index="435">5.5.1. BMM_MODEL_ELEMENT Class</paragraph>
 <object index="1807" name="Table16" object_type="table"/>
 <paragraph index="1809" node_type="writer" parent_index="1807">Class</paragraph>
 <paragraph index="1812" node_type="writer" parent_index="1807">BMM_MODEL_ELEMENT (abstract)</paragraph>
 <paragraph index="1815" node_type="writer" parent_index="1807">Description</paragraph>
 <paragraph index="1818" node_type="writer" parent_index="1807">Abstract meta-type of BMM declared model elements. A declaration is a an element of a model within a context, which defines the scope of the element. Thus, a class definition and its property and routine definitions are model elements, but Types are not, since they are derived from model elements.</paragraph>
 <paragraph index="1821" node_type="writer" parent_index="1807">Attributes</paragraph>
 <paragraph index="1824" node_type="writer" parent_index="1807">Signature</paragraph>
 <paragraph index="1827" node_type="writer" parent_index="1807">Meaning</paragraph>
 <paragraph index="1830" node_type="writer" parent_index="1807">1..1</paragraph>
 <paragraph index="1833" node_type="writer" parent_index="1807">name: String</paragraph>
 <paragraph index="1836" node_type="writer" parent_index="1807">Name of this model element.</paragraph>
 <paragraph index="1839" node_type="writer" parent_index="1807">0..1</paragraph>
 <paragraph index="1842" node_type="writer" parent_index="1807">documentation: Hash&lt;Any, String&gt;</paragraph>
 <paragraph index="1845" node_type="writer" parent_index="1807">Optional documentation of this element, as a keyed list.</paragraph>
 <paragraph index="1846" node_type="writer" parent_index="1807">It is strongly recommended to use the following key /type combinations for the relevant purposes:</paragraph>
 <paragraph index="1847" node_type="writer" parent_index="1807">&quot;purpose&quot;: String</paragraph>
 <paragraph index="1848" node_type="writer" parent_index="1807">&quot;keywords&quot;: List&lt;String&gt;</paragraph>
 <paragraph index="1849" node_type="writer" parent_index="1807">&quot;use&quot;: String</paragraph>
 <paragraph index="1850" node_type="writer" parent_index="1807">&quot;misuse&quot;: String</paragraph>
 <paragraph index="1851" node_type="writer" parent_index="1807">&quot;references&quot;: String</paragraph>
 <paragraph index="1852" node_type="writer" parent_index="1807">Other keys and value types may be freely added.</paragraph>
 <paragraph index="1855" node_type="writer" parent_index="1807">1..1</paragraph>
 <paragraph index="1858" node_type="writer" parent_index="1807">scope: BMM_MODEL_ELEMENT</paragraph>
 <paragraph index="1861" node_type="writer" parent_index="1807">Model element within which an element is declared.</paragraph>
 <paragraph index="1864" node_type="writer" parent_index="1807">0..1</paragraph>
 <paragraph index="1867" node_type="writer" parent_index="1807">extensions: Hash&lt;Any, String&gt;</paragraph>
 <paragraph index="1870" node_type="writer" parent_index="1807">Optional meta-data of this element, as a keyed list. May be used to extend the meta-model.</paragraph>
 <paragraph index="1873" node_type="writer" parent_index="1807">Functions</paragraph>
 <paragraph index="1876" node_type="writer" parent_index="1807">Signature</paragraph>
 <paragraph index="1879" node_type="writer" parent_index="1807">Meaning</paragraph>
 <paragraph index="1882" node_type="writer" parent_index="1807">1..1</paragraph>
 <paragraph index="1885" node_type="writer" parent_index="1807">is_root_scope (): Boolean

Post_result: Result = (scope = self)</paragraph>
 <paragraph index="1888" node_type="writer" parent_index="1807">True if this model element is the root of a model structure hierarchy.</paragraph>
 <paragraph index="1891" node_type="writer" parent_index="435">5.5.2. BMM_PACKAGE_CONTAINER Class</paragraph>
 <object index="1892" name="Table17" object_type="table"/>
 <paragraph index="1894" node_type="writer" parent_index="1892">Class</paragraph>
 <paragraph index="1897" node_type="writer" parent_index="1892">BMM_PACKAGE_CONTAINER (abstract)</paragraph>
 <paragraph index="1900" node_type="writer" parent_index="1892">Description</paragraph>
 <paragraph index="1903" node_type="writer" parent_index="1892">A BMM model component that contains packages and classes.</paragraph>
 <paragraph index="1906" node_type="writer" parent_index="1892">Inherit</paragraph>
 <paragraph index="1909" node_type="writer" parent_index="1892">BMM_MODEL_ELEMENT</paragraph>
 <paragraph index="1912" node_type="writer" parent_index="1892">Attributes</paragraph>
 <paragraph index="1915" node_type="writer" parent_index="1892">Signature</paragraph>
 <paragraph index="1918" node_type="writer" parent_index="1892">Meaning</paragraph>
 <paragraph index="1921" node_type="writer" parent_index="1892">0..1</paragraph>
 <paragraph index="1924" node_type="writer" parent_index="1892">packages: Hash&lt;String,BMM_PACKAGE&gt;</paragraph>
 <paragraph index="1927" node_type="writer" parent_index="1892">Child packages; keys all in upper case for guaranteed matching.</paragraph>
 <paragraph index="1930" node_type="writer" parent_index="1892">1..1
(redefined)</paragraph>
 <paragraph index="1933" node_type="writer" parent_index="1892">scope: BMM_PACKAGE_CONTAINER</paragraph>
 <paragraph index="1936" node_type="writer" parent_index="1892">Model element within which a referenceable element is known.</paragraph>
 <paragraph index="1939" node_type="writer" parent_index="1892">Functions</paragraph>
 <paragraph index="1942" node_type="writer" parent_index="1892">Signature</paragraph>
 <paragraph index="1945" node_type="writer" parent_index="1892">Meaning</paragraph>
 <paragraph index="1948" node_type="writer" parent_index="1892">0..1</paragraph>
 <paragraph index="1951" node_type="writer" parent_index="1892">package_at_path (
a_path: String[1]
): BMM_PACKAGE</paragraph>
 <paragraph index="1954" node_type="writer" parent_index="1892">Package at the path a_path.</paragraph>
 <paragraph index="1957" node_type="writer" parent_index="1892">0..1</paragraph>
 <paragraph index="1960" node_type="writer" parent_index="1892">do_recursive_packages (
action: EL_PROCEDURE_AGENT[1]
)</paragraph>
 <paragraph index="1963" node_type="writer" parent_index="1892">Recursively execute action, which is a procedure taking a BMM_PACKAGE argument, on all members of packages.</paragraph>
 <paragraph index="1966" node_type="writer" parent_index="1892">1..1</paragraph>
 <paragraph index="1969" node_type="writer" parent_index="1892">has_package_path (
a_path: String[1]
): Boolean</paragraph>
 <paragraph index="1972" node_type="writer" parent_index="1892">True if there is a package at the path a_path; paths are delimited with delimiter {BMM_DEFINITIONS} Package_name_delimiter.</paragraph>
 <paragraph index="1975" node_type="writer" parent_index="435">5.5.3. BMM_PACKAGE Class</paragraph>
 <object index="1976" name="Table18" object_type="table"/>
 <paragraph index="1978" node_type="writer" parent_index="1976">Class</paragraph>
 <paragraph index="1981" node_type="writer" parent_index="1976">BMM_PACKAGE</paragraph>
 <paragraph index="1984" node_type="writer" parent_index="1976">Description</paragraph>
 <paragraph index="1987" node_type="writer" parent_index="1976">Abstraction of a package as a tree structure whose nodes can contain other packages and classes.</paragraph>
 <paragraph index="1988" node_type="writer" parent_index="1976">The name may be qualified if it is a top-level package.</paragraph>
 <paragraph index="1991" node_type="writer" parent_index="1976">Inherit</paragraph>
 <paragraph index="1994" node_type="writer" parent_index="1976">BMM_PACKAGE_CONTAINER</paragraph>
 <paragraph index="1997" node_type="writer" parent_index="1976">Attributes</paragraph>
 <paragraph index="2000" node_type="writer" parent_index="1976">Signature</paragraph>
 <paragraph index="2003" node_type="writer" parent_index="1976">Meaning</paragraph>
 <paragraph index="2006" node_type="writer" parent_index="1976">0..1</paragraph>
 <paragraph index="2009" node_type="writer" parent_index="1976">members: List&lt;BMM_MODULE&gt;</paragraph>
 <paragraph index="2012" node_type="writer" parent_index="1976">Member modules in this package.</paragraph>
 <paragraph index="2015" node_type="writer" parent_index="1976">Functions</paragraph>
 <paragraph index="2018" node_type="writer" parent_index="1976">Signature</paragraph>
 <paragraph index="2021" node_type="writer" parent_index="1976">Meaning</paragraph>
 <paragraph index="2024" node_type="writer" parent_index="1976">0..1</paragraph>
 <paragraph index="2027" node_type="writer" parent_index="1976">root_classes (): List&lt;BMM_CLASS&gt;</paragraph>
 <paragraph index="2030" node_type="writer" parent_index="1976">Obtain the set of top-level classes in this package, either from this package itself or by recursing into the structure until classes are obtained from child packages. Recurse into each child only far enough to find the first level of classes.</paragraph>
 <paragraph index="2033" node_type="writer" parent_index="1976">1..1</paragraph>
 <paragraph index="2036" node_type="writer" parent_index="1976">path (): String</paragraph>
 <paragraph index="2039" node_type="writer" parent_index="1976">Full path of this package back to root package.</paragraph>
 <paragraph index="2042" node_type="writer" parent_index="435">5.5.4. BMM_MODEL Class</paragraph>
 <object index="2043" name="Table19" object_type="table"/>
 <paragraph index="2045" node_type="writer" parent_index="2043">Class</paragraph>
 <paragraph index="2048" node_type="writer" parent_index="2043">BMM_MODEL</paragraph>
 <paragraph index="2051" node_type="writer" parent_index="2043">Description</paragraph>
 <paragraph index="2054" node_type="writer" parent_index="2043">Definition of the root of a BMM model (along with what is inherited from BMM_SCHEMA_CORE).</paragraph>
 <paragraph index="2057" node_type="writer" parent_index="2043">Inherit</paragraph>
 <paragraph index="2060" node_type="writer" parent_index="2043">BMM_PACKAGE_CONTAINER, BMM_MODEL_METADATA</paragraph>
 <paragraph index="2063" node_type="writer" parent_index="2043">Attributes</paragraph>
 <paragraph index="2066" node_type="writer" parent_index="2043">Signature</paragraph>
 <paragraph index="2069" node_type="writer" parent_index="2043">Meaning</paragraph>
 <paragraph index="2072" node_type="writer" parent_index="2043">0..1</paragraph>
 <paragraph index="2075" node_type="writer" parent_index="2043">class_definitions: Hash&lt;String,BMM_CLASS&gt;</paragraph>
 <paragraph index="2078" node_type="writer" parent_index="2043">All classes in this model, keyed by type name.</paragraph>
 <paragraph index="2081" node_type="writer" parent_index="2043">0..1</paragraph>
 <paragraph index="2084" node_type="writer" parent_index="2043">used_models: List&lt;BMM_MODEL&gt;</paragraph>
 <paragraph index="2087" node_type="writer" parent_index="2043">List of other models 'used' (i.e. 'imported' by this model). Classes in the current model may refer to classes in a used model by specifying the other class’s scope meta-attribute.</paragraph>
 <paragraph index="2090" node_type="writer" parent_index="2043">0..1</paragraph>
 <paragraph index="2093" node_type="writer" parent_index="2043">modules: Hash&lt;String,BMM_MODULE&gt;</paragraph>
 <paragraph index="2096" node_type="writer" parent_index="2043">All classes in this model, keyed by type name.</paragraph>
 <paragraph index="2099" node_type="writer" parent_index="2043">Functions</paragraph>
 <paragraph index="2102" node_type="writer" parent_index="2043">Signature</paragraph>
 <paragraph index="2105" node_type="writer" parent_index="2043">Meaning</paragraph>
 <paragraph index="2108" node_type="writer" parent_index="2043">1..1</paragraph>
 <paragraph index="2111" node_type="writer" parent_index="2043">model_id (): String</paragraph>
 <paragraph index="2114" node_type="writer" parent_index="2043">Identifier of this model, lower-case, formed from:</paragraph>
 <paragraph index="2115" node_type="writer" parent_index="2043">&lt;rm_publisher&gt;_&lt;model_name&gt;_&lt;rm_release&gt;</paragraph>
 <paragraph index="2116" node_type="writer" parent_index="2043">E.g. &quot;openehr_ehr_1.0.4&quot;.</paragraph>
 <paragraph index="2119" node_type="writer" parent_index="2043">1..1</paragraph>
 <paragraph index="2122" node_type="writer" parent_index="2043">class_definition (
a_name: String[1]
): BMM_CLASS</paragraph>
 <paragraph index="2125" node_type="writer" parent_index="2043">Retrieve the class definition corresponding to a_type_name (which may contain a generic part).</paragraph>
 <paragraph index="2128" node_type="writer" parent_index="2043">1..1</paragraph>
 <paragraph index="2131" node_type="writer" parent_index="2043">type_definition (): BMM_CLASS</paragraph>
 <paragraph index="2134" node_type="writer" parent_index="2043">Retrieve the class definition corresponding to a_type_name. If it contains a generic part, this will be removed if it is a fully open generic name, otherwise it will remain intact, i.e. if it is an effective generic name that identifies a BMM_GENERIC_CLASS_EFFECTIVE.</paragraph>
 <paragraph index="2137" node_type="writer" parent_index="2043">1..1</paragraph>
 <paragraph index="2140" node_type="writer" parent_index="2043">has_class_definition (
a_class_name: String[1]
): Boolean</paragraph>
 <paragraph index="2143" node_type="writer" parent_index="2043">True if a_class_name has a class definition in the model.</paragraph>
 <paragraph index="2146" node_type="writer" parent_index="2043">1..1</paragraph>
 <paragraph index="2149" node_type="writer" parent_index="2043">has_type_definition (
a_type_name: String[1]
): Boolean</paragraph>
 <paragraph index="2152" node_type="writer" parent_index="2043">True if a_type_name is already concretely known in the system, including if it is generic, which may be open, partially open or closed.</paragraph>
 <paragraph index="2155" node_type="writer" parent_index="2043">1..1</paragraph>
 <paragraph index="2158" node_type="writer" parent_index="2043">enumeration_definition (
a_name: String[1]
): BMM_ENUMERATION</paragraph>
 <paragraph index="2161" node_type="writer" parent_index="2043">Retrieve the enumeration definition corresponding to a_type_name.</paragraph>
 <paragraph index="2164" node_type="writer" parent_index="2043">0..1</paragraph>
 <paragraph index="2167" node_type="writer" parent_index="2043">primitive_types (): List&lt;String&gt;</paragraph>
 <paragraph index="2170" node_type="writer" parent_index="2043">List of keys in class_definitions of items marked as primitive types.</paragraph>
 <paragraph index="2173" node_type="writer" parent_index="2043">0..1</paragraph>
 <paragraph index="2176" node_type="writer" parent_index="2043">enumeration_types (): List&lt;String&gt;</paragraph>
 <paragraph index="2179" node_type="writer" parent_index="2043">List of keys in class_definitions of items that are enumeration types.</paragraph>
 <paragraph index="2182" node_type="writer" parent_index="2043">1..1</paragraph>
 <paragraph index="2185" node_type="writer" parent_index="2043">property_definition (): BMM_PROPERTY</paragraph>
 <paragraph index="2188" node_type="writer" parent_index="2043">Retrieve the property definition for a_prop_name in flattened class corresponding to a_type_name.</paragraph>
 <paragraph index="2191" node_type="writer" parent_index="2043">1..1</paragraph>
 <paragraph index="2194" node_type="writer" parent_index="2043">ms_conformant_property_type (
a_bmm_type_name: String[1],
a_bmm_property_name: String[1],
a_ms_property_name: String[1]
): Boolean</paragraph>
 <paragraph index="2197" node_type="writer" parent_index="2043">True if a_ms_property_type is a valid 'MS' dynamic type for a_property in BMM type a_bmm_type_name. 'MS' conformance means 'model-semantic' conformance, which abstracts away container types like List&lt;&gt;, Set&lt;&gt; etc and compares the dynamic type with the relation target type in the UML sense, i.e. regardless of whether there is single or multiple containment.</paragraph>
 <paragraph index="2200" node_type="writer" parent_index="2043">1..1</paragraph>
 <paragraph index="2203" node_type="writer" parent_index="2043">property_definition_at_path (): BMM_PROPERTY</paragraph>
 <paragraph index="2206" node_type="writer" parent_index="2043">Retrieve the property definition for a_property_path in flattened class corresponding to a_type_name.</paragraph>
 <paragraph index="2209" node_type="writer" parent_index="2043">1..1</paragraph>
 <paragraph index="2212" node_type="writer" parent_index="2043">class_definition_at_path (
a_type_name: String[1],
a_prop_path: String[1]
): BMM_CLASS</paragraph>
 <paragraph index="2215" node_type="writer" parent_index="2043">Retrieve the class definition for the class that owns the terminal attribute in a_prop_path in flattened class corresponding to a_type_name.</paragraph>
 <paragraph index="2218" node_type="writer" parent_index="2043">0..1</paragraph>
 <paragraph index="2221" node_type="writer" parent_index="2043">all_ancestor_classes (
a_class: String[1]
): List&lt;String&gt;</paragraph>
 <paragraph index="2224" node_type="writer" parent_index="2043">Return all ancestor types of a_class_name up to root class (usually Any, Object or something similar). Does not include current class. Returns empty list if none.</paragraph>
 <paragraph index="2227" node_type="writer" parent_index="2043">1..1</paragraph>
 <paragraph index="2230" node_type="writer" parent_index="2043">is_descendant_of (
a_class_name: String[1],
a_parent_class_name: String[1]
): Boolean</paragraph>
 <paragraph index="2233" node_type="writer" parent_index="2043">True if a_class_name is a descendant in the model of a_parent_class_name.</paragraph>
 <paragraph index="2236" node_type="writer" parent_index="2043">1..1</paragraph>
 <paragraph index="2239" node_type="writer" parent_index="2043">type_conforms_to (
a_desc_type: String[1],
an_anc_type: String[1]
): Boolean</paragraph>
 <paragraph index="2242" node_type="writer" parent_index="2043">Check conformance of a_desc_type to an_anc_type; the types may be generic, and may contain open generic parameters like 'T' etc. These are replaced with their appropriate constrainer types, or Any during the conformance testing process.</paragraph>
 <paragraph index="2243" node_type="writer" parent_index="2043">Conformance is found if:</paragraph>
 <paragraph index="2244" node_type="writer" parent_index="2043">[base class test] types are non-generic, and either type names are identical, or else a_desc_type has an_anc_type in its ancestors;</paragraph>
 <paragraph index="2245" node_type="writer" parent_index="2043">both types are generic and pass base class test; number of generic params matches, and each generic parameter type, after 'open parameter' substitution, recursively passes; type_name_conforms_to test</paragraph>
 <paragraph index="2246" node_type="writer" parent_index="2043">descendant type is generic and ancestor type is not, and they pass base classes test.</paragraph>
 <paragraph index="2249" node_type="writer" parent_index="2043">1..1</paragraph>
 <paragraph index="2252" node_type="writer" parent_index="2043">subtypes (
a_type: String[1]
): List&lt;String&gt;</paragraph>
 <paragraph index="2255" node_type="writer" parent_index="2043">Generate type substitutions for the supplied type, which may be simple, generic (closed, open or partially open), or a container type. In the generic and container cases, the result is the permutation of the base class type and type substitutions of all generic parameters.</paragraph>
 <paragraph index="2256" node_type="writer" parent_index="2043">Parameters</paragraph>
 <object index="2257" name="Table20" object_type="table"/>
 <paragraph index="2259" node_type="writer" parent_index="2257">a_type </paragraph>
 <paragraph index="2262" node_type="writer" parent_index="2257">Name of a type.</paragraph>
 <paragraph index="2268" node_type="writer" parent_index="2043">1..1</paragraph>
 <paragraph index="2271" node_type="writer" parent_index="2043">any_class_definition (): BMM_SIMPLE_CLASS</paragraph>
 <paragraph index="2274" node_type="writer" parent_index="2043">BMM_SIMPLE_CLASS instance for the Any class. This may be defined in the BMM schema, but if not, use BMM_DEFINITIONS.any_class.</paragraph>
 <paragraph index="2277" node_type="writer" parent_index="2043">1..1</paragraph>
 <paragraph index="2280" node_type="writer" parent_index="2043">any_type_definition (): BMM_SIMPLE_TYPE</paragraph>
 <paragraph index="2283" node_type="writer" parent_index="2043">BMM_SIMPLE_TYPE instance for the Any type.</paragraph>
 <paragraph index="2286" node_type="writer" parent_index="2043">1..1</paragraph>
 <paragraph index="2289" node_type="writer" parent_index="2043">boolean_type_definition (): BMM_SIMPLE_TYPE</paragraph>
 <paragraph index="2292" node_type="writer" parent_index="2043">BMM_SIMPLE_TYPE instance for the Boolean type.</paragraph>
 <paragraph index="2295" node_type="writer" parent_index="2043">Invariants</paragraph>
 <paragraph index="2298" node_type="writer" parent_index="2043">Inv_top_level_scope: scope = self</paragraph>
 <paragraph index="2301" node_type="writer" parent_index="435">5.5.5. BMM_MODULE Class</paragraph>
 <object index="2302" name="Table21" object_type="table"/>
 <paragraph index="2304" node_type="writer" parent_index="2302">Class</paragraph>
 <paragraph index="2307" node_type="writer" parent_index="2302">BMM_MODULE (abstract)</paragraph>
 <paragraph index="2310" node_type="writer" parent_index="2302">Description</paragraph>
 <paragraph index="2313" node_type="writer" parent_index="2302">Meta-type defining a generalised module concept. Descendants define actual structure and contents.</paragraph>
 <paragraph index="2316" node_type="writer" parent_index="2302">Inherit</paragraph>
 <paragraph index="2319" node_type="writer" parent_index="2302">BMM_MODEL_ELEMENT</paragraph>
 <paragraph index="2322" node_type="writer" parent_index="2302">Attributes</paragraph>
 <paragraph index="2325" node_type="writer" parent_index="2302">Signature</paragraph>
 <paragraph index="2328" node_type="writer" parent_index="2302">Meaning</paragraph>
 <paragraph index="2331" node_type="writer" parent_index="2302">0..1</paragraph>
 <paragraph index="2334" node_type="writer" parent_index="2302">feature_groups: List&lt;BMM_FEATURE_GROUP&gt;</paragraph>
 <paragraph index="2337" node_type="writer" parent_index="2302">List of feature groups in this class.</paragraph>
 <paragraph index="2340" node_type="writer" parent_index="2302">0..1</paragraph>
 <paragraph index="2343" node_type="writer" parent_index="2302">features: List&lt;BMM_FORMAL_ELEMENT&gt;</paragraph>
 <paragraph index="2346" node_type="writer" parent_index="2302">Features of this module.</paragraph>
 <paragraph index="2349" node_type="writer" parent_index="2302">1..1
(redefined)</paragraph>
 <paragraph index="2352" node_type="writer" parent_index="2302">scope: BMM_MODEL</paragraph>
 <paragraph index="2355" node_type="writer" parent_index="2302">Model within which module is defined.</paragraph>
 <paragraph index="2358" node_type="writer" parent_index="435">6. Types</paragraph>
 <paragraph index="2359" node_type="writer" parent_index="435">6.1. Overview</paragraph>
 <paragraph index="2360" node_type="writer" parent_index="435">One of the foundational distinctions in the BMM is between class and type, in common with the type systems of the modern forms of most object-oriented languages, but in contrast to the UML meta-model. This division is reflected in the two top-level meta-classes BMM_CLASS and BMM_TYPE, and their respective descendants, as shown in the following UML diagram.</paragraph>
 <object index="2361" name="core_entity" object_type="section"/>
 <paragraph index="2362" node_type="writer" parent_index="2361"> </paragraph>
 <paragraph index="2363" node_type="writer" parent_index="2361">Figure 10. base.bmm.core.entity Package - Types</paragraph>
 <paragraph index="2365" node_type="writer" parent_index="435">Classes are definitional entities, while types are understood in BMM as the formal generators of instances (where non-abstract). Types are the the basis of static typing in a formal model, and dynamic conformance at execution time, when polymorphic attachment is possible. Most types are specified via the definitions of classes and their constituent parts within a 'model'. Types are used for the following purposes in a BMM model:</paragraph>
 <paragraph index="2366" node_type="writer" parent_index="435">to define the types of properties;</paragraph>
 <paragraph index="2367" node_type="writer" parent_index="435">to defined the types of routine parameters and return values;</paragraph>
 <paragraph index="2368" node_type="writer" parent_index="435">to define formal type parameters in a generic class;</paragraph>
 <paragraph index="2369" node_type="writer" parent_index="435">to define type(s) of inheritance ancestors of class definitions;</paragraph>
 <paragraph index="2370" node_type="writer" parent_index="435">to formalise concepts relating to functional programming, including tuples and routine signatures;</paragraph>
 <paragraph index="2371" node_type="writer" parent_index="435">to determine conformance, which is a relation between types (not classes).</paragraph>
 <paragraph index="2372" node_type="writer" parent_index="435">A simple example of typing of properties is shown in the instance diagram below.</paragraph>
 <object index="2373" name="bmm_entities" object_type="section"/>
 <paragraph index="2374" node_type="writer" parent_index="2373"> </paragraph>
 <paragraph index="2375" node_type="writer" parent_index="2373">Figure 11. BMM Typing</paragraph>
 <paragraph index="2377" node_type="writer" parent_index="435">Most types are based on one or more defining class(es), which provide the formal definition for the type. The exceptions are formal generic parameters (e.g. the T in List&lt;T&gt;) and the special built-in types for tuples and routine signatures. The BMM meta-type BMM_TYPE and its descendants define the kinds of types available in a BMM model. The design of the types part of the BMM is based on a taxonomy that makes various distinctions convenient to a formalism intended for modelling rather than pure programming. This leads in particular to the top-level distinction between unitary and container meta-types. The taxonomy is illustrated below, including differentiae.</paragraph>
 <object index="2378" name="bmm_metatype_taxonomy" object_type="section"/>
 <paragraph index="2379" node_type="writer" parent_index="2378"> </paragraph>
 <paragraph index="2380" node_type="writer" parent_index="2378">Figure 12. BMM meta-type taxonomy</paragraph>
 <paragraph index="2382" node_type="writer" parent_index="435">BMM_TYPE includes features common to all meta-types:</paragraph>
 <paragraph index="2383" node_type="writer" parent_index="435">is_abstract: indicates a type based on an abstract class - i.e. one that cannot be directly instantiated;</paragraph>
 <paragraph index="2384" node_type="writer" parent_index="435">is_primitive: indicates that a type is derived from a primitive class; primitive status has no effect on BMM model semantics, and is provided as a convenience for visualisation and type-system mapping;</paragraph>
 <paragraph index="2385" node_type="writer" parent_index="435">type_name: the effective type name of an entity; for simple classes, this will just be the class name (BMM_CLASS.name); for generic and container classes it will be generic name such as List&lt;T&gt;, Interval&lt;T&gt; etc; for feature types it will be the declared type, i.e. a simple name, an open type name (e.g. T) or a generic type name (e.g. Interval&lt;Time&gt;);</paragraph>
 <paragraph index="2386" node_type="writer" parent_index="435">type_signature: a form of the type name that can be used as a fully-defined type signature, which for generic classes includes generic constrainer types, giving a signature such as Interval&lt;T:Ordered&gt;.</paragraph>
 <paragraph index="2387" node_type="writer" parent_index="435">Below BMM_TYPE are the abstract meta-type BMM_UNITARY_TYPE and the concrete meta-type BMM_CONTAINER_TYPE and its specialisation BMM_INDEXED_CONTAINER_TYPE. BMM_UNITARY_TYPE is a meta-type for types whose instances are unitary i.e. singular, while the container meta-types correspond to collections of instances. The latter are further described below. This distinction is made to enable BMM to directly represent the notion of collections in the type system rather than treating them in the same way as any other type, which would force modellers (i.e. authors of actual BMM models) to state concrete containment types such as ArrayedList&lt;Packet&gt;, where ArrayedList would have to be defined in the model as well as Packet.</paragraph>
 <paragraph index="2388" node_type="writer" parent_index="435">Unitary meta-types are further distinguished as formal generic parameters (BMM_PARAMETER TYPE) and effective types, i.e. concrete unitary types. The former meta-type is used to represent replaceable formal generic parameters (typically 'T', 'U' within types such as List&lt;T&gt; etc) within generic type declarations.</paragraph>
 <paragraph index="2389" node_type="writer" parent_index="435">Effective types have as their meta-type BMM_EFFECTIVE_TYPE. Its subtypes are BMM_MODEL_TYPE, a meta-type for types defined by classes in the model (thus characterised by the property base_class: BMM_CLASS), BMM_TUPLE_TYPE, a meta-type for tuples (a list of objects of varying types), and BMM_SIGNATURE, a meta-type representing signatures of routines and typed model elements (properties, variables etc).</paragraph>
 <paragraph index="2390" node_type="writer" parent_index="435">BMM_MODEL_TYPE divides into BMM_SIMPLE_TYPE and BMM_GENERIC_TYPE, corresponding to the standard notions of types familiar in modern programming languages. The class definitions of instances (i.e. BMM model class definitions) of these meta-types are available via the property base_class, of meta-type BMM_CLASS for a BMM simple type, and BMM_GENERIC_CLASS for BMM generic type.</paragraph>
 <paragraph index="2391" node_type="writer" parent_index="435">These various concrete meta-types are described in more detail below.</paragraph>
 <paragraph index="2392" node_type="writer" parent_index="435">6.2. Simple Type</paragraph>
 <paragraph index="2393" node_type="writer" parent_index="435">A simple type is a type based only on a simple class, which is a class with no formal generic parameters. An instance of a simple type is fully described by the class on which it is based, with the only difference being the usual object-oriented possibility of polymorphic attachments of sub-objects whose dynamic types conform to their static type counterparts in the original simple type. Thus, for example, a class Organisation may have a property manager of static type Employee. An instance of the simple type Organisation might have its manager property attached to an instance of Manager, which is legal as long as Manager conforms to Employee, which it will do if Manager is defined as a subtype of Employee.</paragraph>
 <paragraph index="2394" node_type="writer" parent_index="435">6.2.1. Conformance</paragraph>
 <paragraph index="2395" node_type="writer" parent_index="435">Conformance of Simple types follows the inheritance hierarchy via which they are defined, according to the rules:</paragraph>
 <paragraph index="2396" node_type="writer" parent_index="435">meta-rule: A Simple type can only conform to a Model type, i.e. either another Simple type or a Generic type;</paragraph>
 <paragraph index="2397" node_type="writer" parent_index="435">concrete rule: A Simple type A conforms to Simple type B iff for base_class of A, all_ancestors() contains B.</paragraph>
 <paragraph index="2398" node_type="writer" parent_index="435">6.3. Generic Type</paragraph>
 <paragraph index="2399" node_type="writer" parent_index="435">A generic type is a type based on a generic class, which has one or more formal type parameters that are substituted by actual types in its declaration. For example, the generic type Interval&lt;Quantity&gt; can be used in a model that contains the generic class Interval&lt;T:Ordered&gt; and Quantity. The general case is that the generic parameter substitution type (BMM_GENERIC_TYPE.generic_parameters) for any formal parameter (BMM_GENERIC_CLASS.generic_parameters) is of meta-type BMM_UNITARY_TYPE.</paragraph>
 <paragraph index="2400" node_type="writer" parent_index="435">A typical programmatic usage of such a type, and its instantiated BMM model structure is shown below.</paragraph>
 <object index="2401" name="bmm_structure_generic_1" object_type="section"/>
 <paragraph index="2402" node_type="writer" parent_index="2401"> </paragraph>
 <paragraph index="2403" node_type="writer" parent_index="2401">Figure 13. Generic type - closed simple</paragraph>
 <paragraph index="2405" node_type="writer" parent_index="435">The parameters of a generic type may be:</paragraph>
 <paragraph index="2406" node_type="writer" parent_index="435">a substitution of a formal parameter from the generic class with a concrete type, including other generic types and container types;</paragraph>
 <paragraph index="2407" node_type="writer" parent_index="435">an unsubstituted formal parameter, if used as the type of a feature, routine argument etc, whose context has an open generic type to which this parameter conforms.</paragraph>
 <paragraph index="2408" node_type="writer" parent_index="435">Consequently, a generic type may be:</paragraph>
 <paragraph index="2409" node_type="writer" parent_index="435">closed: all formal parameters substituted e.g. Interval&lt;Quantity&gt;;</paragraph>
 <paragraph index="2410" node_type="writer" parent_index="435">partially closed: at least one formal parameter is substituted e.g. Document&lt;ClinicalContent, U&gt;;</paragraph>
 <paragraph index="2411" node_type="writer" parent_index="435">open: no formal parameters substituted, e.g. Document&lt;T, U&gt;.</paragraph>
 <paragraph index="2412" node_type="writer" parent_index="435">The first case is detected via the function is_closed defined on BMM_GENERIC_TYPE, while the function is_partially_closed distinguishes the latter two cases.</paragraph>
 <paragraph index="2413" node_type="writer" parent_index="435">The following shows the BMM instance structure of a generic type that is open.</paragraph>
 <object index="2414" name="bmm_structure_generic_3" object_type="section"/>
 <paragraph index="2415" node_type="writer" parent_index="2414"> </paragraph>
 <paragraph index="2416" node_type="writer" parent_index="2414">Figure 14. Generic type - open</paragraph>
 <paragraph index="2418" node_type="writer" parent_index="435">Since the meta-type of BMM_GENERIC_TYPE.generic_parameters in the BMM is BMM_UNITARY_TYPE, constructions such as MyGenericType&lt;List&lt;OtherType&gt;&gt; are prevented, due to the concrete parameter type List&lt;OtherType&gt; being an instance of BMM_CONTAINER_TYPE rather than of BMM_UNITARY_TYPE. Such constructions are nearly always wrong, and not needed in a model expressed in BMM, because containment can be expressed where the formal generic parameter is used, not where the concrete parameter is declared. The following diagram shows the BMM concrete model structure created for a generic type whose formal parameter type is used in this way, i.e. within a container type.</paragraph>
 <object index="2419" name="bmm_structure_generic_2" object_type="section"/>
 <paragraph index="2420" node_type="writer" parent_index="2419"> </paragraph>
 <paragraph index="2421" node_type="writer" parent_index="2419">Figure 15. Generic type - closed container</paragraph>
 <paragraph index="2423" node_type="writer" parent_index="435">6.3.1. Conformance</paragraph>
 <paragraph index="2424" node_type="writer" parent_index="435">Conformance of Generic types is according to the rules:</paragraph>
 <paragraph index="2425" node_type="writer" parent_index="435">meta-rule: A Generic type can only conform to another Generic type;</paragraph>
 <paragraph index="2426" node_type="writer" parent_index="435">concrete rules: A Generic type Ga&lt;Tai, …​&gt; conforms to Generic type Gb&lt;Tbi, …​&gt; iff:</paragraph>
 <paragraph index="2427" node_type="writer" parent_index="435">for base_class of Ga, all_ancestors() contains Gb; and</paragraph>
 <paragraph index="2428" node_type="writer" parent_index="435">the number of generic parameters is equal;</paragraph>
 <paragraph index="2429" node_type="writer" parent_index="435">for each Tai, either</paragraph>
 <paragraph index="2430" node_type="writer" parent_index="435">Tbi is an open formal parameter, and Tai conforms to any generic constraint type, or;</paragraph>
 <paragraph index="2431" node_type="writer" parent_index="435">Tai conforms to Tbi.</paragraph>
 <paragraph index="2432" node_type="writer" parent_index="435">6.4. Container Meta-types</paragraph>
 <paragraph index="2433" node_type="writer" parent_index="435">In object-oriented type theory, 'container' types are generic types whose outer class happens to have the semantics of a container object, such as a list, set etc. Container types such as List&lt;T&gt;, Set&lt;T&gt; and Hash&lt;K,V&gt; are used ubiquitously in object models. In the BMM, containers and non-container generic types are distinguished via the meta-classes BMM_CONTAINER_TYPE and BMM_GENERIC_TYPE respectively. This allows the BMM to treat container types in a special way. A BMM_CONTAINER_TYPE can be thought of as a 1:N counterpart to a BMM_UNITARY_TYPE, such as the type List&lt;Paragraph&gt; with respect to Paragraph. BMM_GENERIC_TYPE is thus used for objects considered to be singular, but whose types are a product of the base class and one or more parameter types, e.g. Interval&lt;Quantity&gt;.</paragraph>
 <paragraph index="2434" node_type="writer" parent_index="435">The explicit provision of BMM_CONTAINER_TYPE enables BMM models to mention logical linear container types such as List&lt;T&gt; and Set&lt;T&gt;, on the assumption of their standard semantics in computer science , without worrying about providing concrete types which may be numerous and also variable across programming languages, e.g. ArrayedList&lt;T&gt;, LinkedSet&lt;T&gt;, ArrayedStack&lt;T&gt; and so on.</paragraph>
 <paragraph index="2435" node_type="writer" parent_index="435">List and Set semantics are achieved via the BMM_CONTAINER_TYPE attributes is_ordered and is_unique, used in the standard combinations i.e.:</paragraph>
 <paragraph index="2436" node_type="writer" parent_index="435">is_ordered and not is_unique: List&lt;T&gt;;</paragraph>
 <paragraph index="2437" node_type="writer" parent_index="435">is_unique: Set&lt;T&gt; (ordered or not);</paragraph>
 <paragraph index="2438" node_type="writer" parent_index="435">not is_ordered and not is_unique: Bag&lt;T&gt;.</paragraph>
 <paragraph index="2439" node_type="writer" parent_index="435">The following diagram shows how the container type List&lt;Paragraph&gt;, declared as the type of an attribute paragraphs in a class Document, is represented in a BMM model.</paragraph>
 <object index="2440" name="bmm_structure_container" object_type="section"/>
 <paragraph index="2441" node_type="writer" parent_index="2440"> </paragraph>
 <paragraph index="2442" node_type="writer" parent_index="2440">Figure 16. Container Type</paragraph>
 <paragraph index="2444" node_type="writer" parent_index="435">The semantics of indexed containers, commonly known under the type names Hash&lt;K,V&gt;, HashMap&lt;K,V&gt;, HashTable&lt;K,V&gt;, Dictionary&lt;K,V&gt; and so on, are represented by the meta-type BMM_INDEXED_CONTAINER_TYPE, which inherits from BMM_CONTAINER_TYPE, and adds the property index_type. The latter type represents the key type, which must be such that hash values can be generated, and may be any type, but practically speaking, is almost always a String, Integer, or a Date/Time type.</paragraph>
 <paragraph index="2445" node_type="writer" parent_index="435">The following diagram shows how the container type Hash&lt;String, Person&gt; is represented in a BMM model.</paragraph>
 <object index="2446" name="bmm_structure_indexed_container" object_type="section"/>
 <paragraph index="2447" node_type="writer" parent_index="2446"> </paragraph>
 <paragraph index="2448" node_type="writer" parent_index="2446">Figure 17. Indexed Container Type</paragraph>
 <paragraph index="2450" node_type="writer" parent_index="435">6.4.1. Conformance</paragraph>
 <paragraph index="2451" node_type="writer" parent_index="435">Conformance of Container types is according to the rules:</paragraph>
 <paragraph index="2452" node_type="writer" parent_index="435">meta-rule: A Container type can only conform to another Container type;</paragraph>
 <paragraph index="2453" node_type="writer" parent_index="435">concrete rules:</paragraph>
 <paragraph index="2454" node_type="writer" parent_index="435">A Container type Ca&lt;Va&gt; conforms to Container type Cb&lt;Vb&gt; conforms to iff:</paragraph>
 <paragraph index="2455" node_type="writer" parent_index="435">for base_class of Ca, all_ancestors() contains Cb; and Va conforms to Vb.</paragraph>
 <paragraph index="2456" node_type="writer" parent_index="435">An indexed Container type Ca&lt;Ka, Va&gt; conforms to indexed Container type Gb&lt;Kb, Vb&gt; iff:</paragraph>
 <paragraph index="2457" node_type="writer" parent_index="435">for base_class of Ca, all_ancestors() contains Cb; Kb conforms to Kb and Va conforms to Vb.</paragraph>
 <paragraph index="2458" node_type="writer" parent_index="435">6.5. Bult-in Meta-types</paragraph>
 <paragraph index="2459" node_type="writer" parent_index="435">BMM includes a small number of built-in meta-types that do not have corresponding model-source classes. These are shown in the following UML and described in the following sub-sections.</paragraph>
 <object index="2460" name="core_entity_builtin" object_type="section"/>
 <paragraph index="2461" node_type="writer" parent_index="2460"> </paragraph>
 <paragraph index="2462" node_type="writer" parent_index="2460">Figure 18. Built-in meta-types</paragraph>
 <paragraph index="2464" node_type="writer" parent_index="435">6.5.1. Tuple Meta-type</paragraph>
 <paragraph index="2465" node_type="writer" parent_index="435">The meta-type BMM_TUPLE_TYPE enables the type of a tuple i.e. an array of objects each of which may be of any type, to be stated in terms of other types. This is mostly used to state the type of a set of arguments in the BMM_SIGNATURE class, but standalone tuple types may also be used in a model, providing roughly the effect of an anonymous class (or a struct in C/C++).The notional type Tuple defined by BMM_TUPLE_TYPE is treadted as a BMM built-in, and is therefore not stated in any BMM model.</paragraph>
 <paragraph index="2466" node_type="writer" parent_index="435">6.5.1.1. Conformance</paragraph>
 <paragraph index="2467" node_type="writer" parent_index="435">Conformance of Tuple types is according to the rules:</paragraph>
 <paragraph index="2468" node_type="writer" parent_index="435">meta-rule: A Tuple type can only conform to another Tuple type;</paragraph>
 <paragraph index="2469" node_type="writer" parent_index="435">concrete rules: A Tuple type Tuple[Tai, …​] conforms to Tuple type Tuple[Tbi, …​] iff:</paragraph>
 <paragraph index="2470" node_type="writer" parent_index="435">for each Tai, Tai conforms to Tbi.</paragraph>
 <paragraph index="2471" node_type="writer" parent_index="435">The practical effect of this is that longer tuples may conform to shorter tuples. For example, the tuple type [Document, String, Integer] conforms to the tuple type [Document].</paragraph>
 <paragraph index="2472" node_type="writer" parent_index="435">6.5.2. Signature Meta-type</paragraph>
 <paragraph index="2473" node_type="writer" parent_index="435">Within any typed formalism, any entity declared as having a type also has a signature. In BMM, this is is the case for any kind of feature of a class, including constants, properties, and routines. The signature of a feature is a formal construct capturing the type structure of the feature. The simplest type of signature is that of properties and constants, which may be expressed formally in a typical abstract syntax as follows:</paragraph>
 <paragraph index="2474" node_type="writer" parent_index="435">    T_result</paragraph>
 <paragraph index="2475" node_type="writer" parent_index="435">This indicates that both have a return type, being the type of the value they are attached to at execution time.</paragraph>
 <paragraph index="2476" node_type="writer" parent_index="435">The general form of routine signatures is as follows:</paragraph>
 <paragraph index="2477" node_type="writer" parent_index="435">    Function &lt;[T_arg1, T_arg2, ...], T_result&gt;    -- Function type</paragraph>
 <paragraph index="2478" node_type="writer" parent_index="435">    Procedure &lt;[T_arg1, T_arg2, ...]&gt;             -- Procedure type</paragraph>
 <paragraph index="2479" node_type="writer" parent_index="435">In the above, the construction [Type, …​] represents a type-tuple. Strictly speaking, the 'Function' and 'Procedure' are unnecessary, since they can be inferred from just the pure signature. However, for readability they are recommended.</paragraph>
 <paragraph index="2480" node_type="writer" parent_index="435">Typical examples of function signatures are as follows:</paragraph>
 <paragraph index="2481" node_type="writer" parent_index="435">    Function &lt;[], Date&gt;                          -- a 0-order function like current_date</paragraph>
 <paragraph index="2482" node_type="writer" parent_index="435">    Function &lt;[Real, Real], Real&gt;                -- a 2nd-order function like '*' for the domain R</paragraph>
 <paragraph index="2483" node_type="writer" parent_index="435">    Function &lt;[Integer, Integer], Integer&gt;       -- a 2nd-order function like 'add' for the domain I</paragraph>
 <paragraph index="2484" node_type="writer" parent_index="435">Typical procedure signatures include the following:</paragraph>
 <paragraph index="2485" node_type="writer" parent_index="435">    Procedure &lt;[]&gt;                               -- a 0-order (argumentless) procedure</paragraph>
 <paragraph index="2486" node_type="writer" parent_index="435">    Procedure &lt;[Real]&gt;                           -- a 1st-order procedure for the domain R</paragraph>
 <paragraph index="2487" node_type="writer" parent_index="435">    Procedure &lt;[String, Integer]&gt;                -- a procedure taking a String and an Integer argument</paragraph>
 <paragraph index="2488" node_type="writer" parent_index="435">In order to support functional semantics such as function-as-object, the notion of signature is defined in BMM as a first order meta-type, BMM_SIGNATURE and descendants. Instances of BMM_SIGNATURE represent any kind of signature and reference the meta-type of the evaluated form via result_type, which may be of any BMM meta-type.</paragraph>
 <paragraph index="2489" node_type="writer" parent_index="435">BMM_ROUTINE_TYPE is the meta-type of any kind of agent (i.e. lambda) and provides argument_types, whose meta-type is BMM_TUPLE_TYPE (See [Tuple Type]). The descendant BMM_PROCEDURE_TYPE specialises the return type to the built-in type BMM_STATUS_TYPE (see below), used to represent the status of a procedure call.</paragraph>
 <paragraph index="2490" node_type="writer" parent_index="435">The following signatures state the types 'any function' and 'any procedure':</paragraph>
 <paragraph index="2491" node_type="writer" parent_index="435">    Function &lt;&gt;                                  -- any function</paragraph>
 <paragraph index="2492" node_type="writer" parent_index="435">    Procedure &lt;&gt;                                 -- any procedure</paragraph>
 <paragraph index="2493" node_type="writer" parent_index="435">As for the Tuple meta-type, the notional Signature meta-type is a BMM built-in, and is not itself defined in any BMM model.</paragraph>
 <paragraph index="2494" node_type="writer" parent_index="435">6.5.2.1. Conformance</paragraph>
 <paragraph index="2495" node_type="writer" parent_index="435">Conformance of Signature types is as follows:</paragraph>
 <paragraph index="2496" node_type="writer" parent_index="435">meta-rule: A Signature type can only conform to another Signature type;</paragraph>
 <paragraph index="2497" node_type="writer" parent_index="435">concrete rules:</paragraph>
 <paragraph index="2498" node_type="writer" parent_index="435">all specific Function signatures conform to the signature Function;</paragraph>
 <paragraph index="2499" node_type="writer" parent_index="435">all specific Procedure signatures conform to the signature Procedure;</paragraph>
 <paragraph index="2500" node_type="writer" parent_index="435">the conformance of specific Function or Procedure signatures to another Function or Procedure signature is such that:</paragraph>
 <paragraph index="2501" node_type="writer" parent_index="435">the number of argument types accord and;</paragraph>
 <paragraph index="2502" node_type="writer" parent_index="435">the type conformance of each corresponding argument and result type (for functions) follows the rules for conformance given by the meta-types of those types.</paragraph>
 <paragraph index="2503" node_type="writer" parent_index="435">6.5.3. Status Meta-type</paragraph>
 <paragraph index="2504" node_type="writer" parent_index="435">The meta-type BMM_STATUS_TYPE is provided to represent the return type of procedure calls, i.e. of which the pure formal type is often denoted Void or None in programming languages. Using a special return type simplifies the meta-model of routines, since without it, procedures create an anomaly within a system in which all other class features have a result type. Within BMM, procedures are considered to be state-changing actions, and the Status return type enables call and/or execution status information to be returned. Usually this can be ignored, and procedures can be called without assignment. This approach is similar to that of Haskell, in which procedure calls return the 'unit' type.</paragraph>
 <paragraph index="2505" node_type="writer" parent_index="435">6.6. Type Conformance</paragraph>
 <paragraph index="2506" node_type="writer" parent_index="435">An algorithm to determine conformance of two type-names (e.g. to implement BMM_MODEL.type_conforms_to()) is as follows:</paragraph>
 <paragraph index="2507" node_type="writer" parent_index="435">Boolean type_conforms_to (String a_type, anc_type)</paragraph>
 <paragraph index="2508" node_type="writer" parent_index="435">{</paragraph>
 <paragraph index="2509" node_type="writer" parent_index="435">    BMM_TYPE_NAME a_type_name, anc_type_name;</paragraph>
 <paragraph index="2511" node_type="writer" parent_index="435">    if attached create_type_name_from_string (a_a_type) as a_type_name and</paragraph>
 <paragraph index="2512" node_type="writer" parent_index="435">        attached create_type_name_from_string (anc_type) as anc_type_name</paragraph>
 <paragraph index="2513" node_type="writer" parent_index="435">    {</paragraph>
 <paragraph index="2514" node_type="writer" parent_index="435">        base_class = a_type_name.name;</paragraph>
 <paragraph index="2515" node_type="writer" parent_index="435">        anc_base_class = anc_type_name.name;</paragraph>
 <paragraph index="2517" node_type="writer" parent_index="435">        if (base_class.is_case_insensitive_equal (anc_base_class) or else</paragraph>
 <paragraph index="2518" node_type="writer" parent_index="435">            class_definition (base_class).has_ancestor_class (anc_base_class))</paragraph>
 <paragraph index="2519" node_type="writer" parent_index="435">        {</paragraph>
 <paragraph index="2520" node_type="writer" parent_index="435">            BMM_CLASS bmm_def_class = class_definition (base_class);</paragraph>
 <paragraph index="2522" node_type="writer" parent_index="435">            // ---- Tuple types</paragraph>
 <paragraph index="2524" node_type="writer" parent_index="435">            // ---- Signature types ----</paragraph>
 <paragraph index="2526" node_type="writer" parent_index="435">            // ---- Generic types</paragraph>
 <paragraph index="2527" node_type="writer" parent_index="435">            // handle case where formal generic names appear in type name</paragraph>
 <paragraph index="2528" node_type="writer" parent_index="435">            if (valid_generic_type_name (a_type) and bmm_def_class instanceOf (BMM_GENERIC_CLASS) {</paragraph>
 <paragraph index="2530" node_type="writer" parent_index="435">                // in the case of both being generic, we need to compare generics</paragraph>
 <paragraph index="2531" node_type="writer" parent_index="435">                // to start with, the number of generics must match</paragraph>
 <paragraph index="2532" node_type="writer" parent_index="435">                BMM_CLASS anc_bmm_def_class = class_definition (anc_base_class);</paragraph>
 <paragraph index="2533" node_type="writer" parent_index="435">                if (valid_generic_type_name (anc_type) and anc_bmm_def_class instanceOf (BMM_GENERIC_CLASS)) {</paragraph>
 <paragraph index="2534" node_type="writer" parent_index="435">                    ArrayedList&lt;String&gt; a_type_gen_params = a_type_name.generic_parameters_type_list;</paragraph>
 <paragraph index="2535" node_type="writer" parent_index="435">                    ArrayedList&lt;String&gt; anc_type_gen_params = anc_type_name.generic_parameters_type_list;</paragraph>
 <paragraph index="2537" node_type="writer" parent_index="435">                    if (a_type_gen_params.count = anc_type_gen_params.count) {</paragraph>
 <paragraph index="2539" node_type="writer" parent_index="435">                        Iterator&lt;String&gt; this_gen_parms_it = a_type_gen_params.iterator();</paragraph>
 <paragraph index="2540" node_type="writer" parent_index="435">                        Iterator&lt;String&gt; other_gen_parms_it = anc_type_gen_params.iterator();</paragraph>
 <paragraph index="2542" node_type="writer" parent_index="435">                        Boolean result = True;</paragraph>
 <paragraph index="2543" node_type="writer" parent_index="435">                        String a_type_gen_type, anc_type_gen_type;</paragraph>
 <paragraph index="2545" node_type="writer" parent_index="435">                        while (this_gen_parms_it.hasNext() &amp;&amp; other_gen_parms_it.hasNext() || !result) {</paragraph>
 <paragraph index="2546" node_type="writer" parent_index="435">                            // first we convert any open generic parameters to their conformance types</paragraph>
 <paragraph index="2547" node_type="writer" parent_index="435">                            // We assume type names of 1 letter are open parameters</paragraph>
 <paragraph index="2548" node_type="writer" parent_index="435">                            String this_gen_parm = this_gen_parms_it.next();</paragraph>
 <paragraph index="2549" node_type="writer" parent_index="435">                            String other_gen_parm = other_gen_parms_it.next();</paragraph>
 <paragraph index="2550" node_type="writer" parent_index="435">                            if (formal_generic_parameter_name (this_gen_parm))</paragraph>
 <paragraph index="2551" node_type="writer" parent_index="435">                                a_type_gen_type = this_bmm_gen_class.generic_parameter_conformance_type (this_gen_parm);</paragraph>
 <paragraph index="2552" node_type="writer" parent_index="435">                            else</paragraph>
 <paragraph index="2553" node_type="writer" parent_index="435">                                a_type_gen_type = this_gen_parm;</paragraph>
 <paragraph index="2555" node_type="writer" parent_index="435">                            if (formal_generic_parameter_name (other_gen_parm))</paragraph>
 <paragraph index="2556" node_type="writer" parent_index="435">                                anc_type_gen_type = other_bmm_gen_class.generic_parameter_conformance_type (other_gen_parm);</paragraph>
 <paragraph index="2557" node_type="writer" parent_index="435">                            else</paragraph>
 <paragraph index="2558" node_type="writer" parent_index="435">                                anc_type_gen_type = other_gen_parm;</paragraph>
 <paragraph index="2560" node_type="writer" parent_index="435">                            -- now do the test</paragraph>
 <paragraph index="2561" node_type="writer" parent_index="435">                            result = type_conforms_to (a_type_gen_type, anc_type_gen_type);</paragraph>
 <paragraph index="2562" node_type="writer" parent_index="435">                        }</paragraph>
 <paragraph index="2564" node_type="writer" parent_index="435">                        return result;</paragraph>
 <paragraph index="2565" node_type="writer" parent_index="435">                    }</paragraph>
 <paragraph index="2567" node_type="writer" parent_index="435">                }</paragraph>
 <paragraph index="2568" node_type="writer" parent_index="435">                // Conforms - case where anc type is not provided in generic form, but desc is</paragraph>
 <paragraph index="2569" node_type="writer" parent_index="435">                // e.g. Interval&lt;Integer&gt; conforms to Interval</paragraph>
 <paragraph index="2570" node_type="writer" parent_index="435">                else</paragraph>
 <paragraph index="2571" node_type="writer" parent_index="435">                    return True;</paragraph>
 <paragraph index="2572" node_type="writer" parent_index="435">            }</paragraph>
 <paragraph index="2573" node_type="writer" parent_index="435">            // in the following case, the descendant type is not generic,</paragraph>
 <paragraph index="2574" node_type="writer" parent_index="435">            // so the ancestor type cannot be either, for conformance</paragraph>
 <paragraph index="2575" node_type="writer" parent_index="435">            else</paragraph>
 <paragraph index="2576" node_type="writer" parent_index="435">                return not valid_generic_type_name (anc_type);</paragraph>
 <paragraph index="2577" node_type="writer" parent_index="435">        }</paragraph>
 <paragraph index="2578" node_type="writer" parent_index="435">    }</paragraph>
 <paragraph index="2579" node_type="writer" parent_index="435">}</paragraph>
 <paragraph index="2580" node_type="writer" parent_index="435">6.7. Model Theoretic Questions</paragraph>
 <paragraph index="2581" node_type="writer" parent_index="435">The above model produces a number of outcomes that are not necessarily immediately obvious or expected, including:</paragraph>
 <paragraph index="2582" node_type="writer" parent_index="435">Inheritance is from classes to types rather than classes;</paragraph>
 <paragraph index="2583" node_type="writer" parent_index="435">A Generic type parameter can only be a unitary type, i.e. not a container type;</paragraph>
 <paragraph index="2584" node_type="writer" parent_index="435">Tuple and Signature types are pure types, i.e. not defined in generating model other than by implication due to use as routine argument lists;</paragraph>
 <paragraph index="2585" node_type="writer" parent_index="435">In theory, a Signature type could be a BMM_GENERIC_TYPE descendant but the specialisation restriction would make the meta-model more complex for no obvious benefit.</paragraph>
 <paragraph index="2586" node_type="writer" parent_index="435">6.8. Class Definitions</paragraph>
 <paragraph index="2587" node_type="writer" parent_index="435">6.8.1. BMM_TYPE Class</paragraph>
 <object index="2588" name="Table22" object_type="table"/>
 <paragraph index="2590" node_type="writer" parent_index="2588">Class</paragraph>
 <paragraph index="2593" node_type="writer" parent_index="2588">BMM_TYPE (abstract)</paragraph>
 <paragraph index="2596" node_type="writer" parent_index="2588">Description</paragraph>
 <paragraph index="2599" node_type="writer" parent_index="2588">Abstract idea of specifying a type in some context. This is not the same as 'defining' a class. A type specification is essentially a reference of some kind, that defines the type of an attribute, or function result or argument. It may include generic parameters that might or might not be bound. See subtypes.</paragraph>
 <paragraph index="2602" node_type="writer" parent_index="2588">Functions</paragraph>
 <paragraph index="2605" node_type="writer" parent_index="2588">Signature</paragraph>
 <paragraph index="2608" node_type="writer" parent_index="2588">Meaning</paragraph>
 <paragraph index="2611" node_type="writer" parent_index="2588">1..1
(abstract)</paragraph>
 <paragraph index="2614" node_type="writer" parent_index="2588">type_name (): String</paragraph>
 <paragraph index="2617" node_type="writer" parent_index="2588">Formal string form of the type as per UML.</paragraph>
 <paragraph index="2620" node_type="writer" parent_index="2588">1..1</paragraph>
 <paragraph index="2623" node_type="writer" parent_index="2588">type_signature (): String</paragraph>
 <paragraph index="2626" node_type="writer" parent_index="2588">Signature form of the type name, which for generics includes generic parameter constrainer types E.g. Interval&lt;T:Ordered&gt;.</paragraph>
 <paragraph index="2627" node_type="writer" parent_index="2588">Defaults to the value of type_name().</paragraph>
 <paragraph index="2630" node_type="writer" parent_index="2588">1..1
(abstract)</paragraph>
 <paragraph index="2633" node_type="writer" parent_index="2588">is_abstract (): Boolean</paragraph>
 <paragraph index="2636" node_type="writer" parent_index="2588">If true, indicates a type based on an abstract class, i.e. a type that cannot be directly instantiated.</paragraph>
 <paragraph index="2639" node_type="writer" parent_index="2588">1..1
(abstract)</paragraph>
 <paragraph index="2642" node_type="writer" parent_index="2588">is_primitive (): Boolean</paragraph>
 <paragraph index="2645" node_type="writer" parent_index="2588">If True, indicates that a type based solely on primitive classes.</paragraph>
 <paragraph index="2648" node_type="writer" parent_index="2588">1..1
(abstract)</paragraph>
 <paragraph index="2651" node_type="writer" parent_index="2588">unitary_type (): BMM_UNITARY_TYPE</paragraph>
 <paragraph index="2654" node_type="writer" parent_index="2588">Type with any container abstracted away; may be a formal generic type.</paragraph>
 <paragraph index="2657" node_type="writer" parent_index="2588">1..1
(abstract)</paragraph>
 <paragraph index="2660" node_type="writer" parent_index="2588">effective_type (): BMM_EFFECTIVE_TYPE</paragraph>
 <paragraph index="2663" node_type="writer" parent_index="2588">Type with any container abstracted away, and any formal parameter replaced by its effective constraint type.</paragraph>
 <paragraph index="2666" node_type="writer" parent_index="2588">1..1
(abstract)</paragraph>
 <paragraph index="2669" node_type="writer" parent_index="2588">flattened_type_list (): List&lt;String&gt;</paragraph>
 <paragraph index="2672" node_type="writer" parent_index="2588">Completely flattened list of type names, flattening out all generic parameters.</paragraph>
 <paragraph index="2675" node_type="writer" parent_index="435">6.8.2. BMM_UNITARY_TYPE Class</paragraph>
 <object index="2676" name="Table23" object_type="table"/>
 <paragraph index="2678" node_type="writer" parent_index="2676">Class</paragraph>
 <paragraph index="2681" node_type="writer" parent_index="2676">BMM_UNITARY_TYPE (abstract)</paragraph>
 <paragraph index="2684" node_type="writer" parent_index="2676">Description</paragraph>
 <paragraph index="2687" node_type="writer" parent_index="2676">Parent of meta-types that may be used as the type of any instantiated object that is not a container object.</paragraph>
 <paragraph index="2690" node_type="writer" parent_index="2676">Inherit</paragraph>
 <paragraph index="2693" node_type="writer" parent_index="2676">BMM_TYPE</paragraph>
 <paragraph index="2696" node_type="writer" parent_index="2676">Functions</paragraph>
 <paragraph index="2699" node_type="writer" parent_index="2676">Signature</paragraph>
 <paragraph index="2702" node_type="writer" parent_index="2676">Meaning</paragraph>
 <paragraph index="2705" node_type="writer" parent_index="2676">1..1
(effected)</paragraph>
 <paragraph index="2708" node_type="writer" parent_index="2676">unitary_type (): BMM_UNITARY_TYPE</paragraph>
 <paragraph index="2711" node_type="writer" parent_index="2676">Result = self.</paragraph>
 <paragraph index="2714" node_type="writer" parent_index="435">6.8.3. BMM_EFFECTIVE_TYPE Class</paragraph>
 <object index="2715" name="Table24" object_type="table"/>
 <paragraph index="2717" node_type="writer" parent_index="2715">Class</paragraph>
 <paragraph index="2720" node_type="writer" parent_index="2715">BMM_EFFECTIVE_TYPE (abstract)</paragraph>
 <paragraph index="2723" node_type="writer" parent_index="2715">Description</paragraph>
 <paragraph index="2726" node_type="writer" parent_index="2715">Meta-type for a concrete, unitary type that can be used as an actual parameter type in a generic type declaration.</paragraph>
 <paragraph index="2729" node_type="writer" parent_index="2715">Inherit</paragraph>
 <paragraph index="2732" node_type="writer" parent_index="2715">BMM_UNITARY_TYPE</paragraph>
 <paragraph index="2735" node_type="writer" parent_index="2715">Functions</paragraph>
 <paragraph index="2738" node_type="writer" parent_index="2715">Signature</paragraph>
 <paragraph index="2741" node_type="writer" parent_index="2715">Meaning</paragraph>
 <paragraph index="2744" node_type="writer" parent_index="2715">1..1
(effected)</paragraph>
 <paragraph index="2747" node_type="writer" parent_index="2715">effective_type (): BMM_EFFECTIVE_TYPE</paragraph>
 <paragraph index="2750" node_type="writer" parent_index="2715">Result = self.</paragraph>
 <paragraph index="2753" node_type="writer" parent_index="2715">1..1
(abstract)</paragraph>
 <paragraph index="2756" node_type="writer" parent_index="2715">type_base_name (): String</paragraph>
 <paragraph index="2759" node_type="writer" parent_index="2715">Name of base generator type, i.e. excluding any generic parts if present.</paragraph>
 <paragraph index="2762" node_type="writer" parent_index="435">6.8.4. BMM_PARAMETER_TYPE Class</paragraph>
 <object index="2763" name="Table25" object_type="table"/>
 <paragraph index="2765" node_type="writer" parent_index="2763">Class</paragraph>
 <paragraph index="2768" node_type="writer" parent_index="2763">BMM_PARAMETER_TYPE</paragraph>
 <paragraph index="2771" node_type="writer" parent_index="2763">Description</paragraph>
 <paragraph index="2774" node_type="writer" parent_index="2763">Definition of a generic parameter in a class definition of a generic type.</paragraph>
 <paragraph index="2777" node_type="writer" parent_index="2763">Inherit</paragraph>
 <paragraph index="2780" node_type="writer" parent_index="2763">BMM_UNITARY_TYPE</paragraph>
 <paragraph index="2783" node_type="writer" parent_index="2763">Attributes</paragraph>
 <paragraph index="2786" node_type="writer" parent_index="2763">Signature</paragraph>
 <paragraph index="2789" node_type="writer" parent_index="2763">Meaning</paragraph>
 <paragraph index="2792" node_type="writer" parent_index="2763">1..1</paragraph>
 <paragraph index="2795" node_type="writer" parent_index="2763">name: String</paragraph>
 <paragraph index="2798" node_type="writer" parent_index="2763">Name of the parameter, e.g. 'T' etc. The name is limited to 1 character and upper-case.</paragraph>
 <paragraph index="2801" node_type="writer" parent_index="2763">0..1</paragraph>
 <paragraph index="2804" node_type="writer" parent_index="2763">type_constraint: BMM_EFFECTIVE_TYPE</paragraph>
 <paragraph index="2807" node_type="writer" parent_index="2763">Optional conformance constraint that must be the name of a defined type.</paragraph>
 <paragraph index="2810" node_type="writer" parent_index="2763">0..1</paragraph>
 <paragraph index="2813" node_type="writer" parent_index="2763">inheritance_precursor: BMM_PARAMETER_TYPE</paragraph>
 <paragraph index="2816" node_type="writer" parent_index="2763">If set, is the corresponding generic parameter definition in an ancestor class.</paragraph>
 <paragraph index="2819" node_type="writer" parent_index="2763">Functions</paragraph>
 <paragraph index="2822" node_type="writer" parent_index="2763">Signature</paragraph>
 <paragraph index="2825" node_type="writer" parent_index="2763">Meaning</paragraph>
 <paragraph index="2828" node_type="writer" parent_index="2763">1..1</paragraph>
 <paragraph index="2831" node_type="writer" parent_index="2763">flattened_conforms_to_type (): BMM_EFFECTIVE_TYPE</paragraph>
 <paragraph index="2834" node_type="writer" parent_index="2763">Result is either conforms_to_type or inheritance_precursor.flattened_conforms_to_type.</paragraph>
 <paragraph index="2837" node_type="writer" parent_index="2763">1..1
(redefined)</paragraph>
 <paragraph index="2840" node_type="writer" parent_index="2763">type_signature (): String</paragraph>
 <paragraph index="2843" node_type="writer" parent_index="2763">Signature form of the open type, including constrainer type if there is one, e.g. T:Ordered.</paragraph>
 <paragraph index="2846" node_type="writer" parent_index="2763">1..1
(effected)</paragraph>
 <paragraph index="2849" node_type="writer" parent_index="2763">is_primitive (): Boolean</paragraph>
 <paragraph index="2852" node_type="writer" parent_index="2763">Result = False - generic parameters are understood by definition to be non-primitive.</paragraph>
 <paragraph index="2855" node_type="writer" parent_index="2763">1..1
(effected)</paragraph>
 <paragraph index="2858" node_type="writer" parent_index="2763">is_abstract (): Boolean</paragraph>
 <paragraph index="2861" node_type="writer" parent_index="2763">Result = False - generic parameters are understood by definition to be non-abstract.</paragraph>
 <paragraph index="2864" node_type="writer" parent_index="2763">1..1
(effected)</paragraph>
 <paragraph index="2867" node_type="writer" parent_index="2763">type_name (): String</paragraph>
 <paragraph index="2870" node_type="writer" parent_index="2763">Return name.</paragraph>
 <paragraph index="2873" node_type="writer" parent_index="2763">1..1
(effected)</paragraph>
 <paragraph index="2876" node_type="writer" parent_index="2763">flattened_type_list (): List&lt;String&gt;</paragraph>
 <paragraph index="2879" node_type="writer" parent_index="2763">Result is either flattened_conforms_to_type.flattened_type_list or the Any type.</paragraph>
 <paragraph index="2882" node_type="writer" parent_index="2763">1..1
(effected)</paragraph>
 <paragraph index="2885" node_type="writer" parent_index="2763">effective_type (): BMM_EFFECTIVE_TYPE</paragraph>
 <paragraph index="2888" node_type="writer" parent_index="2763">Generate ultimate conformance type, which is either flattened_conforms_to_type or if not set, 'Any'.</paragraph>
 <paragraph index="2891" node_type="writer" parent_index="2763">Invariants</paragraph>
 <paragraph index="2894" node_type="writer" parent_index="2763">Inv_generic_name: name.count = 1 and name.is_upper</paragraph>
 <paragraph index="2897" node_type="writer" parent_index="435">6.8.5. BMM_MODEL_TYPE Class</paragraph>
 <object index="2898" name="Table26" object_type="table"/>
 <paragraph index="2900" node_type="writer" parent_index="2898">Class</paragraph>
 <paragraph index="2903" node_type="writer" parent_index="2898">BMM_MODEL_TYPE (abstract)</paragraph>
 <paragraph index="2906" node_type="writer" parent_index="2898">Description</paragraph>
 <paragraph index="2909" node_type="writer" parent_index="2898">A type that is defined by a class (or classes) in the model.</paragraph>
 <paragraph index="2912" node_type="writer" parent_index="2898">Inherit</paragraph>
 <paragraph index="2915" node_type="writer" parent_index="2898">BMM_EFFECTIVE_TYPE</paragraph>
 <paragraph index="2918" node_type="writer" parent_index="2898">Attributes</paragraph>
 <paragraph index="2921" node_type="writer" parent_index="2898">Signature</paragraph>
 <paragraph index="2924" node_type="writer" parent_index="2898">Meaning</paragraph>
 <paragraph index="2927" node_type="writer" parent_index="2898">0..1</paragraph>
 <paragraph index="2930" node_type="writer" parent_index="2898">value_constraint: BMM_VALUE_SET_SPEC</paragraph>
 <paragraph index="2936" node_type="writer" parent_index="2898">1..1</paragraph>
 <paragraph index="2939" node_type="writer" parent_index="2898">base_class: BMM_CLASS</paragraph>
 <paragraph index="2942" node_type="writer" parent_index="2898">Base class of this type.</paragraph>
 <paragraph index="2945" node_type="writer" parent_index="2898">Functions</paragraph>
 <paragraph index="2948" node_type="writer" parent_index="2898">Signature</paragraph>
 <paragraph index="2951" node_type="writer" parent_index="2898">Meaning</paragraph>
 <paragraph index="2954" node_type="writer" parent_index="2898">1..1
(effected)</paragraph>
 <paragraph index="2957" node_type="writer" parent_index="2898">type_base_name (): String</paragraph>
 <paragraph index="2960" node_type="writer" parent_index="2898">Result = base_class.name.</paragraph>
 <paragraph index="2963" node_type="writer" parent_index="2898">1..1
(effected)</paragraph>
 <paragraph index="2966" node_type="writer" parent_index="2898">is_primitive (): Boolean</paragraph>
 <paragraph index="2969" node_type="writer" parent_index="2898">Result = base_class.is_primitive.</paragraph>
 <paragraph index="2972" node_type="writer" parent_index="435">6.8.6. BMM_SIMPLE_TYPE Class</paragraph>
 <object index="2973" name="Table27" object_type="table"/>
 <paragraph index="2975" node_type="writer" parent_index="2973">Class</paragraph>
 <paragraph index="2978" node_type="writer" parent_index="2973">BMM_SIMPLE_TYPE</paragraph>
 <paragraph index="2981" node_type="writer" parent_index="2973">Description</paragraph>
 <paragraph index="2984" node_type="writer" parent_index="2973">Type reference to a single type i.e. not generic or container type.</paragraph>
 <paragraph index="2987" node_type="writer" parent_index="2973">Inherit</paragraph>
 <paragraph index="2990" node_type="writer" parent_index="2973">BMM_MODEL_TYPE</paragraph>
 <paragraph index="2993" node_type="writer" parent_index="2973">Attributes</paragraph>
 <paragraph index="2996" node_type="writer" parent_index="2973">Signature</paragraph>
 <paragraph index="2999" node_type="writer" parent_index="2973">Meaning</paragraph>
 <paragraph index="3002" node_type="writer" parent_index="2973">1..1
(redefined)</paragraph>
 <paragraph index="3005" node_type="writer" parent_index="2973">base_class: BMM_SIMPLE_CLASS</paragraph>
 <paragraph index="3008" node_type="writer" parent_index="2973">Defining class of this type.</paragraph>
 <paragraph index="3011" node_type="writer" parent_index="2973">Functions</paragraph>
 <paragraph index="3014" node_type="writer" parent_index="2973">Signature</paragraph>
 <paragraph index="3017" node_type="writer" parent_index="2973">Meaning</paragraph>
 <paragraph index="3020" node_type="writer" parent_index="2973">1..1
(effected)</paragraph>
 <paragraph index="3023" node_type="writer" parent_index="2973">type_name (): String</paragraph>
 <paragraph index="3026" node_type="writer" parent_index="2973">Result is base_class.name.</paragraph>
 <paragraph index="3029" node_type="writer" parent_index="2973">1..1
(effected)</paragraph>
 <paragraph index="3032" node_type="writer" parent_index="2973">is_abstract (): Boolean</paragraph>
 <paragraph index="3035" node_type="writer" parent_index="2973">Result is base_class.is_abstract.</paragraph>
 <paragraph index="3038" node_type="writer" parent_index="2973">1..1
(effected)</paragraph>
 <paragraph index="3041" node_type="writer" parent_index="2973">flattened_type_list (): List&lt;String&gt;</paragraph>
 <paragraph index="3044" node_type="writer" parent_index="2973">Result is base_class.name .</paragraph>
 <paragraph index="3047" node_type="writer" parent_index="2973">1..1</paragraph>
 <paragraph index="3050" node_type="writer" parent_index="2973">effective_base_class (): BMM_SIMPLE_CLASS</paragraph>
 <paragraph index="3053" node_type="writer" parent_index="2973">Main design class for this type, from which properties etc can be extracted.</paragraph>
 <paragraph index="3056" node_type="writer" parent_index="435">6.8.7. BMM_GENERIC_TYPE Class</paragraph>
 <object index="3057" name="Table28" object_type="table"/>
 <paragraph index="3059" node_type="writer" parent_index="3057">Class</paragraph>
 <paragraph index="3062" node_type="writer" parent_index="3057">BMM_GENERIC_TYPE</paragraph>
 <paragraph index="3065" node_type="writer" parent_index="3057">Description</paragraph>
 <paragraph index="3068" node_type="writer" parent_index="3057">Meta-type based on a non-container generic class, e.g. Packet&lt;Header&gt;.</paragraph>
 <paragraph index="3071" node_type="writer" parent_index="3057">Inherit</paragraph>
 <paragraph index="3074" node_type="writer" parent_index="3057">BMM_MODEL_TYPE</paragraph>
 <paragraph index="3077" node_type="writer" parent_index="3057">Attributes</paragraph>
 <paragraph index="3080" node_type="writer" parent_index="3057">Signature</paragraph>
 <paragraph index="3083" node_type="writer" parent_index="3057">Meaning</paragraph>
 <paragraph index="3086" node_type="writer" parent_index="3057">1..1</paragraph>
 <paragraph index="3089" node_type="writer" parent_index="3057">generic_parameters: List&lt;BMM_UNITARY_TYPE&gt;</paragraph>
 <paragraph index="3092" node_type="writer" parent_index="3057">Generic parameters of the root_type in this type specifier. The order must match the order of the owning class’s formal generic parameter declarations, and the types may be defined types or formal parameter types.</paragraph>
 <paragraph index="3095" node_type="writer" parent_index="3057">1..1
(redefined)</paragraph>
 <paragraph index="3098" node_type="writer" parent_index="3057">base_class: BMM_GENERIC_CLASS</paragraph>
 <paragraph index="3101" node_type="writer" parent_index="3057">Defining generic class of this type.</paragraph>
 <paragraph index="3104" node_type="writer" parent_index="3057">Functions</paragraph>
 <paragraph index="3107" node_type="writer" parent_index="3057">Signature</paragraph>
 <paragraph index="3110" node_type="writer" parent_index="3057">Meaning</paragraph>
 <paragraph index="3113" node_type="writer" parent_index="3057">1..1
(effected)</paragraph>
 <paragraph index="3116" node_type="writer" parent_index="3057">type_name (): String</paragraph>
 <paragraph index="3119" node_type="writer" parent_index="3057">Return the full name of the type including generic parameters, e.g. DV_INTERVAL&lt;T&gt;, TABLE&lt;List&lt;THING&gt;,String&gt;.</paragraph>
 <paragraph index="3122" node_type="writer" parent_index="3057">1..1
(redefined)</paragraph>
 <paragraph index="3125" node_type="writer" parent_index="3057">type_signature (): String</paragraph>
 <paragraph index="3128" node_type="writer" parent_index="3057">Signature form of the type, which for generics includes generic parameter constrainer types E.g. Interval&lt;T:Ordered&gt;.</paragraph>
 <paragraph index="3131" node_type="writer" parent_index="3057">1..1
(effected)</paragraph>
 <paragraph index="3134" node_type="writer" parent_index="3057">is_abstract (): Boolean</paragraph>
 <paragraph index="3137" node_type="writer" parent_index="3057">True if base_class.is_abstract or if any (non-open) parameter type is abstract.</paragraph>
 <paragraph index="3140" node_type="writer" parent_index="3057">1..1
(effected)</paragraph>
 <paragraph index="3143" node_type="writer" parent_index="3057">flattened_type_list (): List&lt;String&gt;</paragraph>
 <paragraph index="3146" node_type="writer" parent_index="3057">Result is base_class.name followed by names of all generic parameter type names, which may be open or closed.</paragraph>
 <paragraph index="3149" node_type="writer" parent_index="3057">1..1</paragraph>
 <paragraph index="3152" node_type="writer" parent_index="3057">is_partially_closed (): Boolean</paragraph>
 <paragraph index="3155" node_type="writer" parent_index="3057">Returns True if there is any substituted generic parameter.</paragraph>
 <paragraph index="3158" node_type="writer" parent_index="3057">1..1</paragraph>
 <paragraph index="3161" node_type="writer" parent_index="3057">effective_base_class (): BMM_GENERIC_CLASS</paragraph>
 <paragraph index="3164" node_type="writer" parent_index="3057">Effective underlying class for this type, abstracting away any container type.</paragraph>
 <paragraph index="3167" node_type="writer" parent_index="3057">1..1</paragraph>
 <paragraph index="3170" node_type="writer" parent_index="3057">is_open (): Boolean</paragraph>
 <paragraph index="3173" node_type="writer" parent_index="3057">True if all generic parameters from ancestor generic types have been substituted in this type.</paragraph>
 <paragraph index="3176" node_type="writer" parent_index="435">6.8.8. BMM_BUILTIN_TYPE Class</paragraph>
 <object index="3177" name="Table29" object_type="table"/>
 <paragraph index="3179" node_type="writer" parent_index="3177">Class</paragraph>
 <paragraph index="3182" node_type="writer" parent_index="3177">BMM_BUILTIN_TYPE (abstract)</paragraph>
 <paragraph index="3185" node_type="writer" parent_index="3177">Description</paragraph>
 <paragraph index="3188" node_type="writer" parent_index="3177">Parent of built-in types, which are treated as being primitive and non-abstract.</paragraph>
 <paragraph index="3191" node_type="writer" parent_index="3177">Inherit</paragraph>
 <paragraph index="3194" node_type="writer" parent_index="3177">BMM_EFFECTIVE_TYPE</paragraph>
 <paragraph index="3197" node_type="writer" parent_index="3177">Constants</paragraph>
 <paragraph index="3200" node_type="writer" parent_index="3177">Signature</paragraph>
 <paragraph index="3203" node_type="writer" parent_index="3177">Meaning</paragraph>
 <paragraph index="3206" node_type="writer" parent_index="3177">1..1</paragraph>
 <paragraph index="3209" node_type="writer" parent_index="3177">base_name: String = </paragraph>
 <paragraph index="3212" node_type="writer" parent_index="3177">Base name (built-in typename).</paragraph>
 <paragraph index="3215" node_type="writer" parent_index="3177">Functions</paragraph>
 <paragraph index="3218" node_type="writer" parent_index="3177">Signature</paragraph>
 <paragraph index="3221" node_type="writer" parent_index="3177">Meaning</paragraph>
 <paragraph index="3224" node_type="writer" parent_index="3177">1..1
(effected)</paragraph>
 <paragraph index="3227" node_type="writer" parent_index="3177">is_abstract (): Boolean</paragraph>
 <paragraph index="3230" node_type="writer" parent_index="3177">Return False.</paragraph>
 <paragraph index="3233" node_type="writer" parent_index="3177">1..1
(effected)</paragraph>
 <paragraph index="3236" node_type="writer" parent_index="3177">is_primitive (): Boolean</paragraph>
 <paragraph index="3239" node_type="writer" parent_index="3177">Return True.</paragraph>
 <paragraph index="3242" node_type="writer" parent_index="3177">1..1
(effected)</paragraph>
 <paragraph index="3245" node_type="writer" parent_index="3177">type_base_name (): String</paragraph>
 <paragraph index="3248" node_type="writer" parent_index="3177">Return base_name.</paragraph>
 <paragraph index="3251" node_type="writer" parent_index="3177">1..1
(effected)</paragraph>
 <paragraph index="3254" node_type="writer" parent_index="3177">type_name (): String</paragraph>
 <paragraph index="3257" node_type="writer" parent_index="3177">Return base_name.</paragraph>
 <paragraph index="3260" node_type="writer" parent_index="435">6.8.9. BMM_TUPLE_TYPE Class</paragraph>
 <object index="3261" name="Table30" object_type="table"/>
 <paragraph index="3263" node_type="writer" parent_index="3261">Class</paragraph>
 <paragraph index="3266" node_type="writer" parent_index="3261">BMM_TUPLE_TYPE</paragraph>
 <paragraph index="3269" node_type="writer" parent_index="3261">Description</paragraph>
 <paragraph index="3272" node_type="writer" parent_index="3261">Built-in meta-type representing the type of a tuple, i.e. an array of any number of other types. This includes both container and unitary types, since tuple instances represent concrete objects.</paragraph>
 <paragraph index="3273" node_type="writer" parent_index="3261">Note that both open and closed generic parameters are allowed, as with any generic type, but open generic parameters are only valid within the scope of a generic class.</paragraph>
 <paragraph index="3276" node_type="writer" parent_index="3261">Inherit</paragraph>
 <paragraph index="3279" node_type="writer" parent_index="3261">BMM_BUILTIN_TYPE</paragraph>
 <paragraph index="3282" node_type="writer" parent_index="3261">Constants</paragraph>
 <paragraph index="3285" node_type="writer" parent_index="3261">Signature</paragraph>
 <paragraph index="3288" node_type="writer" parent_index="3261">Meaning</paragraph>
 <paragraph index="3291" node_type="writer" parent_index="3261">1..1
(redefined)</paragraph>
 <paragraph index="3294" node_type="writer" parent_index="3261">base_name: String = &quot;Tuple&quot;</paragraph>
 <paragraph index="3297" node_type="writer" parent_index="3261">Base name (built-in).</paragraph>
 <paragraph index="3300" node_type="writer" parent_index="3261">Attributes</paragraph>
 <paragraph index="3303" node_type="writer" parent_index="3261">Signature</paragraph>
 <paragraph index="3306" node_type="writer" parent_index="3261">Meaning</paragraph>
 <paragraph index="3309" node_type="writer" parent_index="3261">1..1</paragraph>
 <paragraph index="3312" node_type="writer" parent_index="3261">item_types: Hash&lt;String,BMM_TYPE&gt;</paragraph>
 <paragraph index="3315" node_type="writer" parent_index="3261">List of types of the items of the tuple, keyed by purpose in the tuple.</paragraph>
 <paragraph index="3318" node_type="writer" parent_index="3261">Functions</paragraph>
 <paragraph index="3321" node_type="writer" parent_index="3261">Signature</paragraph>
 <paragraph index="3324" node_type="writer" parent_index="3261">Meaning</paragraph>
 <paragraph index="3327" node_type="writer" parent_index="3261">1..1
(effected)</paragraph>
 <paragraph index="3330" node_type="writer" parent_index="3261">flattened_type_list (): List&lt;String&gt;</paragraph>
 <paragraph index="3333" node_type="writer" parent_index="3261">Return the logical set (i.e. unique types) from the merge of flattened_type_list() called on each member of item_types.</paragraph>
 <paragraph index="3336" node_type="writer" parent_index="435">6.8.10. BMM_SIGNATURE Class</paragraph>
 <object index="3337" name="Table31" object_type="table"/>
 <paragraph index="3339" node_type="writer" parent_index="3337">Class</paragraph>
 <paragraph index="3342" node_type="writer" parent_index="3337">BMM_SIGNATURE</paragraph>
 <paragraph index="3345" node_type="writer" parent_index="3337">Description</paragraph>
 <paragraph index="3348" node_type="writer" parent_index="3337">Built-in meta-type that expresses the type structure of any referenceable element of a model. Consists of potential arguments and result, with constraints in descendants determining the exact form.</paragraph>
 <paragraph index="3351" node_type="writer" parent_index="3337">Inherit</paragraph>
 <paragraph index="3354" node_type="writer" parent_index="3337">BMM_BUILTIN_TYPE</paragraph>
 <paragraph index="3357" node_type="writer" parent_index="3337">Constants</paragraph>
 <paragraph index="3360" node_type="writer" parent_index="3337">Signature</paragraph>
 <paragraph index="3363" node_type="writer" parent_index="3337">Meaning</paragraph>
 <paragraph index="3366" node_type="writer" parent_index="3337">1..1
(redefined)</paragraph>
 <paragraph index="3369" node_type="writer" parent_index="3337">base_name: String = &quot;Signature&quot;</paragraph>
 <paragraph index="3372" node_type="writer" parent_index="3337">Base name (built-in).</paragraph>
 <paragraph index="3375" node_type="writer" parent_index="3337">Attributes</paragraph>
 <paragraph index="3378" node_type="writer" parent_index="3337">Signature</paragraph>
 <paragraph index="3381" node_type="writer" parent_index="3337">Meaning</paragraph>
 <paragraph index="3384" node_type="writer" parent_index="3337">1..1</paragraph>
 <paragraph index="3387" node_type="writer" parent_index="3337">result_type: BMM_TYPE</paragraph>
 <paragraph index="3390" node_type="writer" parent_index="3337">Result type of signature.</paragraph>
 <paragraph index="3393" node_type="writer" parent_index="3337">Functions</paragraph>
 <paragraph index="3396" node_type="writer" parent_index="3337">Signature</paragraph>
 <paragraph index="3399" node_type="writer" parent_index="3337">Meaning</paragraph>
 <paragraph index="3402" node_type="writer" parent_index="3337">1..1
(effected)</paragraph>
 <paragraph index="3405" node_type="writer" parent_index="3337">flattened_type_list (): List&lt;String&gt;</paragraph>
 <paragraph index="3408" node_type="writer" parent_index="3337">Return the logical set (i.e. unique items) consisting of argument_types.flattened_type_list() and result_type.flattened_type_list().</paragraph>
 <paragraph index="3411" node_type="writer" parent_index="435">6.8.11. BMM_PROPERTY_TYPE Class</paragraph>
 <object index="3412" name="Table32" object_type="table"/>
 <paragraph index="3414" node_type="writer" parent_index="3412">Class</paragraph>
 <paragraph index="3417" node_type="writer" parent_index="3412">BMM_PROPERTY_TYPE</paragraph>
 <paragraph index="3420" node_type="writer" parent_index="3412">Description</paragraph>
 <paragraph index="3423" node_type="writer" parent_index="3412">Meta-type for property and variable signatures.</paragraph>
 <paragraph index="3426" node_type="writer" parent_index="3412">Inherit</paragraph>
 <paragraph index="3429" node_type="writer" parent_index="3412">BMM_SIGNATURE</paragraph>
 <paragraph index="3432" node_type="writer" parent_index="435">6.8.12. BMM_ROUTINE_TYPE Class</paragraph>
 <object index="3433" name="Table33" object_type="table"/>
 <paragraph index="3435" node_type="writer" parent_index="3433">Class</paragraph>
 <paragraph index="3438" node_type="writer" parent_index="3433">BMM_ROUTINE_TYPE</paragraph>
 <paragraph index="3441" node_type="writer" parent_index="3433">Description</paragraph>
 <paragraph index="3444" node_type="writer" parent_index="3433">Meta-type for routine objects.</paragraph>
 <paragraph index="3447" node_type="writer" parent_index="3433">Inherit</paragraph>
 <paragraph index="3450" node_type="writer" parent_index="3433">BMM_SIGNATURE</paragraph>
 <paragraph index="3453" node_type="writer" parent_index="3433">Constants</paragraph>
 <paragraph index="3456" node_type="writer" parent_index="3433">Signature</paragraph>
 <paragraph index="3459" node_type="writer" parent_index="3433">Meaning</paragraph>
 <paragraph index="3462" node_type="writer" parent_index="3433">1..1
(redefined)</paragraph>
 <paragraph index="3465" node_type="writer" parent_index="3433">base_name: String = &quot;Routine&quot;</paragraph>
 <paragraph index="3468" node_type="writer" parent_index="3433">Base name (built-in).</paragraph>
 <paragraph index="3471" node_type="writer" parent_index="3433">Attributes</paragraph>
 <paragraph index="3474" node_type="writer" parent_index="3433">Signature</paragraph>
 <paragraph index="3477" node_type="writer" parent_index="3433">Meaning</paragraph>
 <paragraph index="3480" node_type="writer" parent_index="3433">0..1</paragraph>
 <paragraph index="3483" node_type="writer" parent_index="3433">argument_types: BMM_TUPLE_TYPE</paragraph>
 <paragraph index="3486" node_type="writer" parent_index="3433">Type of arguments in the signature, if any; represented as a type-tuple (list of arbitrary types).</paragraph>
 <paragraph index="3489" node_type="writer" parent_index="435">6.8.13. BMM_FUNCTION_TYPE Class</paragraph>
 <object index="3490" name="Table34" object_type="table"/>
 <paragraph index="3492" node_type="writer" parent_index="3490">Class</paragraph>
 <paragraph index="3495" node_type="writer" parent_index="3490">BMM_FUNCTION_TYPE</paragraph>
 <paragraph index="3498" node_type="writer" parent_index="3490">Description</paragraph>
 <paragraph index="3501" node_type="writer" parent_index="3490">Meta-type for function object signatures.</paragraph>
 <paragraph index="3504" node_type="writer" parent_index="3490">Inherit</paragraph>
 <paragraph index="3507" node_type="writer" parent_index="3490">BMM_ROUTINE_TYPE</paragraph>
 <paragraph index="3510" node_type="writer" parent_index="3490">Constants</paragraph>
 <paragraph index="3513" node_type="writer" parent_index="3490">Signature</paragraph>
 <paragraph index="3516" node_type="writer" parent_index="3490">Meaning</paragraph>
 <paragraph index="3519" node_type="writer" parent_index="3490">1..1
(redefined)</paragraph>
 <paragraph index="3522" node_type="writer" parent_index="3490">base_name: String = &quot;Function&quot;</paragraph>
 <paragraph index="3525" node_type="writer" parent_index="3490">Base name (built-in).</paragraph>
 <paragraph index="3528" node_type="writer" parent_index="435">6.8.14. BMM_PROCEDURE_TYPE Class</paragraph>
 <object index="3529" name="Table35" object_type="table"/>
 <paragraph index="3531" node_type="writer" parent_index="3529">Class</paragraph>
 <paragraph index="3534" node_type="writer" parent_index="3529">BMM_PROCEDURE_TYPE</paragraph>
 <paragraph index="3537" node_type="writer" parent_index="3529">Description</paragraph>
 <paragraph index="3540" node_type="writer" parent_index="3529">Form of routine specific to procedure object signatures, with result_type being the special Status meta-type</paragraph>
 <paragraph index="3543" node_type="writer" parent_index="3529">Inherit</paragraph>
 <paragraph index="3546" node_type="writer" parent_index="3529">BMM_ROUTINE_TYPE</paragraph>
 <paragraph index="3549" node_type="writer" parent_index="3529">Constants</paragraph>
 <paragraph index="3552" node_type="writer" parent_index="3529">Signature</paragraph>
 <paragraph index="3555" node_type="writer" parent_index="3529">Meaning</paragraph>
 <paragraph index="3558" node_type="writer" parent_index="3529">1..1
(redefined)</paragraph>
 <paragraph index="3561" node_type="writer" parent_index="3529">base_name: String = &quot;Procedure&quot;</paragraph>
 <paragraph index="3564" node_type="writer" parent_index="3529">Base name (built-in).</paragraph>
 <paragraph index="3567" node_type="writer" parent_index="3529">Attributes</paragraph>
 <paragraph index="3570" node_type="writer" parent_index="3529">Signature</paragraph>
 <paragraph index="3573" node_type="writer" parent_index="3529">Meaning</paragraph>
 <paragraph index="3576" node_type="writer" parent_index="3529">0..1
(redefined)</paragraph>
 <paragraph index="3579" node_type="writer" parent_index="3529">result_type: BMM_STATUS_TYPE</paragraph>
 <paragraph index="3582" node_type="writer" parent_index="3529">Result type of a procedure.</paragraph>
 <paragraph index="3585" node_type="writer" parent_index="435">6.8.15. BMM_STATUS_TYPE Class</paragraph>
 <object index="3586" name="Table36" object_type="table"/>
 <paragraph index="3588" node_type="writer" parent_index="3586">Class</paragraph>
 <paragraph index="3591" node_type="writer" parent_index="3586">BMM_STATUS_TYPE</paragraph>
 <paragraph index="3594" node_type="writer" parent_index="3586">Description</paragraph>
 <paragraph index="3597" node_type="writer" parent_index="3586">Built-in meta-type representing action status, e.g. result of a call invocation.</paragraph>
 <paragraph index="3600" node_type="writer" parent_index="3586">Inherit</paragraph>
 <paragraph index="3603" node_type="writer" parent_index="3586">BMM_BUILTIN_TYPE</paragraph>
 <paragraph index="3606" node_type="writer" parent_index="3586">Constants</paragraph>
 <paragraph index="3609" node_type="writer" parent_index="3586">Signature</paragraph>
 <paragraph index="3612" node_type="writer" parent_index="3586">Meaning</paragraph>
 <paragraph index="3615" node_type="writer" parent_index="3586">1..1
(redefined)</paragraph>
 <paragraph index="3618" node_type="writer" parent_index="3586">base_name: String = &quot;Status&quot;</paragraph>
 <paragraph index="3621" node_type="writer" parent_index="3586">Base name (built-in).</paragraph>
 <paragraph index="3624" node_type="writer" parent_index="435">6.8.16. BMM_CONTAINER_TYPE Class</paragraph>
 <object index="3625" name="Table37" object_type="table"/>
 <paragraph index="3627" node_type="writer" parent_index="3625">Class</paragraph>
 <paragraph index="3630" node_type="writer" parent_index="3625">BMM_CONTAINER_TYPE</paragraph>
 <paragraph index="3633" node_type="writer" parent_index="3625">Description</paragraph>
 <paragraph index="3636" node_type="writer" parent_index="3625">Meta-type that specifies linear containers with a generic parameter corresponding to the type of contained item, and whose container type is a generic type such as List&lt;T&gt;, Set&lt;T&gt; etc.</paragraph>
 <paragraph index="3639" node_type="writer" parent_index="3625">Inherit</paragraph>
 <paragraph index="3642" node_type="writer" parent_index="3625">BMM_TYPE</paragraph>
 <paragraph index="3645" node_type="writer" parent_index="3625">Attributes</paragraph>
 <paragraph index="3648" node_type="writer" parent_index="3625">Signature</paragraph>
 <paragraph index="3651" node_type="writer" parent_index="3625">Meaning</paragraph>
 <paragraph index="3654" node_type="writer" parent_index="3625">1..1</paragraph>
 <paragraph index="3657" node_type="writer" parent_index="3625">container_class: BMM_GENERIC_CLASS</paragraph>
 <paragraph index="3660" node_type="writer" parent_index="3625">The type of the container. This converts to the root_type in BMM_GENERIC_TYPE.</paragraph>
 <paragraph index="3663" node_type="writer" parent_index="3625">1..1</paragraph>
 <paragraph index="3666" node_type="writer" parent_index="3625">item_type: BMM_UNITARY_TYPE</paragraph>
 <paragraph index="3669" node_type="writer" parent_index="3625">The container item type.</paragraph>
 <paragraph index="3672" node_type="writer" parent_index="3625">0..1</paragraph>
 <paragraph index="3675" node_type="writer" parent_index="3625">is_ordered: Boolean
{default = true}</paragraph>
 <paragraph index="3678" node_type="writer" parent_index="3625">True indicates that order of the items in the container attribute is considered significant and must be preserved, e.g. across sessions, serialisation, deserialisation etc. Otherwise known as 'list' semantics.</paragraph>
 <paragraph index="3681" node_type="writer" parent_index="3625">0..1</paragraph>
 <paragraph index="3684" node_type="writer" parent_index="3625">is_unique: Boolean
{default = false}</paragraph>
 <paragraph index="3687" node_type="writer" parent_index="3625">True indicates that only unique instances of items in the container are allowed. Otherwise known as 'set' semantics.</paragraph>
 <paragraph index="3690" node_type="writer" parent_index="3625">Functions</paragraph>
 <paragraph index="3693" node_type="writer" parent_index="3625">Signature</paragraph>
 <paragraph index="3696" node_type="writer" parent_index="3625">Meaning</paragraph>
 <paragraph index="3699" node_type="writer" parent_index="3625">1..1
(effected)</paragraph>
 <paragraph index="3702" node_type="writer" parent_index="3625">type_name (): String</paragraph>
 <paragraph index="3705" node_type="writer" parent_index="3625">Return full type name, e.g. List&lt;ELEMENT&gt;.</paragraph>
 <paragraph index="3708" node_type="writer" parent_index="3625">1..1
(effected)</paragraph>
 <paragraph index="3711" node_type="writer" parent_index="3625">is_abstract (): Boolean

Post_is_abstract: Result = container_type.is_abstract</paragraph>
 <paragraph index="3714" node_type="writer" parent_index="3625">True if the container class is abstract.</paragraph>
 <paragraph index="3717" node_type="writer" parent_index="3625">1..1
(effected)</paragraph>
 <paragraph index="3720" node_type="writer" parent_index="3625">flattened_type_list (): List&lt;String&gt;

Post_result: Result = item_type.flattened_type_list</paragraph>
 <paragraph index="3723" node_type="writer" parent_index="3625">Flattened list of type names of item_type, i.e. item_type.flattened_type_list().</paragraph>
 <paragraph index="3726" node_type="writer" parent_index="3625">1..1
(effected)</paragraph>
 <paragraph index="3729" node_type="writer" parent_index="3625">unitary_type (): BMM_UNITARY_TYPE</paragraph>
 <paragraph index="3732" node_type="writer" parent_index="3625">Return item_type.</paragraph>
 <paragraph index="3735" node_type="writer" parent_index="3625">1..1
(effected)</paragraph>
 <paragraph index="3738" node_type="writer" parent_index="3625">is_primitive (): Boolean

Post_result: Result = item_type.is_primitive</paragraph>
 <paragraph index="3741" node_type="writer" parent_index="3625">True if item_type is primitive.</paragraph>
 <paragraph index="3744" node_type="writer" parent_index="3625">1..1
(effected)</paragraph>
 <paragraph index="3747" node_type="writer" parent_index="3625">effective_type (): BMM_EFFECTIVE_TYPE</paragraph>
 <paragraph index="3750" node_type="writer" parent_index="3625">Return item_type.effective_type().</paragraph>
 <paragraph index="3753" node_type="writer" parent_index="435">6.8.17. BMM_INDEXED_CONTAINER_TYPE Class</paragraph>
 <object index="3754" name="Table38" object_type="table"/>
 <paragraph index="3756" node_type="writer" parent_index="3754">Class</paragraph>
 <paragraph index="3759" node_type="writer" parent_index="3754">BMM_INDEXED_CONTAINER_TYPE</paragraph>
 <paragraph index="3762" node_type="writer" parent_index="3754">Description</paragraph>
 <paragraph index="3765" node_type="writer" parent_index="3754">Meta-type of linear container type that indexes the contained items in the manner of a standard Hash table, map or dictionary.</paragraph>
 <paragraph index="3768" node_type="writer" parent_index="3754">Inherit</paragraph>
 <paragraph index="3771" node_type="writer" parent_index="3754">BMM_CONTAINER_TYPE</paragraph>
 <paragraph index="3774" node_type="writer" parent_index="3754">Attributes</paragraph>
 <paragraph index="3777" node_type="writer" parent_index="3754">Signature</paragraph>
 <paragraph index="3780" node_type="writer" parent_index="3754">Meaning</paragraph>
 <paragraph index="3783" node_type="writer" parent_index="3754">1..1</paragraph>
 <paragraph index="3786" node_type="writer" parent_index="3754">index_type: BMM_SIMPLE_TYPE</paragraph>
 <paragraph index="3789" node_type="writer" parent_index="3754">Type of the element index, typically String or Integer, but may be a numeric type or indeed any type from which a hash value can be derived.</paragraph>
 <paragraph index="3792" node_type="writer" parent_index="3754">Functions</paragraph>
 <paragraph index="3795" node_type="writer" parent_index="3754">Signature</paragraph>
 <paragraph index="3798" node_type="writer" parent_index="3754">Meaning</paragraph>
 <paragraph index="3801" node_type="writer" parent_index="3754">1..1
(effected)</paragraph>
 <paragraph index="3804" node_type="writer" parent_index="3754">type_name (): String</paragraph>
 <paragraph index="3807" node_type="writer" parent_index="3754">Return full type name, e.g. HashMap&lt;String, ELEMENT&gt;.</paragraph>
 <paragraph index="3810" node_type="writer" parent_index="435">7. Classes</paragraph>
 <paragraph index="3811" node_type="writer" parent_index="435">7.1. Overview</paragraph>
 <paragraph index="3812" node_type="writer" parent_index="435">This section describes the semantics of the BMM_CLASS meta-class, its sub-types, constituent parts and relationships. Classes in BMM are generators of types, and are what is authored (i.e. 'programmed') in order to create a model or program text.</paragraph>
 <paragraph index="3813" node_type="writer" parent_index="435">The formally typed parts of a class are collectively known as features, and consist of functions, procedures, constants and properties, which appear in feature groups. Within a class, all features are contained in the features attribute (inherited from BMM_MODULE), with features of each specific type being referenced in a dedicated map (BMM_CLASS.properties etc). The following UML illustrates classes and relationships to constituent feature meta-types. Features are described in detail in the following section.</paragraph>
 <object index="3814" name="core_class" object_type="section"/>
 <paragraph index="3815" node_type="writer" parent_index="3814"> </paragraph>
 <paragraph index="3816" node_type="writer" parent_index="3814">Figure 19. base.bmm.core Package - Classes</paragraph>
 <paragraph index="3818" node_type="writer" parent_index="435">Class definitions are the definitional basis of a BMM model, i.e. they are the means of defining the types that are statically used in the model, and the dynamic types generated at runtime. Types are thus derived entities.</paragraph>
 <paragraph index="3819" node_type="writer" parent_index="435">The top meta-class BMM_CLASS defines two properties inherent in classes defined in a model, and derived in resulting types: is_abstract and is_primitive. The Boolean attribute is_abstract indicates a class that cannot be directly instantiated. The attribute is_primitive indicates that a class is considered to be part of a primitive type set (typically corresponding to primitive types in another type system). Primitive status has no effect on BMM model semantics, and is provided as a convenience for visualisation and type-system mapping.</paragraph>
 <paragraph index="3820" node_type="writer" parent_index="435">BMM distinguishes between simple and generic class definitions via two descendants of BMM_CLASS, i.e. BMM_SIMPLE_CLASS and BMM_GENERIC_CLASS, with the first providing a concrete form of BMM_CLASS that applies to non-generic classes, and the latter defining the additional semantics of generic classes. The meta-type BMM_ENUMERATION is a specialisation of BMM_SIMPLE_CLASS used to represent enumeration classes in BMM models. The meta-types are further described below.</paragraph>
 <paragraph index="3821" node_type="writer" parent_index="435">7.2. Simple Classes</paragraph>
 <paragraph index="3822" node_type="writer" parent_index="435">The simplest type of class definition in a model is an instance of the meta-type BMM_SIMPLE_CLASS, and has a 1:1 relationship with its type. Such classes might be specified in the following abstract syntax:</paragraph>
 <paragraph index="3823" node_type="writer" parent_index="435">class DvQuantity</paragraph>
 <paragraph index="3824" node_type="writer" parent_index="435">{</paragraph>
 <paragraph index="3825" node_type="writer" parent_index="435">    feature</paragraph>
 <paragraph index="3826" node_type="writer" parent_index="435">        // feature definitions</paragraph>
 <paragraph index="3827" node_type="writer" parent_index="435">}</paragraph>
 <paragraph index="3829" node_type="writer" parent_index="435">class Observation</paragraph>
 <paragraph index="3830" node_type="writer" parent_index="435">{</paragraph>
 <paragraph index="3831" node_type="writer" parent_index="435">    feature</paragraph>
 <paragraph index="3832" node_type="writer" parent_index="435">        // feature definitions</paragraph>
 <paragraph index="3833" node_type="writer" parent_index="435">}</paragraph>
 <paragraph index="3834" node_type="writer" parent_index="435">7.3. Generic Classes</paragraph>
 <paragraph index="3835" node_type="writer" parent_index="435">The generic class meta-type BMM_GENERIC_CLASS adds generic parameters to BMM_CLASS, enabling formal generic parameters to be represented. Each such parameter is expressed using an instance of BMM_PARAMETER_TYPE which names the parameter and optionally allows a type constraint to be associated with it, in the usual object-oriented fashion. In BMM, formal parameters have single-letter names, such as 'T', 'U' etc, following typical usage in programming languages. A generic class may also be primitive. Generic classes can be defined in a syntax similar to the following.</paragraph>
 <paragraph index="3836" node_type="writer" parent_index="435">//</paragraph>
 <paragraph index="3837" node_type="writer" parent_index="435">// a primitive generic class with an open type parameter</paragraph>
 <paragraph index="3838" node_type="writer" parent_index="435">//</paragraph>
 <paragraph index="3839" node_type="writer" parent_index="435">primitive class List &lt;T&gt;</paragraph>
 <paragraph index="3841" node_type="writer" parent_index="435">feature</paragraph>
 <paragraph index="3842" node_type="writer" parent_index="435">    // feature definitions</paragraph>
 <paragraph index="3845" node_type="writer" parent_index="435">//</paragraph>
 <paragraph index="3846" node_type="writer" parent_index="435">// a generic class with a constrained type parameter</paragraph>
 <paragraph index="3847" node_type="writer" parent_index="435">//</paragraph>
 <paragraph index="3848" node_type="writer" parent_index="435">class DvInterval &lt;T:DvOrdered&gt;</paragraph>
 <paragraph index="3850" node_type="writer" parent_index="435">feature</paragraph>
 <paragraph index="3851" node_type="writer" parent_index="435">    // feature definitions</paragraph>
 <paragraph index="3853" node_type="writer" parent_index="435">//</paragraph>
 <paragraph index="3854" node_type="writer" parent_index="435">// a primitive generic class two type parameters</paragraph>
 <paragraph index="3855" node_type="writer" parent_index="435">//</paragraph>
 <paragraph index="3856" node_type="writer" parent_index="435">primitive class HashMap &lt;K:Ordered, V&gt;</paragraph>
 <paragraph index="3858" node_type="writer" parent_index="435">feature</paragraph>
 <paragraph index="3859" node_type="writer" parent_index="435">    // feature definitions</paragraph>
 <paragraph index="3860" node_type="writer" parent_index="435">The following example shows a generic class Interval&lt;T:Ordered&gt;, which is a class Interval with one formal parameter T constrained to be of type Ordered or any descendant.</paragraph>
 <object index="3861" name="awb_generic_class" object_type="section"/>
 <paragraph index="3862" node_type="writer" parent_index="3861"> </paragraph>
 <paragraph index="3863" node_type="writer" parent_index="3861">Figure 20. BMM class - generic class</paragraph>
 <paragraph index="3865" node_type="writer" parent_index="435">7.4. Range-Constrained Classes</paragraph>
 <paragraph index="3866" node_type="writer" parent_index="435">The value range of any defined type is by default open, meaning that its instances may take any value allowed by the type definition. For primitive types such as String and Integer, this means that any String or Integer value is a valid instance of their respective types. For complex types, instances are composed of hierarchies of values which are similarly unconstrained with respect to their types.</paragraph>
 <paragraph index="3867" node_type="writer" parent_index="435">A useful derived form of any concrete type definition (i.e. instance of BMM_EFFECTIVE_TYPE in a model) is one that constrains the legal values of its instances to a particular set of values. The Pascal language provided a well-known precedent, 'sub-range types' that could restrict primitive type value ranges. BMM supports two kinds of range constraint: enumeration and 'value sets'. The additional meta-classes are shown below.</paragraph>
 <object index="3868" name="core_range_constrained" object_type="section"/>
 <paragraph index="3869" node_type="writer" parent_index="3868"> </paragraph>
 <paragraph index="3870" node_type="writer" parent_index="3868">Figure 21. bmm.core.range_constrained Package - Constrained-range Meta-Types, including Enumeration</paragraph>
 <paragraph index="3872" node_type="writer" parent_index="435">7.4.1. Enumerated Types</paragraph>
 <paragraph index="3873" node_type="writer" parent_index="435">In modern programming languages, the enumerated type is the most common kind of range constraint mechanism. In Java for example, an enumeration is a finite set of labels each associated with a singleton value object - either automatically assigned integers, or else programmatically associated instances of any other kind. Enumerated types are supported in BMM via the BMM_ENUMERATION meta-type and descendants.</paragraph>
 <paragraph index="3874" node_type="writer" parent_index="435">An enumerated type could in theory be based on any BMM defined type, i.e. any simple or generic type, since instances of either could be constrained. BMM makes the simplification that an enumerated type can only be based on a BMM simple type, which means that in the defined model, an enumeration of a closed generic type Gen&lt;T_subst&gt; is achieved by first defining a simple type based on the closed generic type via inheritance, e.g. a type Gen_T_subst that inherits from Gen&lt;T_subst&gt; can be used as the ancestor of a BMM enumeration type.</paragraph>
 <paragraph index="3875" node_type="writer" parent_index="435">For this reason, the BMM_ENUMERATION meta-type is defined as a descendant of BMM_SIMPLE_CLASS, and may have only one ancestor. The value enumeration is represented via a set of enumeration labels (item_names) and constant values (item_values), the latter of which must be of the type represented in the concrete model by the instance of the ancestor class.</paragraph>
 <paragraph index="3876" node_type="writer" parent_index="435">Since String and Integer valued enumerations are by far the most common in real models, two descendant classes BMM_ENUMERATION_STRING and BMM_ENUMERATION_INTEGER are provided, which fix the values and types to String and Integer respectively.</paragraph>
 <paragraph index="3877" node_type="writer" parent_index="435">The following diagram shows the BMM instance structure corresponding to an attribute declaration lifecycle: TaskLifecycle in a class Order.</paragraph>
 <object index="3878" name="bmm_structure_enumeration" object_type="section"/>
 <paragraph index="3879" node_type="writer" parent_index="3878"> </paragraph>
 <paragraph index="3880" node_type="writer" parent_index="3878">Figure 22. Integer-based Enumeration Type</paragraph>
 <paragraph index="3882" node_type="writer" parent_index="435">The following shows the same class in an abstract syntax.</paragraph>
 <paragraph index="3883" node_type="writer" parent_index="435">// an Integer-based enumeration</paragraph>
 <paragraph index="3884" node_type="writer" parent_index="435">enumeration class TASK_LIFECYCLE</paragraph>
 <paragraph index="3886" node_type="writer" parent_index="435">feature -- Enumeration Literals</paragraph>
 <paragraph index="3888" node_type="writer" parent_index="435">    planned   = 0;</paragraph>
 <paragraph index="3889" node_type="writer" parent_index="435">    available = 1;</paragraph>
 <paragraph index="3890" node_type="writer" parent_index="435">    cancelled = 2;</paragraph>
 <paragraph index="3891" node_type="writer" parent_index="435">    aborted   = 3;</paragraph>
 <paragraph index="3892" node_type="writer" parent_index="435">    abandoned = 4;</paragraph>
 <paragraph index="3893" node_type="writer" parent_index="435">    underway  = 5;</paragraph>
 <paragraph index="3894" node_type="writer" parent_index="435">    suspended = 6;</paragraph>
 <paragraph index="3895" node_type="writer" parent_index="435">    resumed   = 7;</paragraph>
 <paragraph index="3896" node_type="writer" parent_index="435">    completed = 8;</paragraph>
 <paragraph index="3897" node_type="writer" parent_index="435">The following screenshot shows how this enumeration class appears within a BMM model.</paragraph>
 <object index="3898" name="awb_enumeration" object_type="section"/>
 <paragraph index="3899" node_type="writer" parent_index="3898"> </paragraph>
 <paragraph index="3900" node_type="writer" parent_index="3898">Figure 23. Enumeration Example</paragraph>
 <paragraph index="3902" node_type="writer" parent_index="435">The following shows another enumeration class, this time based on the String type.</paragraph>
 <paragraph index="3903" node_type="writer" parent_index="435">// a String-based enumeration</paragraph>
 <paragraph index="3904" node_type="writer" parent_index="435">enumeration class ContractStatus</paragraph>
 <paragraph index="3906" node_type="writer" parent_index="435">feature -- Enumeration Literals</paragraph>
 <paragraph index="3907" node_type="writer" parent_index="435">    initial   = &quot;Initial&quot;;</paragraph>
 <paragraph index="3908" node_type="writer" parent_index="435">    cancelled = &quot;Cancelled&quot;;</paragraph>
 <paragraph index="3909" node_type="writer" parent_index="435">    active    = &quot;Active&quot;;</paragraph>
 <paragraph index="3910" node_type="writer" parent_index="435">    completed = &quot;Completed&quot;;</paragraph>
 <paragraph index="3911" node_type="writer" parent_index="435">The types String and Integer are assumed to be defined via primitive classes of the same names.</paragraph>
 <paragraph index="3912" node_type="writer" parent_index="435">7.4.2. Value-set Types</paragraph>
 <paragraph index="3913" node_type="writer" parent_index="435">Another form of range constraint that occurs in many models is the use of 'coded terms' that represent codes from e.g. ISO or IANA value sets such as ISO 639 (languages) and IANA media types. These are particularly prevalent in type systems used in the biosciences where object models routinely include attributes of a Coded Term type that refer to terminologies such as SNOMED CT, WHO ICD10 etc. In such models, it is typical to want to define an attribute being not just of a Coded Term type, but also limited to a particular terminology (such as a coded attribute representing 'language'), or even a specific 'value set' from such a terminology.</paragraph>
 <paragraph index="3914" node_type="writer" parent_index="435">The same kind of constraint may be applied to any kind of model type, for example a type representing Medication may be constrained to be instantiated only as instances defined by a medications database. This kind of constraint is known here as a value set, following the common usage in the biomedical sciences, and is supported in a different way than enumerations. The latter is a common programming concept which always involves a dedicated type representing the enumeration. Since the required value-sets are represented explicitly in the model but in an external database or other resource, the constraint is limited to a reference to the relevant resource, and is applied directly to the use of a type within a feature definition, rather than requiring the definition of a new type.</paragraph>
 <paragraph index="3915" node_type="writer" parent_index="435">Accordingly, BMM provides the attribute value_constraint: BMM_VALUE_SET_SPEC defined on BMM_MODEL_TYPE. The BMM_VALUE_SET_SPEC meta-type contains two String attributes resource_id and value_set_id which may be used to define a resource (equivalently a namespace) and an identifier of a value set within that resource. BMM does not impose any particular format or resolution algorithm on these identifiers - it is assumed that they can be correctly defined and used within the context of the concrete model usage.</paragraph>
 <paragraph index="3916" node_type="writer" parent_index="435">Consequently, an attribute within a standard concrete model such as language: CodedTerm could now be expressed notionally as language: CodedTerm &lt;&lt;iso::639-*&gt;&gt; or language: CodedTerm &lt;&lt;iso::languages&gt;&gt;. The construction within the &lt;&lt;&gt;&gt; is parsed into two pieces around the :: separator, which are then used to populate the BMM_VALUE_SET_SPEC for a type.</paragraph>
 <paragraph index="3917" node_type="writer" parent_index="435">The following diagram shows the meta-model structure corresponding to an attribute declaration language: CodedText whose instances are constrained to be from a value-set iso_639-2 within the resource namespace iso.</paragraph>
 <object index="3918" name="bmm_structure_value_set" object_type="section"/>
 <paragraph index="3919" node_type="writer" parent_index="3918"> </paragraph>
 <paragraph index="3920" node_type="writer" parent_index="3918">Figure 24. Value-set Constrained Type</paragraph>
 <paragraph index="3922" node_type="writer" parent_index="435">The following shows a possible abstract syntax value-set type definition.</paragraph>
 <paragraph index="3923" node_type="writer" parent_index="435">// a Value-set type</paragraph>
 <paragraph index="3924" node_type="writer" parent_index="435">class Document</paragraph>
 <paragraph index="3926" node_type="writer" parent_index="435">feature</paragraph>
 <paragraph index="3927" node_type="writer" parent_index="435">    property language: CodedText &lt;&lt;&quot;iso::iso_639-2&quot;&gt;&gt; [1];</paragraph>
 <paragraph index="3928" node_type="writer" parent_index="435">7.5. Class Qualifiers</paragraph>
 <paragraph index="3929" node_type="writer" parent_index="435">The following sub-sections describe qualifiers that may be used on any class definition to achieve a specific status within the model system. BMM qualifiers are designed to map to typical features in programming languages.</paragraph>
 <paragraph index="3930" node_type="writer" parent_index="435">7.5.1. Abstract Classes</paragraph>
 <paragraph index="3931" node_type="writer" parent_index="435">Any class definition in a BMM model may be marked as 'abstract', to indicate that it cannot be directly instantiated. This qualifier generally maps to the concept of abstract classes in most OOPLs. It may be specified in an abstract syntax as follows.</paragraph>
 <paragraph index="3932" node_type="writer" parent_index="435">abstract class ENTRY</paragraph>
 <paragraph index="3934" node_type="writer" parent_index="435">feature</paragraph>
 <paragraph index="3935" node_type="writer" parent_index="435">    // feature definitions</paragraph>
 <paragraph index="3936" node_type="writer" parent_index="435">7.5.2. Primitive Type Classes</paragraph>
 <paragraph index="3937" node_type="writer" parent_index="435">Class definitions within a BMM model may be marked as 'primitive', enabling them to be visualised and queried as a separate group without otherwise changing the semantics of the entity in the BMM meta-type system. This is normally done to distinguish 'built-in' types used by a model from the classes for which the model was created. An abstract syntax definition may look as follows:</paragraph>
 <paragraph index="3938" node_type="writer" parent_index="435">primitive class Integer</paragraph>
 <paragraph index="3940" node_type="writer" parent_index="435">feature</paragraph>
 <paragraph index="3941" node_type="writer" parent_index="435">    // feature definitions</paragraph>
 <paragraph index="3944" node_type="writer" parent_index="435">primitive class String</paragraph>
 <paragraph index="3946" node_type="writer" parent_index="435">feature</paragraph>
 <paragraph index="3947" node_type="writer" parent_index="435">    // feature definitions</paragraph>
 <paragraph index="3948" node_type="writer" parent_index="435">The following shows part of a BMM model in which a number of classes are classified as primitive (shown in light and dark grey).</paragraph>
 <object index="3949" name="awb_primitive_types" object_type="section"/>
 <paragraph index="3950" node_type="writer" parent_index="3949"> </paragraph>
 <paragraph index="3951" node_type="writer" parent_index="3949">Figure 25. Primitive classes</paragraph>
 <paragraph index="3953" node_type="writer" parent_index="435">Primitive classes are normal BMM classes, other than being marked primitive for convenience, and do not have different semantics.</paragraph>
 <paragraph index="3954" node_type="writer" parent_index="435">7.6. Class Invariants</paragraph>
 <paragraph index="3955" node_type="writer" parent_index="435">A class defined within a model may include invariants, i.e. assertions relating to its state that hold true before and after all public routine calls. Assertions are instances of the class BMM_ASSERTION, which is a tagged Boolean-valued Expression.</paragraph>
 <paragraph index="3956" node_type="writer" parent_index="435">The following shows classes with invariants.</paragraph>
 <paragraph index="3957" node_type="writer" parent_index="435">//</paragraph>
 <paragraph index="3958" node_type="writer" parent_index="435">// a class with simple invariants</paragraph>
 <paragraph index="3959" node_type="writer" parent_index="435">//</paragraph>
 <paragraph index="3960" node_type="writer" parent_index="435">class COMPOSITION</paragraph>
 <paragraph index="3962" node_type="writer" parent_index="435">feature</paragraph>
 <paragraph index="3963" node_type="writer" parent_index="435">    // feature definitions</paragraph>
 <paragraph index="3965" node_type="writer" parent_index="435">invariant</paragraph>
 <paragraph index="3966" node_type="writer" parent_index="435">    Is_archetype_root: is_archetype_root</paragraph>
 <paragraph index="3967" node_type="writer" parent_index="435">    Content_valid: content /= Void implies not content.is_empty</paragraph>
 <paragraph index="3970" node_type="writer" parent_index="435">//</paragraph>
 <paragraph index="3971" node_type="writer" parent_index="435">// a class with more complex invariants</paragraph>
 <paragraph index="3972" node_type="writer" parent_index="435">//</paragraph>
 <paragraph index="3973" node_type="writer" parent_index="435">class VERSIONED_COMPOSITION</paragraph>
 <paragraph index="3975" node_type="writer" parent_index="435">feature</paragraph>
 <paragraph index="3976" node_type="writer" parent_index="435">    // feature definitions</paragraph>
 <paragraph index="3978" node_type="writer" parent_index="435">invariant</paragraph>
 <paragraph index="3979" node_type="writer" parent_index="435">    Archetype_node_id_valid: all_versions.for_all (</paragraph>
 <paragraph index="3980" node_type="writer" parent_index="435">        agent (v: VERSION) {</paragraph>
 <paragraph index="3981" node_type="writer" parent_index="435">            v.archetype_node_id.is_equal (all_versions.first.archetype_node_id);</paragraph>
 <paragraph index="3982" node_type="writer" parent_index="435">        }</paragraph>
 <paragraph index="3983" node_type="writer" parent_index="435">    )</paragraph>
 <paragraph index="3985" node_type="writer" parent_index="435">    Persistent_validity: all_versions.for_all (</paragraph>
 <paragraph index="3986" node_type="writer" parent_index="435">        agent (v: VERSION) {</paragraph>
 <paragraph index="3987" node_type="writer" parent_index="435">            v.is_persistent = all_versions.first.data.is_persistent;</paragraph>
 <paragraph index="3988" node_type="writer" parent_index="435">        }</paragraph>
 <paragraph index="3989" node_type="writer" parent_index="435">    )</paragraph>
 <paragraph index="3990" node_type="writer" parent_index="435">7.7. Inheritance</paragraph>
 <paragraph index="3991" node_type="writer" parent_index="435">Inheritance in BMM is a relation between a class and one or more types, rather than classes, as in many class-based formalisms. This is primarily to allow classes to be based on specific generic types, rather than just the 'open' type represented by the underlying classes. Multiple inheritance is permitted, with same-named features from different types being treated as clashes needing resolution. See Section 13.1 for a detailed description.</paragraph>
 <paragraph index="3992" node_type="writer" parent_index="435">7.8. Model Theoretic Questions</paragraph>
 <paragraph index="3993" node_type="writer" parent_index="435">The class meta-model as defined here entails certain choices that have consequences, including:</paragraph>
 <paragraph index="3994" node_type="writer" parent_index="435">All Enumeration types are based on literal values (i.e. not only names), which may be of any concrete type, including constructed types.</paragraph>
 <paragraph index="3995" node_type="writer" parent_index="435">7.9. Class Definitions</paragraph>
 <paragraph index="3996" node_type="writer" parent_index="435">7.9.1. BMM_CLASS Class</paragraph>
 <object index="3997" name="Table39" object_type="table"/>
 <paragraph index="3999" node_type="writer" parent_index="3997">Class</paragraph>
 <paragraph index="4002" node_type="writer" parent_index="3997">BMM_CLASS (abstract)</paragraph>
 <paragraph index="4005" node_type="writer" parent_index="3997">Description</paragraph>
 <paragraph index="4008" node_type="writer" parent_index="3997">Meta-type corresponding a class definition in an object model. Inheritance is specified by the ancestors attribute, which contains a list of types rather than classes. Inheritance is thus understood in BMM as a stated relationship between classes. The equivalent relationship between types is conformance.</paragraph>
 <object index="4009" name="Table40" object_type="table"/>
 <paragraph index="4011" node_type="writer" parent_index="4009">Note</paragraph>
 <paragraph index="4014" node_type="writer" parent_index="4009">unlike UML, the name is just the root name, even if the class is generic. Use type_name() to obtain the qualified type name. </paragraph>
 <paragraph index="4020" node_type="writer" parent_index="3997">Inherit</paragraph>
 <paragraph index="4023" node_type="writer" parent_index="3997">BMM_MODULE</paragraph>
 <paragraph index="4026" node_type="writer" parent_index="3997">Attributes</paragraph>
 <paragraph index="4029" node_type="writer" parent_index="3997">Signature</paragraph>
 <paragraph index="4032" node_type="writer" parent_index="3997">Meaning</paragraph>
 <paragraph index="4035" node_type="writer" parent_index="3997">0..1</paragraph>
 <paragraph index="4038" node_type="writer" parent_index="3997">ancestors: Hash&lt;String,BMM_MODEL_TYPE&gt;</paragraph>
 <paragraph index="4041" node_type="writer" parent_index="3997">List of immediate inheritance parents.</paragraph>
 <paragraph index="4044" node_type="writer" parent_index="3997">1..1</paragraph>
 <paragraph index="4047" node_type="writer" parent_index="3997">package: BMM_PACKAGE</paragraph>
 <paragraph index="4050" node_type="writer" parent_index="3997">Package this class belongs to.</paragraph>
 <paragraph index="4053" node_type="writer" parent_index="3997">0..1</paragraph>
 <paragraph index="4056" node_type="writer" parent_index="3997">properties: Hash&lt;String,BMM_PROPERTY&gt;</paragraph>
 <paragraph index="4059" node_type="writer" parent_index="3997">Properties defined in this class (subset of features).</paragraph>
 <paragraph index="4062" node_type="writer" parent_index="3997">1..1</paragraph>
 <paragraph index="4065" node_type="writer" parent_index="3997">source_schema_id: String</paragraph>
 <paragraph index="4068" node_type="writer" parent_index="3997">Reference to original source schema defining this class. Useful for UI tools to determine which original schema file to open for a given class for manual editing.</paragraph>
 <paragraph index="4071" node_type="writer" parent_index="3997">0..1</paragraph>
 <paragraph index="4074" node_type="writer" parent_index="3997">immediate_descendants: List&lt;BMM_CLASS&gt;</paragraph>
 <paragraph index="4077" node_type="writer" parent_index="3997">List of computed references to base classes of immediate inheritance descendants, derived when members of ancestors are attached at creation time.</paragraph>
 <paragraph index="4080" node_type="writer" parent_index="3997">1..1</paragraph>
 <paragraph index="4083" node_type="writer" parent_index="3997">is_override: Boolean</paragraph>
 <paragraph index="4086" node_type="writer" parent_index="3997">True if this definition overrides a class of the same name in an included schema.</paragraph>
 <paragraph index="4089" node_type="writer" parent_index="3997">0..1</paragraph>
 <paragraph index="4092" node_type="writer" parent_index="3997">static_properties: Hash&lt;String,BMM_STATIC&gt;</paragraph>
 <paragraph index="4095" node_type="writer" parent_index="3997">Static properties defined in this class (subset of features).</paragraph>
 <paragraph index="4098" node_type="writer" parent_index="3997">0..1</paragraph>
 <paragraph index="4101" node_type="writer" parent_index="3997">functions: Hash&lt;String,BMM_FUNCTION&gt;</paragraph>
 <paragraph index="4104" node_type="writer" parent_index="3997">Functions defined in this class (subset of features).</paragraph>
 <paragraph index="4107" node_type="writer" parent_index="3997">0..1</paragraph>
 <paragraph index="4110" node_type="writer" parent_index="3997">procedures: Hash&lt;String,BMM_PROCEDURE&gt;</paragraph>
 <paragraph index="4113" node_type="writer" parent_index="3997">Procedures defined in this class (subset of features).</paragraph>
 <paragraph index="4116" node_type="writer" parent_index="3997">0..1</paragraph>
 <paragraph index="4119" node_type="writer" parent_index="3997">is_primitive: Boolean
{default = false}</paragraph>
 <paragraph index="4122" node_type="writer" parent_index="3997">True if this class represents a type considered to be primitive in the type system, i.e. any typically built-in or standard library type such as String, Date, Hash&lt;K,V&gt; etc.</paragraph>
 <paragraph index="4125" node_type="writer" parent_index="3997">0..1</paragraph>
 <paragraph index="4128" node_type="writer" parent_index="3997">is_abstract: Boolean
{default = false}</paragraph>
 <paragraph index="4131" node_type="writer" parent_index="3997">True if this class is marked as abstract, i.e. direct instances cannot be created from its direct type.</paragraph>
 <paragraph index="4134" node_type="writer" parent_index="3997">0..1</paragraph>
 <paragraph index="4137" node_type="writer" parent_index="3997">invariants: List&lt;BMM_ASSERTION&gt;</paragraph>
 <paragraph index="4143" node_type="writer" parent_index="3997">0..1</paragraph>
 <paragraph index="4146" node_type="writer" parent_index="3997">creators: Hash&lt;String,BMM_PROCEDURE&gt;</paragraph>
 <paragraph index="4149" node_type="writer" parent_index="3997">Subset of procedures that may be used to initialise a new instance of an object, and whose execution will guarantee that class invariants are satisfied.</paragraph>
 <paragraph index="4152" node_type="writer" parent_index="3997">0..1</paragraph>
 <paragraph index="4155" node_type="writer" parent_index="3997">converters: Hash&lt;String,BMM_PROCEDURE&gt;</paragraph>
 <paragraph index="4158" node_type="writer" parent_index="3997">Subset of creators that create a new instance from a single argument of another type.</paragraph>
 <paragraph index="4161" node_type="writer" parent_index="3997">0..1
(redefined)</paragraph>
 <paragraph index="4164" node_type="writer" parent_index="3997">features: List&lt;BMM_FEATURE&gt;</paragraph>
 <paragraph index="4167" node_type="writer" parent_index="3997">Features of this module.</paragraph>
 <paragraph index="4170" node_type="writer" parent_index="3997">Functions</paragraph>
 <paragraph index="4173" node_type="writer" parent_index="3997">Signature</paragraph>
 <paragraph index="4176" node_type="writer" parent_index="3997">Meaning</paragraph>
 <paragraph index="4179" node_type="writer" parent_index="3997">1..1
(abstract)</paragraph>
 <paragraph index="4182" node_type="writer" parent_index="3997">type (): BMM_MODEL_TYPE</paragraph>
 <paragraph index="4185" node_type="writer" parent_index="3997">Generate a type object that represents the type for which this class is the definer.</paragraph>
 <paragraph index="4188" node_type="writer" parent_index="3997">0..1</paragraph>
 <paragraph index="4191" node_type="writer" parent_index="3997">all_ancestors (): List&lt;String&gt;</paragraph>
 <paragraph index="4194" node_type="writer" parent_index="3997">List of all inheritance parent class names, recursively.</paragraph>
 <paragraph index="4197" node_type="writer" parent_index="3997">0..1</paragraph>
 <paragraph index="4200" node_type="writer" parent_index="3997">all_descendants (): List&lt;String&gt;</paragraph>
 <paragraph index="4203" node_type="writer" parent_index="3997">Compute all descendants by following immediate_descendants.</paragraph>
 <paragraph index="4206" node_type="writer" parent_index="3997">0..1</paragraph>
 <paragraph index="4209" node_type="writer" parent_index="3997">suppliers (): List&lt;String&gt;</paragraph>
 <paragraph index="4212" node_type="writer" parent_index="3997">List of names of immediate supplier classes, including concrete generic parameters, concrete descendants of abstract statically defined types, and inherited suppliers. (Where generics are unconstrained, no class name is added, since logically it would be Any and this can always be assumed anyway). This list includes primitive types.</paragraph>
 <paragraph index="4215" node_type="writer" parent_index="3997">0..1</paragraph>
 <paragraph index="4218" node_type="writer" parent_index="3997">suppliers_non_primitive (): List&lt;String&gt;</paragraph>
 <paragraph index="4221" node_type="writer" parent_index="3997">Same as suppliers minus primitive types, as defined in input schema.</paragraph>
 <paragraph index="4224" node_type="writer" parent_index="3997">0..1</paragraph>
 <paragraph index="4227" node_type="writer" parent_index="3997">supplier_closure (): List&lt;String&gt;</paragraph>
 <paragraph index="4230" node_type="writer" parent_index="3997">List of names of all classes in full supplier closure, including concrete generic parameters; (where generics are unconstrained, no class name is added, since logically it would be Any and this can always be assumed anyway). This list includes primitive types.</paragraph>
 <paragraph index="4233" node_type="writer" parent_index="3997">1..1</paragraph>
 <paragraph index="4236" node_type="writer" parent_index="3997">package_path (): String</paragraph>
 <paragraph index="4239" node_type="writer" parent_index="3997">Fully qualified package name, of form: package.package.</paragraph>
 <paragraph index="4242" node_type="writer" parent_index="3997">1..1</paragraph>
 <paragraph index="4245" node_type="writer" parent_index="3997">class_path (): String</paragraph>
 <paragraph index="4248" node_type="writer" parent_index="3997">Fully qualified class name, of form: package.package.CLASS with package path in lower-case and class in original case.</paragraph>
 <paragraph index="4251" node_type="writer" parent_index="3997">1..1</paragraph>
 <paragraph index="4254" node_type="writer" parent_index="3997">is_primitive (): Boolean</paragraph>
 <paragraph index="4257" node_type="writer" parent_index="3997">True if this class is designated a primitive type within the overall type system of the schema. Set from schema.</paragraph>
 <paragraph index="4260" node_type="writer" parent_index="3997">1..1</paragraph>
 <paragraph index="4263" node_type="writer" parent_index="3997">is_abstract (): Boolean</paragraph>
 <paragraph index="4266" node_type="writer" parent_index="3997">True if this class is abstract in its model. Value provided from an underlying data property set at creation or construction time.</paragraph>
 <paragraph index="4269" node_type="writer" parent_index="3997">0..1</paragraph>
 <paragraph index="4272" node_type="writer" parent_index="3997">features ()</paragraph>
 <paragraph index="4275" node_type="writer" parent_index="3997">List of all feature definitions introduced in this class.</paragraph>
 <paragraph index="4278" node_type="writer" parent_index="3997">0..1</paragraph>
 <paragraph index="4281" node_type="writer" parent_index="3997">flat_features ()</paragraph>
 <paragraph index="4284" node_type="writer" parent_index="3997">Consolidated list of all feature definitions from this class and all inheritance ancestors.</paragraph>
 <paragraph index="4287" node_type="writer" parent_index="3997">0..1</paragraph>
 <paragraph index="4290" node_type="writer" parent_index="3997">flat_properties (): List&lt;BMM_PROPERTY&gt;</paragraph>
 <paragraph index="4293" node_type="writer" parent_index="3997">List of all properties due to current and ancestor classes, keyed by property name.</paragraph>
 <paragraph index="4296" node_type="writer" parent_index="3997">Invariants</paragraph>
 <paragraph index="4299" node_type="writer" parent_index="3997">Inv_constructors: for_all p in creators : procedures.has(p)</paragraph>
 <paragraph index="4305" node_type="writer" parent_index="3997">Inv_converters: for_all p in converters : creators.has(p) and p.arity() = 1</paragraph>
 <paragraph index="4308" node_type="writer" parent_index="435">7.9.2. BMM_SIMPLE_CLASS Class</paragraph>
 <object index="4309" name="Table41" object_type="table"/>
 <paragraph index="4311" node_type="writer" parent_index="4309">Class</paragraph>
 <paragraph index="4314" node_type="writer" parent_index="4309">BMM_SIMPLE_CLASS</paragraph>
 <paragraph index="4317" node_type="writer" parent_index="4309">Description</paragraph>
 <paragraph index="4320" node_type="writer" parent_index="4309">Definition of a simple class, i.e. a class that has no generic parameters and is 1:1 with the type it generates.</paragraph>
 <paragraph index="4323" node_type="writer" parent_index="4309">Inherit</paragraph>
 <paragraph index="4326" node_type="writer" parent_index="4309">BMM_CLASS</paragraph>
 <paragraph index="4329" node_type="writer" parent_index="4309">Functions</paragraph>
 <paragraph index="4332" node_type="writer" parent_index="4309">Signature</paragraph>
 <paragraph index="4335" node_type="writer" parent_index="4309">Meaning</paragraph>
 <paragraph index="4338" node_type="writer" parent_index="4309">1..1
(effected)</paragraph>
 <paragraph index="4341" node_type="writer" parent_index="4309">type (): BMM_SIMPLE_TYPE</paragraph>
 <paragraph index="4344" node_type="writer" parent_index="4309">Generate a type object that represents the type of this class. Can only be an instance of BMM_SIMPLE_TYPE or a descendant.</paragraph>
 <paragraph index="4347" node_type="writer" parent_index="435">7.9.3. BMM_GENERIC_CLASS Class</paragraph>
 <object index="4348" name="Table42" object_type="table"/>
 <paragraph index="4350" node_type="writer" parent_index="4348">Class</paragraph>
 <paragraph index="4353" node_type="writer" parent_index="4348">BMM_GENERIC_CLASS</paragraph>
 <paragraph index="4356" node_type="writer" parent_index="4348">Description</paragraph>
 <paragraph index="4359" node_type="writer" parent_index="4348">Definition of a generic class in an object model.</paragraph>
 <paragraph index="4362" node_type="writer" parent_index="4348">Inherit</paragraph>
 <paragraph index="4365" node_type="writer" parent_index="4348">BMM_CLASS</paragraph>
 <paragraph index="4368" node_type="writer" parent_index="4348">Attributes</paragraph>
 <paragraph index="4371" node_type="writer" parent_index="4348">Signature</paragraph>
 <paragraph index="4374" node_type="writer" parent_index="4348">Meaning</paragraph>
 <paragraph index="4377" node_type="writer" parent_index="4348">1..1</paragraph>
 <paragraph index="4380" node_type="writer" parent_index="4348">generic_parameters: Hash&lt;String,BMM_PARAMETER_TYPE&gt;</paragraph>
 <paragraph index="4383" node_type="writer" parent_index="4348">List of formal generic parameters, keyed by name. These are defined either directly on this class or by the inclusion of an ancestor class which is generic.</paragraph>
 <paragraph index="4386" node_type="writer" parent_index="4348">Functions</paragraph>
 <paragraph index="4389" node_type="writer" parent_index="4348">Signature</paragraph>
 <paragraph index="4392" node_type="writer" parent_index="4348">Meaning</paragraph>
 <paragraph index="4395" node_type="writer" parent_index="4348">0..1
(redefined)</paragraph>
 <paragraph index="4398" node_type="writer" parent_index="4348">suppliers (): List&lt;String&gt;</paragraph>
 <paragraph index="4401" node_type="writer" parent_index="4348">Add suppliers from generic parameters.</paragraph>
 <paragraph index="4404" node_type="writer" parent_index="4348">1..1
(effected)</paragraph>
 <paragraph index="4407" node_type="writer" parent_index="4348">type (): BMM_GENERIC_TYPE</paragraph>
 <paragraph index="4410" node_type="writer" parent_index="4348">Generate a fully open BMM_GENERIC_TYPE instance that corresponds to this class definition</paragraph>
 <paragraph index="4413" node_type="writer" parent_index="4348">1..1</paragraph>
 <paragraph index="4416" node_type="writer" parent_index="4348">generic_parameter_conformance_type (
a_name: String[1]
): String</paragraph>
 <paragraph index="4419" node_type="writer" parent_index="4348">For a generic class, type to which generic parameter a_name conforms e.g. if this class is Interval &lt;T:Comparable&gt; then the Result will be the single type Comparable. For an unconstrained type T, the Result will be Any.</paragraph>
 <paragraph index="4422" node_type="writer" parent_index="435">7.9.4. BMM_ENUMERATION Class</paragraph>
 <object index="4423" name="Table43" object_type="table"/>
 <paragraph index="4425" node_type="writer" parent_index="4423">Class</paragraph>
 <paragraph index="4428" node_type="writer" parent_index="4423">BMM_ENUMERATION</paragraph>
 <paragraph index="4431" node_type="writer" parent_index="4423">Description</paragraph>
 <paragraph index="4434" node_type="writer" parent_index="4423">Definition of an enumeration class, understood as a class whose value range is constrained extensionally, i.e. by an explicit enumeration of named singleton instances.</paragraph>
 <paragraph index="4435" node_type="writer" parent_index="4423">Only one inheritance ancestor is allowed in order to provide the base type to which the range constraint is applied.</paragraph>
 <paragraph index="4436" node_type="writer" parent_index="4423">The common notion of a set of literals with no explicit defined values is represented as the degenerate subtype BMM_ENUMERATION_INTEGER, whose values are 0, 1, …​</paragraph>
 <paragraph index="4439" node_type="writer" parent_index="4423">Inherit</paragraph>
 <paragraph index="4442" node_type="writer" parent_index="4423">BMM_SIMPLE_CLASS</paragraph>
 <paragraph index="4445" node_type="writer" parent_index="4423">Attributes</paragraph>
 <paragraph index="4448" node_type="writer" parent_index="4423">Signature</paragraph>
 <paragraph index="4451" node_type="writer" parent_index="4423">Meaning</paragraph>
 <paragraph index="4454" node_type="writer" parent_index="4423">0..1</paragraph>
 <paragraph index="4457" node_type="writer" parent_index="4423">item_names: List&lt;String&gt;</paragraph>
 <paragraph index="4460" node_type="writer" parent_index="4423">The list of names of the enumeration. If no values are supplied, the integer values 0, 1, 2, …​ are assumed.</paragraph>
 <paragraph index="4463" node_type="writer" parent_index="4423">0..1</paragraph>
 <paragraph index="4466" node_type="writer" parent_index="4423">item_values: List&lt;BMM_PRIMITIVE_VALUE&gt;</paragraph>
 <paragraph index="4469" node_type="writer" parent_index="4423">Optional list of specific values. Must be 1:1 with item_names list.</paragraph>
 <paragraph index="4472" node_type="writer" parent_index="4423">Functions</paragraph>
 <paragraph index="4475" node_type="writer" parent_index="4423">Signature</paragraph>
 <paragraph index="4478" node_type="writer" parent_index="4423">Meaning</paragraph>
 <paragraph index="4481" node_type="writer" parent_index="4423">1..1</paragraph>
 <paragraph index="4484" node_type="writer" parent_index="4423">name_map (): Hash&lt;String, String&gt;</paragraph>
 <paragraph index="4487" node_type="writer" parent_index="4423">Map of item_names to item_values (stringified).</paragraph>
 <paragraph index="4490" node_type="writer" parent_index="435">7.9.5. BMM_ENUMERATION_STRING Class</paragraph>
 <object index="4491" name="Table44" object_type="table"/>
 <paragraph index="4493" node_type="writer" parent_index="4491">Class</paragraph>
 <paragraph index="4496" node_type="writer" parent_index="4491">BMM_ENUMERATION_STRING</paragraph>
 <paragraph index="4499" node_type="writer" parent_index="4491">Description</paragraph>
 <paragraph index="4502" node_type="writer" parent_index="4491">String-based enumeration meta-type.</paragraph>
 <paragraph index="4505" node_type="writer" parent_index="4491">Inherit</paragraph>
 <paragraph index="4508" node_type="writer" parent_index="4491">BMM_ENUMERATION</paragraph>
 <paragraph index="4511" node_type="writer" parent_index="4491">Attributes</paragraph>
 <paragraph index="4514" node_type="writer" parent_index="4491">Signature</paragraph>
 <paragraph index="4517" node_type="writer" parent_index="4491">Meaning</paragraph>
 <paragraph index="4520" node_type="writer" parent_index="4491">0..1
(redefined)</paragraph>
 <paragraph index="4523" node_type="writer" parent_index="4491">item_values: List&lt;BMM_STRING_VALUE&gt;</paragraph>
 <paragraph index="4526" node_type="writer" parent_index="4491">Optional list of specific values. Must be 1:1 with item_names list.</paragraph>
 <paragraph index="4529" node_type="writer" parent_index="435">7.9.6. BMM_ENUMERATION_INTEGER Class</paragraph>
 <object index="4530" name="Table45" object_type="table"/>
 <paragraph index="4532" node_type="writer" parent_index="4530">Class</paragraph>
 <paragraph index="4535" node_type="writer" parent_index="4530">BMM_ENUMERATION_INTEGER</paragraph>
 <paragraph index="4538" node_type="writer" parent_index="4530">Description</paragraph>
 <paragraph index="4541" node_type="writer" parent_index="4530">Integer-based enumeration meta-type.</paragraph>
 <paragraph index="4544" node_type="writer" parent_index="4530">Inherit</paragraph>
 <paragraph index="4547" node_type="writer" parent_index="4530">BMM_ENUMERATION</paragraph>
 <paragraph index="4550" node_type="writer" parent_index="4530">Attributes</paragraph>
 <paragraph index="4553" node_type="writer" parent_index="4530">Signature</paragraph>
 <paragraph index="4556" node_type="writer" parent_index="4530">Meaning</paragraph>
 <paragraph index="4559" node_type="writer" parent_index="4530">0..1
(redefined)</paragraph>
 <paragraph index="4562" node_type="writer" parent_index="4530">item_values: List&lt;BMM_INTEGER_VALUE&gt;</paragraph>
 <paragraph index="4565" node_type="writer" parent_index="4530">Optional list of specific values. Must be 1:1 with item_names list.</paragraph>
 <paragraph index="4568" node_type="writer" parent_index="435">7.9.7. BMM_VALUE_SET_SPEC Class</paragraph>
 <object index="4569" name="Table46" object_type="table"/>
 <paragraph index="4571" node_type="writer" parent_index="4569">Class</paragraph>
 <paragraph index="4574" node_type="writer" parent_index="4569">BMM_VALUE_SET_SPEC</paragraph>
 <paragraph index="4577" node_type="writer" parent_index="4569">Description</paragraph>
 <paragraph index="4580" node_type="writer" parent_index="4569">Definition of a range-constrained class whose value range is defined by reference to a 'value set' within an external resource, e.g. a reference data service.</paragraph>
 <paragraph index="4583" node_type="writer" parent_index="4569">Attributes</paragraph>
 <paragraph index="4586" node_type="writer" parent_index="4569">Signature</paragraph>
 <paragraph index="4589" node_type="writer" parent_index="4569">Meaning</paragraph>
 <paragraph index="4592" node_type="writer" parent_index="4569">1..1</paragraph>
 <paragraph index="4595" node_type="writer" parent_index="4569">resource_id: String</paragraph>
 <paragraph index="4598" node_type="writer" parent_index="4569">Identifier of a resource (typically available as a service) that contains legal values of a specific type. This is typically a URI but need not be.</paragraph>
 <paragraph index="4601" node_type="writer" parent_index="4569">1..1</paragraph>
 <paragraph index="4604" node_type="writer" parent_index="4569">value_set_id: String</paragraph>
 <paragraph index="4607" node_type="writer" parent_index="4569">Identifier of a value set within the resource identified by resource_id, which specifies the set of legal values of a type. This might be a URI, but need not be.</paragraph>
 <paragraph index="4610" node_type="writer" parent_index="435">8. Class Features</paragraph>
 <paragraph index="4611" node_type="writer" parent_index="435">8.1. Overview</paragraph>
 <paragraph index="4612" node_type="writer" parent_index="435">Within the definition of each class in a BMM model are found the declarations of its features. Variables are declared within routines. Features and variables are kinds of formal elements, i.e. typed entities having a signature (BMM_FORMAL_ELEMENT). This section describes class features, their parts, and their semantics.</paragraph>
 <paragraph index="4613" node_type="writer" parent_index="435">8.1.1. Feature Taxonomy</paragraph>
 <paragraph index="4614" node_type="writer" parent_index="435">Features are understood in BMM as typed entities referenceable within a module context. Class features consist of the formal sub-parts of a class, namely:</paragraph>
 <paragraph index="4615" node_type="writer" parent_index="435">routines: procedures and functions;</paragraph>
 <paragraph index="4616" node_type="writer" parent_index="435">properties: mutable static definitions, described in detail in previous sections;</paragraph>
 <paragraph index="4617" node_type="writer" parent_index="435">constants: immutable static values.</paragraph>
 <paragraph index="4618" node_type="writer" parent_index="435">The taxonomy of feature declarations is shown below in the simplified view of the BMM feature meta-model.</paragraph>
 <object index="4619" name="feature-taxonomy" object_type="section"/>
 <paragraph index="4620" node_type="writer" parent_index="4619"> </paragraph>
 <paragraph index="4621" node_type="writer" parent_index="4619">Figure 26. Feature taxonomy</paragraph>
 <paragraph index="4623" node_type="writer" parent_index="435">8.1.2. Class Model</paragraph>
 <paragraph index="4624" node_type="writer" parent_index="435">The full feature meta-model is shown below.</paragraph>
 <object index="4625" name="core_feature" object_type="section"/>
 <paragraph index="4626" node_type="writer" parent_index="4625"> </paragraph>
 <paragraph index="4627" node_type="writer" parent_index="4625">Figure 27. base.bmm.core.feature package</paragraph>
 <paragraph index="4629" node_type="writer" parent_index="435">8.1.3. Feature Groups and Visibility</paragraph>
 <paragraph index="4630" node_type="writer" parent_index="435">Features are arranged within a class in feature groups, each represented by an instance of a meta-type BMM_FEATURE_GROUP, shown in the following UML view.</paragraph>
 <object index="4631" name="core_feature_group" object_type="section"/>
 <paragraph index="4632" node_type="writer" parent_index="4631"> </paragraph>
 <paragraph index="4633" node_type="writer" parent_index="4631">Figure 28. Feature Groups</paragraph>
 <paragraph index="4635" node_type="writer" parent_index="435">By default there is at least one feature group called &quot;feature&quot;. Feature groups may be given any name, and are usually used to group features on the basis of things like:</paragraph>
 <paragraph index="4636" node_type="writer" parent_index="435">meta-type, e.g. a group called &quot;rules&quot; limited to publicly visible functions only;</paragraph>
 <paragraph index="4637" node_type="writer" parent_index="435">logical feature type, e.g. commands, queries, factory methods etc.</paragraph>
 <paragraph index="4638" node_type="writer" parent_index="435">The primary purpose of feature groups is to represent specific meta-data that naturally applies to more than one feature in general, and is thus convenient to represent on a logical container rather than repeat individually. Feature group meta-data is recorded in the properties attribute. A feature group may also set default visibility for all features in the group.</paragraph>
 <paragraph index="4639" node_type="writer" parent_index="435">Selective visibility of features to external clients is expressed in the attributes BMM_FEATURE_GROUP.visibility with potential overrides achieved using BMM_FEATURE.visibility, i.e. at an individual feature level. Visibility is defined using sub-types of the abstract meta-class BMM_VISIBILITY.</paragraph>
 <paragraph index="4640" node_type="writer" parent_index="435">TBD: define visibility meta-model; probably need to support C++/Java approach and type-based.</paragraph>
 <paragraph index="4641" node_type="writer" parent_index="435">8.1.4. Differential and Flat Form</paragraph>
 <paragraph index="4642" node_type="writer" parent_index="435">In modelling or programming terms, the features defined on a particular class within a model constitute the features it introduces with respect to its inheritance parent(s). We can think of this list of features as the differential set. A 'top-level' class with no declared inheritance ancestor is considered to inherit by default from the Any class, and its feature set is relationally differential to the top class.</paragraph>
 <paragraph index="4643" node_type="writer" parent_index="435">In contrast, the effective set of features for an instance at runtime is the result of evaluating these lists of features down the inheritance hierarchy to obtain the flat set of features. The features properties and flat_properties defined on BMM_CLASS provide access to these two lists for any class.</paragraph>
 <paragraph index="4644" node_type="writer" parent_index="435">8.1.5. Signatures</paragraph>
 <paragraph index="4645" node_type="writer" parent_index="435">All features are formal computational entities, and therefore have formal signatures (described in Section 6.5.2), represented by BMM_FORMAL_ELEMENT.signature. A standard taxonomy of feature signature types is illustrated below, in which properties have signatures with no arguments (this is also true for argument-less functions), and procedures have the special built-in Status result type (BMM_STATUS_TYPE), following the meta-model of various functional languages, e.g. Haskell (in which procedure invocations return the special 'unit' type).</paragraph>
 <object index="4646" name="signature_taxonomy" object_type="section"/>
 <paragraph index="4647" node_type="writer" parent_index="4646"> </paragraph>
 <paragraph index="4648" node_type="writer" parent_index="4646">Figure 29. Signature taxonomy</paragraph>
 <paragraph index="4650" node_type="writer" parent_index="435">8.1.6. Synthesis due to Generic Parameter Substitution</paragraph>
 <paragraph index="4651" node_type="writer" parent_index="435">Due to the possibility of generating concrete types via substitution of concrete generic parameters for formal parameters of generic classes, new concrete types of features may routinely result anywhere in a fully computed in-memory BMM model. BMM allows such features to be synthesised with their resulting concrete types rather than their 'source-defined' open parameter types, and provides the Boolean flag is_synthesised_generic on BMM_FEATURE to mark any such synthesised feature. An example of the use of this is described below in Section 13.1.2.</paragraph>
 <paragraph index="4652" node_type="writer" parent_index="435">8.2. Properties</paragraph>
 <paragraph index="4653" node_type="writer" parent_index="435">Properties are features whose values are stored rather than computed on each reference, and are represented by the meta-type BMM_INSTANTIABLE_FEATURE. They are distinguished from routines by having no arguments (signature of degree zero).</paragraph>
 <paragraph index="4654" node_type="writer" parent_index="435">8.2.1. Static Properties</paragraph>
 <paragraph index="4655" node_type="writer" parent_index="435">Static properties are properties whose values are pre-defined by some means, and read-only during execution (is_nullable is False).</paragraph>
 <paragraph index="4656" node_type="writer" parent_index="435">8.2.1.1. Constants</paragraph>
 <paragraph index="4657" node_type="writer" parent_index="435">Constant class features (meta-type BMM_CONSTANT) correspond to classic constants in most computer languages, and are defined with a literal value.</paragraph>
 <paragraph index="4658" node_type="writer" parent_index="435">The following abstract syntax illustrates how constants may be defined in a BMM model.</paragraph>
 <paragraph index="4659" node_type="writer" parent_index="435">class BASIC_DEFINITIONS</paragraph>
 <paragraph index="4661" node_type="writer" parent_index="435">feature</paragraph>
 <paragraph index="4662" node_type="writer" parent_index="435">    //</paragraph>
 <paragraph index="4663" node_type="writer" parent_index="435">    // simple constants</paragraph>
 <paragraph index="4664" node_type="writer" parent_index="435">    //</paragraph>
 <paragraph index="4665" node_type="writer" parent_index="435">    constant CR: Character = '\015';</paragraph>
 <paragraph index="4666" node_type="writer" parent_index="435">    constant LF: Character = '\012';</paragraph>
 <paragraph index="4668" node_type="writer" parent_index="435">    //</paragraph>
 <paragraph index="4669" node_type="writer" parent_index="435">    // constant of complex type</paragraph>
 <paragraph index="4670" node_type="writer" parent_index="435">    // TODO: correct JSON (maybe YAML?) or other syntax</paragraph>
 <paragraph index="4671" node_type="writer" parent_index="435">    //</paragraph>
 <paragraph index="4672" node_type="writer" parent_index="435">    constant SafeSpeed: Interval&lt;Quantity&gt; = |0.0 km/h .. 60.0 km/h|;</paragraph>
 <paragraph index="4673" node_type="writer" parent_index="435">8.2.1.2. Singletons</paragraph>
 <paragraph index="4674" node_type="writer" parent_index="435">The other kind of static property is computed once during execution (meta-type BMM_SINGLETON) via an argumentless function-body. Like a value-based constant, it has the same value for all instances of the containing type, including descendant and generically derived types.</paragraph>
 <paragraph index="4675" node_type="writer" parent_index="435">The following illustrates how singletons may be defined in a BMM model.</paragraph>
 <paragraph index="4676" node_type="writer" parent_index="435">feature</paragraph>
 <paragraph index="4677" node_type="writer" parent_index="435">    //</paragraph>
 <paragraph index="4678" node_type="writer" parent_index="435">    // constant generated by a function call</paragraph>
 <paragraph index="4679" node_type="writer" parent_index="435">    //</paragraph>
 <paragraph index="4680" node_type="writer" parent_index="435">    singleton criticalPressure: ProxyVar&lt;Quantity&gt;</paragraph>
 <paragraph index="4681" node_type="writer" parent_index="435">        Result := {ProxyVar&lt;Quantity&gt;}({Quantity}(0.0, &quot;kPa&quot;), {Quantity}(150.0, &quot;kPa&quot;));</paragraph>
 <paragraph index="4682" node_type="writer" parent_index="435">8.2.2. Writable Properties</paragraph>
 <paragraph index="4683" node_type="writer" parent_index="435">Writable class properties are defined via the meta-class BMM_PROPERTY, and its subtypes which distinguish unitary properties (single-valued attributes in a class) from container properties (multiply-valued attributes).</paragraph>
 <paragraph index="4684" node_type="writer" parent_index="435">The BMM_PROPERTY meta-type defines semantics common to all properties, including is_composition, which indicates whether the property reference instantiates a part-of relationship or an association.</paragraph>
 <paragraph index="4685" node_type="writer" parent_index="435">8.2.2.1. Unitary versus Container Properties</paragraph>
 <paragraph index="4686" node_type="writer" parent_index="435">Single-valued properties in a BMM model are instances of the type BMM_UNITARY_PROPERTY, and have as their type the meta-type BMM_UNITARY_TYPE. Container properties are instances of the meta-type BMM_CONTAINER_PROPERTY, which adds the attribute cardinality, enabling the possible number of container elements to be constrained (this corresponds to the multiplicities used at the end of UML associations). The meta-type BMM_INDEXED_CONTAINER_PROPERTY adds the attribute index_type, enabling representation of indexed concrete container types such as Hash&lt;K,V&gt; etc.</paragraph>
 <paragraph index="4687" node_type="writer" parent_index="435">A typical example of properties of class is shown below, in which the flattened property view of a class OBSERVATION includes the inherited properties other_participations and links properties exemplifying the container property meta-type:</paragraph>
 <object index="4688" name="awb_class_properties" object_type="section"/>
 <paragraph index="4689" node_type="writer" parent_index="4688"> </paragraph>
 <paragraph index="4690" node_type="writer" parent_index="4688">Figure 30. BMM class - properties view</paragraph>
 <paragraph index="4692" node_type="writer" parent_index="435">The following illustrates how various kinds of properties may appear in a BMM model. The first two properties are associations, used to represent references to shared objects (including singletons), while the remainder are normal compositional sub-parts, i.e. owned sub-instances that will cease to exist when the parent object is destroyed. All of the properties are single-valued, other than other_participations, which is defined as a container property with cardinality [*] (i.e. 0..*) and 'set' semantics.</paragraph>
 <paragraph index="4693" node_type="writer" parent_index="435">abstract class ENTRY extend CARE_ENTRY</paragraph>
 <paragraph index="4695" node_type="writer" parent_index="435">feature -- Locale</paragraph>
 <paragraph index="4696" node_type="writer" parent_index="435">    association property language: CODE_PHRASE &lt;&lt;&quot;iso::iso_639-2&quot;&gt;&gt; [0..1];</paragraph>
 <paragraph index="4697" node_type="writer" parent_index="435">    association property encoding: CODE_PHRASE &lt;&lt;&quot;iana::character-sets&quot;&gt;&gt; [0..1];</paragraph>
 <paragraph index="4699" node_type="writer" parent_index="435">feature -- Access</paragraph>
 <paragraph index="4700" node_type="writer" parent_index="435">    composition property protocol: ITEM_STRUCTURE[1];</paragraph>
 <paragraph index="4701" node_type="writer" parent_index="435">    composition property guideline_id: OBJECT_REF[0..1];</paragraph>
 <paragraph index="4702" node_type="writer" parent_index="435">    composition property subject: PARTY_PROXY[0..1];</paragraph>
 <paragraph index="4703" node_type="writer" parent_index="435">    composition property other_participations: PARTICIPATION[*]{set};</paragraph>
 <paragraph index="4704" node_type="writer" parent_index="435">8.2.3. Semantic Level</paragraph>
 <paragraph index="4705" node_type="writer" parent_index="435">TBD: this BMM feature requires review</paragraph>
 <paragraph index="4706" node_type="writer" parent_index="435">Properties also include two other Boolean meta-data items, is_im_runtime and is_im_infrastructure, which can be used to classify property values in a model according to a 'semantic level', which roughly corresponds to the continuum from domain-specific to infrastructure. These may be individually set, or both may be False. The three meaningful value settings are as follows:</paragraph>
 <paragraph index="4707" node_type="writer" parent_index="435">both False: the value of the property is considered to be design-time constrainable;</paragraph>
 <paragraph index="4708" node_type="writer" parent_index="435">is IM runtime: True if the property value is only knowable at runtime, as is typically the case for identifiers, dates etc;</paragraph>
 <paragraph index="4709" node_type="writer" parent_index="435">is infrastructure: True if the property is not a user- or business-oriented property, but something required by software design, e.g instance identifier, meta-data etc.</paragraph>
 <paragraph index="4710" node_type="writer" parent_index="435">The above screenshot also includes properties have different settings of the is_im_runtime and is_im_infrastructure meta-data flags: property names in black are neither; those in grey are IM runtime (guideline_id, workflow_id), and those in light grey are infrastructure properties (language, encoding, uid, etc).</paragraph>
 <paragraph index="4711" node_type="writer" parent_index="435">8.3. Functions and Procedures</paragraph>
 <paragraph index="4712" node_type="writer" parent_index="435">Functions and procedures are kinds of routine, which are computational features of a class. The classes BMM_FUNCTION, BMM_PROCEDURE and BMM_ROUTINE respectively provide the meta-model for definitions of the two types of routine.</paragraph>
 <paragraph index="4713" node_type="writer" parent_index="435">The formal parameter definitions of both kinds of routines are represented by an ordered list of instances of the meta-class BMM_PARAMETER, which is defined as a kind of variable. A formal parameter may optionally have the read/write direction defined, which indicates whether the variable contains an input value, should only be written to, or both, i.e. read then written to. The is_nullable meta-attribute inherited from BMM_FEATURE indicates whether each parameter is mandatory or not.</paragraph>
 <paragraph index="4714" node_type="writer" parent_index="435">An additional feature of the meta-model for functions is the notion of operator, which supports the representation of a function call in a formal expression as an operator symbol with one or two operands, in the typical form found in programming languages and first order logics. The BMM approach considers an operator as an optional addition to any function of arity 1 or 2 that may reasonably be represented in an abstract syntax using operator syntax. Operators thus support the use of expressions like weight &gt; 90 to mean weight.gt (90), where weight is of type Real, and the function gt(other: Real) is defined.</paragraph>
 <paragraph index="4715" node_type="writer" parent_index="435">Any routine may have pre- and/or post-conditions defined for it, represented in BMM by BMM_ASSERTIONs populating the pre_conditions and post_conditions attributes of BMM_ROUINE. An Assertion is a tagged Boolean Expression.</paragraph>
 <paragraph index="4716" node_type="writer" parent_index="435">The following abstract syntax illustrates the various elements of function definitions.</paragraph>
 <paragraph index="4717" node_type="writer" parent_index="435">abstract class DV_AMOUNT</paragraph>
 <paragraph index="4718" node_type="writer" parent_index="435">    inherit</paragraph>
 <paragraph index="4719" node_type="writer" parent_index="435">        DV_QUANTIFIED</paragraph>
 <paragraph index="4721" node_type="writer" parent_index="435">feature -- Arithmetic Operations</paragraph>
 <paragraph index="4723" node_type="writer" parent_index="435">    function equal (other: DV_AMOUNT[1]): Boolean[1]</paragraph>
 <paragraph index="4724" node_type="writer" parent_index="435">        alias {infix '='};</paragraph>
 <paragraph index="4726" node_type="writer" parent_index="435">    function less_than (other: DV_AMOUNT[1]): Boolean[1]</paragraph>
 <paragraph index="4727" node_type="writer" parent_index="435">        alias {infix '&lt;'};</paragraph>
 <paragraph index="4729" node_type="writer" parent_index="435">feature -- Arithmetic Operations</paragraph>
 <paragraph index="4731" node_type="writer" parent_index="435">    function add (other: DV_AMOUNT[1]): DV_AMOUNT[1]</paragraph>
 <paragraph index="4732" node_type="writer" parent_index="435">        alias {infix '+'};</paragraph>
 <paragraph index="4734" node_type="writer" parent_index="435">    function subtract (other: DV_AMOUNT[1]): DV_AMOUNT[1]</paragraph>
 <paragraph index="4735" node_type="writer" parent_index="435">        alias {infix '-'};</paragraph>
 <paragraph index="4737" node_type="writer" parent_index="435">    function multiply (val: Real[1]): DV_AMOUNT[1]</paragraph>
 <paragraph index="4738" node_type="writer" parent_index="435">        alias {infix '*'};</paragraph>
 <paragraph index="4740" node_type="writer" parent_index="435">    function divide (val: Real[1]): DV_AMOUNT[1]</paragraph>
 <paragraph index="4741" node_type="writer" parent_index="435">        alias {infix '/', infix '÷'};</paragraph>
 <paragraph index="4742" node_type="writer" parent_index="435">8.3.1. Pre- and Post-conditions</paragraph>
 <paragraph index="4743" node_type="writer" parent_index="435">All BMM routine definitions may include pre- and/or post-conditions, with the semantics of Djikstra’s weakest pre-condition logic (Dijkstra (1976)), Object-Z (Smith (2000)) and the Eiffel language (Meyer (1997)).</paragraph>
 <paragraph index="4744" node_type="writer" parent_index="435">The essential semantics are as follows:</paragraph>
 <paragraph index="4745" node_type="writer" parent_index="435">pre-conditions specify truth conditions on public object state and/or parameters that must hold for the routine to execute correctly;</paragraph>
 <paragraph index="4746" node_type="writer" parent_index="435">if a pre-condition is not met at the moment of routine call, the client (caller) is at fault;</paragraph>
 <paragraph index="4747" node_type="writer" parent_index="435">post-conditions specify truth conditions on public object state and/or result (in the case of functions) that will hold at the end of routine execution;</paragraph>
 <paragraph index="4748" node_type="writer" parent_index="435">if a post-condition is not met at the moment of routine completion, the routine is at fault, i.e. contains bugs.</paragraph>
 <paragraph index="4749" node_type="writer" parent_index="435">The use of pre- and post-conditions is also known as design by contract (DbC), a term introduced by Meyer, and is widely used in general IT, particularly in specification languages such as OMG Interface Definition Language (IDL).</paragraph>
 <paragraph index="4750" node_type="writer" parent_index="435">The following shows how a routine contract may be specified in an abstract syntax.</paragraph>
 <paragraph index="4751" node_type="writer" parent_index="435">class I_EHR_SERVICE</paragraph>
 <paragraph index="4753" node_type="writer" parent_index="435">feature -- Creation</paragraph>
 <paragraph index="4755" node_type="writer" parent_index="435">    create_ehr_with_id (</paragraph>
 <paragraph index="4756" node_type="writer" parent_index="435">        an_ehr_id: UUID[1];</paragraph>
 <paragraph index="4757" node_type="writer" parent_index="435">        an_ehr_status: EHR_STATUS[0..1]</paragraph>
 <paragraph index="4758" node_type="writer" parent_index="435">    ): UUID[1]</paragraph>
 <paragraph index="4759" node_type="writer" parent_index="435">        pre_condition</paragraph>
 <paragraph index="4760" node_type="writer" parent_index="435">            No_duplicate: not has_ehr (an_ehr_id)</paragraph>
 <paragraph index="4761" node_type="writer" parent_index="435">        post_condition</paragraph>
 <paragraph index="4762" node_type="writer" parent_index="435">            Has_ehr: has_ehr (Result)</paragraph>
 <paragraph index="4763" node_type="writer" parent_index="435">8.3.2. Creators and Converters</paragraph>
 <paragraph index="4764" node_type="writer" parent_index="435">In common with may OOPLs, BMM classes may specify creators, i.e. instance-creating procedures, known as 'constructors' in some OOPLs. These are just a subset of all procedures known in BMM_CLASS.procedures that when executed will satisfy the class invariants. A further subset of the creators are single-argument converters which can initialise a new instance from an instance of another type. Converter routines are typically used to support type conversion in expressions, e.g. String to Date etc. These two subsets are formally defined as the creators and converters reference lists of procedures on BMM_CLASS, as shown in the following UML view.</paragraph>
 <object index="4765" name="core_class_creators" object_type="section"/>
 <paragraph index="4766" node_type="writer" parent_index="4765"> </paragraph>
 <paragraph index="4767" node_type="writer" parent_index="4765">Figure 31. Class creators and converters</paragraph>
 <paragraph index="4769" node_type="writer" parent_index="435">Creators and converters might be distinguished among other procedures in an abstract syntax as follows.</paragraph>
 <paragraph index="4770" node_type="writer" parent_index="435">class Date</paragraph>
 <paragraph index="4772" node_type="writer" parent_index="435">inherit</paragraph>
 <paragraph index="4773" node_type="writer" parent_index="435">    Temporal</paragraph>
 <paragraph index="4775" node_type="writer" parent_index="435">convert</paragraph>
 <paragraph index="4776" node_type="writer" parent_index="435">    create_from_string</paragraph>
 <paragraph index="4778" node_type="writer" parent_index="435">feature -- Creators</paragraph>
 <paragraph index="4780" node_type="writer" parent_index="435">    procedure create_from_string (a_date_str: String[1])</paragraph>
 <paragraph index="4782" node_type="writer" parent_index="435">    procedure create (a_day, a_month, a_year: Integer[1])</paragraph>
 <paragraph index="4784" node_type="writer" parent_index="435">feature -- Modification</paragraph>
 <paragraph index="4786" node_type="writer" parent_index="435">    procedure set_day (a_day: Integer[1])</paragraph>
 <paragraph index="4787" node_type="writer" parent_index="435">8.3.3. Routine Body</paragraph>
 <paragraph index="4788" node_type="writer" parent_index="435">BMM supports the definition of statements, i.e. implementation within a ROUTINE as well as 'external' routines, which are represented by an instance of the meta-class BMM_ROUTINE_EXTERNAL. These classes are shown in the following UML view.</paragraph>
 <object index="4789" name="core_feature_routine" object_type="section"/>
 <paragraph index="4790" node_type="writer" parent_index="4789"> </paragraph>
 <paragraph index="4791" node_type="writer" parent_index="4789">Figure 32. Routine body</paragraph>
 <paragraph index="4793" node_type="writer" parent_index="435">The meta-model of statements is described in detail in Section 12.</paragraph>
 <paragraph index="4794" node_type="writer" parent_index="435">8.4. Variables</paragraph>
 <paragraph index="4795" node_type="writer" parent_index="435">At the finest level of detail of a model definition are what are typically thought of as variables within a routine scope. These may be either writable (BMM_WRITABLE_VARIABLE) or read-only (BMM_READONlY_VARIABLE) variables.</paragraph>
 <paragraph index="4796" node_type="writer" parent_index="435">Writable variables include local variables (variables declared locally within a routine) and the special pre-defined variable Result, which is automatically available within any function. Read-only variables include parameters (declared in the arguments part of a routine declaration), and the special variable Self, which represents the current instance.</paragraph>
 <paragraph index="4797" node_type="writer" parent_index="435">8.5. Model Theoretic Questions</paragraph>
 <paragraph index="4798" node_type="writer" parent_index="435">The features meta-model as defined here entails certain choices that have consequences. One question is how to treat procedures. In a mathematical sense, procedures have no return type, and therefore should not be allowed within 'normal' expressions. However in a computational sense, a procedure call normally performs some state-changing action (for example, authenticating to a database), and it is potentially useful to obtain an execution status and use it in further logic. The choice made in BMM is to treat procedures as typed entities, with a result meta-type and concrete type of Status (represented by BMM_STATUS_TYPE). This is similar to the approach in various languages such as Haskell and Kotlin, which both have a 'unit' type for the same purpose. This approach allows procedures to fit within the typed framework without complicating the meta-model.</paragraph>
 <paragraph index="4799" node_type="writer" parent_index="435">Procedure calls are prevented from appearing in expressions by the expressions part of the meta-model, and can only appear on their own (the usual case) or in an assignment statement in which a result status value may be obtained from the Status object. This value may then be used in normal expressions, e.g. a case statement.</paragraph>
 <paragraph index="4800" node_type="writer" parent_index="435">8.6. Class Definitions</paragraph>
 <paragraph index="4801" node_type="writer" parent_index="435">8.6.1. BMM_FORMAL_ELEMENT Class</paragraph>
 <object index="4802" name="Table47" object_type="table"/>
 <paragraph index="4804" node_type="writer" parent_index="4802">Class</paragraph>
 <paragraph index="4807" node_type="writer" parent_index="4802">BMM_FORMAL_ELEMENT (abstract)</paragraph>
 <paragraph index="4810" node_type="writer" parent_index="4802">Description</paragraph>
 <paragraph index="4813" node_type="writer" parent_index="4802">A formal element having a name, type and a type-based signature.</paragraph>
 <paragraph index="4816" node_type="writer" parent_index="4802">Inherit</paragraph>
 <paragraph index="4819" node_type="writer" parent_index="4802">BMM_MODEL_ELEMENT</paragraph>
 <paragraph index="4822" node_type="writer" parent_index="4802">Attributes</paragraph>
 <paragraph index="4825" node_type="writer" parent_index="4802">Signature</paragraph>
 <paragraph index="4828" node_type="writer" parent_index="4802">Meaning</paragraph>
 <paragraph index="4831" node_type="writer" parent_index="4802">1..1</paragraph>
 <paragraph index="4834" node_type="writer" parent_index="4802">type: BMM_TYPE</paragraph>
 <paragraph index="4837" node_type="writer" parent_index="4802">Declared or inferred static type of the entity.</paragraph>
 <paragraph index="4840" node_type="writer" parent_index="4802">0..1</paragraph>
 <paragraph index="4843" node_type="writer" parent_index="4802">is_nullable: Boolean
{default = false}</paragraph>
 <paragraph index="4846" node_type="writer" parent_index="4802">True if this element can be null (Void) at execution time. May be interpreted as optionality in subtypes..</paragraph>
 <paragraph index="4849" node_type="writer" parent_index="4802">Functions</paragraph>
 <paragraph index="4852" node_type="writer" parent_index="4802">Signature</paragraph>
 <paragraph index="4855" node_type="writer" parent_index="4802">Meaning</paragraph>
 <paragraph index="4858" node_type="writer" parent_index="4802">1..1
(abstract)</paragraph>
 <paragraph index="4861" node_type="writer" parent_index="4802">signature (): BMM_SIGNATURE</paragraph>
 <paragraph index="4864" node_type="writer" parent_index="4802">Formal signature of this element, in the form:</paragraph>
 <paragraph index="4865" node_type="writer" parent_index="4802">name [arg1_name: T_arg1, …​][:T_value]</paragraph>
 <paragraph index="4866" node_type="writer" parent_index="4802">Specific implementations in descendants.</paragraph>
 <paragraph index="4869" node_type="writer" parent_index="4802">1..1</paragraph>
 <paragraph index="4872" node_type="writer" parent_index="4802">is_boolean (): Boolean

Post_result: Result = type().equal( {BMM_MODEL}.boolean_type_definition())</paragraph>
 <paragraph index="4875" node_type="writer" parent_index="4802">True if type is notionally Boolean (i.e. a BMM_SIMPLE_TYPE with type_name() = 'Boolean').</paragraph>
 <paragraph index="4878" node_type="writer" parent_index="435">8.6.2. BMM_FEATURE Class</paragraph>
 <object index="4879" name="Table48" object_type="table"/>
 <paragraph index="4881" node_type="writer" parent_index="4879">Class</paragraph>
 <paragraph index="4884" node_type="writer" parent_index="4879">BMM_FEATURE (abstract)</paragraph>
 <paragraph index="4887" node_type="writer" parent_index="4879">Description</paragraph>
 <paragraph index="4890" node_type="writer" parent_index="4879">A module-scoped formal element.</paragraph>
 <paragraph index="4893" node_type="writer" parent_index="4879">Inherit</paragraph>
 <paragraph index="4896" node_type="writer" parent_index="4879">BMM_FORMAL_ELEMENT</paragraph>
 <paragraph index="4899" node_type="writer" parent_index="4879">Attributes</paragraph>
 <paragraph index="4902" node_type="writer" parent_index="4879">Signature</paragraph>
 <paragraph index="4905" node_type="writer" parent_index="4879">Meaning</paragraph>
 <paragraph index="4908" node_type="writer" parent_index="4879">0..1</paragraph>
 <paragraph index="4911" node_type="writer" parent_index="4879">is_synthesised_generic: Boolean
{default = false}</paragraph>
 <paragraph index="4914" node_type="writer" parent_index="4879">True if this feature was synthesised due to generic substitution in an inherited type, or further constraining of a formal generic parameter.</paragraph>
 <paragraph index="4917" node_type="writer" parent_index="4879">0..1</paragraph>
 <paragraph index="4920" node_type="writer" parent_index="4879">feature_extensions: List&lt;BMM_FEATURE_EXTENSION&gt;</paragraph>
 <paragraph index="4923" node_type="writer" parent_index="4879">Extensions to feature-level meta-types.</paragraph>
 <paragraph index="4926" node_type="writer" parent_index="4879">1..1</paragraph>
 <paragraph index="4929" node_type="writer" parent_index="4879">group: BMM_FEATURE_GROUP</paragraph>
 <paragraph index="4932" node_type="writer" parent_index="4879">Group containing this feature.</paragraph>
 <paragraph index="4935" node_type="writer" parent_index="4879">1..1
(redefined)</paragraph>
 <paragraph index="4938" node_type="writer" parent_index="4879">scope: BMM_CLASS</paragraph>
 <paragraph index="4941" node_type="writer" parent_index="4879">Model element within which an element is declared.</paragraph>
 <paragraph index="4944" node_type="writer" parent_index="435">8.6.3. BMM_FEATURE_GROUP Class</paragraph>
 <object index="4945" name="Table49" object_type="table"/>
 <paragraph index="4947" node_type="writer" parent_index="4945">Class</paragraph>
 <paragraph index="4950" node_type="writer" parent_index="4945">BMM_FEATURE_GROUP</paragraph>
 <paragraph index="4953" node_type="writer" parent_index="4945">Description</paragraph>
 <paragraph index="4956" node_type="writer" parent_index="4945">A logical group of features, with a name and set of properties that applies to the group.</paragraph>
 <paragraph index="4959" node_type="writer" parent_index="4945">Attributes</paragraph>
 <paragraph index="4962" node_type="writer" parent_index="4945">Signature</paragraph>
 <paragraph index="4965" node_type="writer" parent_index="4945">Meaning</paragraph>
 <paragraph index="4968" node_type="writer" parent_index="4945">1..1</paragraph>
 <paragraph index="4971" node_type="writer" parent_index="4945">name: String
{default = &quot;feature&quot;}</paragraph>
 <paragraph index="4974" node_type="writer" parent_index="4945">Name of this feature group; defaults to 'feature'.</paragraph>
 <paragraph index="4977" node_type="writer" parent_index="4945">1..1</paragraph>
 <paragraph index="4980" node_type="writer" parent_index="4945">properties: Hash&lt;String, String&gt;</paragraph>
 <paragraph index="4983" node_type="writer" parent_index="4945">Set of properties of this group, represented as name/value pairs. These are understood to apply logically to all of the features contained within the group.</paragraph>
 <paragraph index="4986" node_type="writer" parent_index="4945">0..1</paragraph>
 <paragraph index="4989" node_type="writer" parent_index="4945">features: List&lt;BMM_FEATURE&gt;</paragraph>
 <paragraph index="4992" node_type="writer" parent_index="4945">Set of features in this group.</paragraph>
 <paragraph index="4995" node_type="writer" parent_index="4945">0..1</paragraph>
 <paragraph index="4998" node_type="writer" parent_index="4945">visibility: BMM_VISIBILITY</paragraph>
 <paragraph index="5001" node_type="writer" parent_index="4945">Optional visibility to apply to all features in this group.</paragraph>
 <paragraph index="5004" node_type="writer" parent_index="435">8.6.4. BMM_VISIBILITY Class</paragraph>
 <object index="5005" name="Table50" object_type="table"/>
 <paragraph index="5007" node_type="writer" parent_index="5005">Class</paragraph>
 <paragraph index="5010" node_type="writer" parent_index="5005">BMM_VISIBILITY (abstract)</paragraph>
 <paragraph index="5013" node_type="writer" parent_index="5005">Description</paragraph>
 <paragraph index="5016" node_type="writer" parent_index="5005">Abstract parent of visibility representation.</paragraph>
 <paragraph index="5017" node_type="writer" parent_index="5005">TODO: define schemes; probably need to support C++/Java scheme as well as better type-based schemes.</paragraph>
 <paragraph index="5020" node_type="writer" parent_index="435">8.6.5. BMM_INSTANTIABLE_FEATURE Class</paragraph>
 <object index="5021" name="Table51" object_type="table"/>
 <paragraph index="5023" node_type="writer" parent_index="5021">Class</paragraph>
 <paragraph index="5026" node_type="writer" parent_index="5021">BMM_INSTANTIABLE_FEATURE (abstract)</paragraph>
 <paragraph index="5029" node_type="writer" parent_index="5021">Description</paragraph>
 <paragraph index="5032" node_type="writer" parent_index="5021">Meta-type representing instantiable features, i.e. features that are created as value objects.</paragraph>
 <paragraph index="5035" node_type="writer" parent_index="5021">Inherit</paragraph>
 <paragraph index="5038" node_type="writer" parent_index="5021">BMM_FEATURE</paragraph>
 <paragraph index="5041" node_type="writer" parent_index="5021">Invariants</paragraph>
 <paragraph index="5044" node_type="writer" parent_index="5021">Inv_signature_no_args: signature().arguments = Void</paragraph>
 <paragraph index="5047" node_type="writer" parent_index="435">8.6.6. BMM_STATIC Class</paragraph>
 <object index="5048" name="Table52" object_type="table"/>
 <paragraph index="5050" node_type="writer" parent_index="5048">Class</paragraph>
 <paragraph index="5053" node_type="writer" parent_index="5048">BMM_STATIC (abstract)</paragraph>
 <paragraph index="5056" node_type="writer" parent_index="5048">Description</paragraph>
 <paragraph index="5059" node_type="writer" parent_index="5048">Meta-type for static (i.e. read-only) properties.</paragraph>
 <paragraph index="5062" node_type="writer" parent_index="5048">Inherit</paragraph>
 <paragraph index="5065" node_type="writer" parent_index="5048">BMM_INSTANTIABLE_FEATURE</paragraph>
 <paragraph index="5068" node_type="writer" parent_index="5048">Invariants</paragraph>
 <paragraph index="5071" node_type="writer" parent_index="5048">Inv_not_nullable: is_nullable = False</paragraph>
 <paragraph index="5074" node_type="writer" parent_index="435">8.6.7. BMM_CONSTANT Class</paragraph>
 <object index="5075" name="Table53" object_type="table"/>
 <paragraph index="5077" node_type="writer" parent_index="5075">Class</paragraph>
 <paragraph index="5080" node_type="writer" parent_index="5075">BMM_CONSTANT</paragraph>
 <paragraph index="5083" node_type="writer" parent_index="5075">Description</paragraph>
 <paragraph index="5086" node_type="writer" parent_index="5075">An immutable, static value-returning element scoped to a class. The value is the result of the evaluation of the generator, which may be as simple as a literal value, or may be any expression, including a function call.</paragraph>
 <paragraph index="5089" node_type="writer" parent_index="5075">Inherit</paragraph>
 <paragraph index="5092" node_type="writer" parent_index="5075">BMM_STATIC</paragraph>
 <paragraph index="5095" node_type="writer" parent_index="5075">Attributes</paragraph>
 <paragraph index="5098" node_type="writer" parent_index="5075">Signature</paragraph>
 <paragraph index="5101" node_type="writer" parent_index="5075">Meaning</paragraph>
 <paragraph index="5104" node_type="writer" parent_index="5075">1..1</paragraph>
 <paragraph index="5107" node_type="writer" parent_index="5075">generator: BMM_LITERAL_VALUE</paragraph>
 <paragraph index="5110" node_type="writer" parent_index="5075">Literal value of the constant.</paragraph>
 <paragraph index="5113" node_type="writer" parent_index="435">8.6.8. BMM_SINGLETON Class</paragraph>
 <object index="5114" name="Table54" object_type="table"/>
 <paragraph index="5116" node_type="writer" parent_index="5114">Class</paragraph>
 <paragraph index="5119" node_type="writer" parent_index="5114">BMM_SINGLETON</paragraph>
 <paragraph index="5122" node_type="writer" parent_index="5114">Description</paragraph>
 <paragraph index="5125" node_type="writer" parent_index="5114">Meta-type for static value properties computed once by a function invocation.</paragraph>
 <paragraph index="5128" node_type="writer" parent_index="5114">Inherit</paragraph>
 <paragraph index="5131" node_type="writer" parent_index="5114">BMM_STATIC</paragraph>
 <paragraph index="5134" node_type="writer" parent_index="5114">Attributes</paragraph>
 <paragraph index="5137" node_type="writer" parent_index="5114">Signature</paragraph>
 <paragraph index="5140" node_type="writer" parent_index="5114">Meaning</paragraph>
 <paragraph index="5143" node_type="writer" parent_index="5114">1..1</paragraph>
 <paragraph index="5146" node_type="writer" parent_index="5114">generator: BMM_ROUTINE_DEFINITION</paragraph>
 <paragraph index="5149" node_type="writer" parent_index="5114">Generator of the value of this static property.</paragraph>
 <paragraph index="5152" node_type="writer" parent_index="435">8.6.9. BMM_PROPERTY Class</paragraph>
 <object index="5153" name="Table55" object_type="table"/>
 <paragraph index="5155" node_type="writer" parent_index="5153">Class</paragraph>
 <paragraph index="5158" node_type="writer" parent_index="5153">BMM_PROPERTY (abstract)</paragraph>
 <paragraph index="5161" node_type="writer" parent_index="5153">Description</paragraph>
 <paragraph index="5164" node_type="writer" parent_index="5153">Meta-type of a writable property definition within a class definition of an object model. The is_composition attribute indicates whether the property has sub-part or an association semantics with respect to the owning class.</paragraph>
 <paragraph index="5167" node_type="writer" parent_index="5153">Inherit</paragraph>
 <paragraph index="5170" node_type="writer" parent_index="5153">BMM_INSTANTIABLE_FEATURE</paragraph>
 <paragraph index="5173" node_type="writer" parent_index="5153">Attributes</paragraph>
 <paragraph index="5176" node_type="writer" parent_index="5153">Signature</paragraph>
 <paragraph index="5179" node_type="writer" parent_index="5153">Meaning</paragraph>
 <paragraph index="5182" node_type="writer" parent_index="5153">0..1</paragraph>
 <paragraph index="5185" node_type="writer" parent_index="5153">is_im_runtime: Boolean
{default = false}</paragraph>
 <paragraph index="5188" node_type="writer" parent_index="5153">True if this property is marked with info model im_runtime property.</paragraph>
 <paragraph index="5191" node_type="writer" parent_index="5153">0..1</paragraph>
 <paragraph index="5194" node_type="writer" parent_index="5153">is_im_infrastructure: Boolean
{default = false}</paragraph>
 <paragraph index="5197" node_type="writer" parent_index="5153">True if this property was marked with info model im_infrastructure flag.</paragraph>
 <paragraph index="5200" node_type="writer" parent_index="5153">0..1</paragraph>
 <paragraph index="5203" node_type="writer" parent_index="5153">is_composition: Boolean
{default = false}</paragraph>
 <paragraph index="5206" node_type="writer" parent_index="5153">True if this property instance is a compositional sub-part of the owning class instance. Equivalent to 'composition' in UML associations (but missing from UML properties without associations) and also 'cascade-delete' semantics in ER schemas.</paragraph>
 <paragraph index="5209" node_type="writer" parent_index="5153">Functions</paragraph>
 <paragraph index="5212" node_type="writer" parent_index="5153">Signature</paragraph>
 <paragraph index="5215" node_type="writer" parent_index="5153">Meaning</paragraph>
 <paragraph index="5218" node_type="writer" parent_index="5153">1..1</paragraph>
 <paragraph index="5221" node_type="writer" parent_index="5153">existence (): Multiplicity_interval</paragraph>
 <paragraph index="5224" node_type="writer" parent_index="5153">Interval form of 0..1, 1..1 etc, derived from is_nullable.</paragraph>
 <paragraph index="5227" node_type="writer" parent_index="5153">1..1</paragraph>
 <paragraph index="5230" node_type="writer" parent_index="5153">display_name (): String</paragraph>
 <paragraph index="5233" node_type="writer" parent_index="5153">Name of this property to display in UI.</paragraph>
 <paragraph index="5236" node_type="writer" parent_index="435">8.6.10. BMM_UNITARY_PROPERTY Class</paragraph>
 <object index="5237" name="Table56" object_type="table"/>
 <paragraph index="5239" node_type="writer" parent_index="5237">Class</paragraph>
 <paragraph index="5242" node_type="writer" parent_index="5237">BMM_UNITARY_PROPERTY</paragraph>
 <paragraph index="5245" node_type="writer" parent_index="5237">Description</paragraph>
 <paragraph index="5248" node_type="writer" parent_index="5237">Meta-type of for properties of unitary type.</paragraph>
 <paragraph index="5251" node_type="writer" parent_index="5237">Inherit</paragraph>
 <paragraph index="5254" node_type="writer" parent_index="5237">BMM_PROPERTY</paragraph>
 <paragraph index="5257" node_type="writer" parent_index="5237">Attributes</paragraph>
 <paragraph index="5260" node_type="writer" parent_index="5237">Signature</paragraph>
 <paragraph index="5263" node_type="writer" parent_index="5237">Meaning</paragraph>
 <paragraph index="5266" node_type="writer" parent_index="5237">1..1
(redefined)</paragraph>
 <paragraph index="5269" node_type="writer" parent_index="5237">type: BMM_UNITARY_TYPE</paragraph>
 <paragraph index="5272" node_type="writer" parent_index="5237">Declared or inferred static type of the entity.</paragraph>
 <paragraph index="5275" node_type="writer" parent_index="435">8.6.11. BMM_CONTAINER_PROPERTY Class</paragraph>
 <object index="5276" name="Table57" object_type="table"/>
 <paragraph index="5278" node_type="writer" parent_index="5276">Class</paragraph>
 <paragraph index="5281" node_type="writer" parent_index="5276">BMM_CONTAINER_PROPERTY</paragraph>
 <paragraph index="5284" node_type="writer" parent_index="5276">Description</paragraph>
 <paragraph index="5287" node_type="writer" parent_index="5276">Meta-type of for properties of linear container type, such as List&lt;T&gt; etc.</paragraph>
 <paragraph index="5290" node_type="writer" parent_index="5276">Inherit</paragraph>
 <paragraph index="5293" node_type="writer" parent_index="5276">BMM_PROPERTY</paragraph>
 <paragraph index="5296" node_type="writer" parent_index="5276">Attributes</paragraph>
 <paragraph index="5299" node_type="writer" parent_index="5276">Signature</paragraph>
 <paragraph index="5302" node_type="writer" parent_index="5276">Meaning</paragraph>
 <paragraph index="5305" node_type="writer" parent_index="5276">0..1</paragraph>
 <paragraph index="5308" node_type="writer" parent_index="5276">cardinality: Multiplicity_interval</paragraph>
 <paragraph index="5311" node_type="writer" parent_index="5276">Cardinality of this container.</paragraph>
 <paragraph index="5314" node_type="writer" parent_index="5276">1..1
(redefined)</paragraph>
 <paragraph index="5317" node_type="writer" parent_index="5276">type: BMM_CONTAINER_TYPE</paragraph>
 <paragraph index="5320" node_type="writer" parent_index="5276">Declared or inferred static type of the entity.</paragraph>
 <paragraph index="5323" node_type="writer" parent_index="5276">Functions</paragraph>
 <paragraph index="5326" node_type="writer" parent_index="5276">Signature</paragraph>
 <paragraph index="5329" node_type="writer" parent_index="5276">Meaning</paragraph>
 <paragraph index="5332" node_type="writer" parent_index="5276">1..1
(redefined)</paragraph>
 <paragraph index="5335" node_type="writer" parent_index="5276">display_name (): String</paragraph>
 <paragraph index="5338" node_type="writer" parent_index="5276">Name of this property in form name: ContainerTypeName&lt;&gt;.</paragraph>
 <paragraph index="5341" node_type="writer" parent_index="435">8.6.12. BMM_INDEXED_CONTAINER_PROPERTY Class</paragraph>
 <object index="5342" name="Table58" object_type="table"/>
 <paragraph index="5344" node_type="writer" parent_index="5342">Class</paragraph>
 <paragraph index="5347" node_type="writer" parent_index="5342">BMM_INDEXED_CONTAINER_PROPERTY</paragraph>
 <paragraph index="5350" node_type="writer" parent_index="5342">Description</paragraph>
 <paragraph index="5353" node_type="writer" parent_index="5342">Meta-type of for properties of linear container type, such as Hash&lt;Index_type, T&gt; etc.</paragraph>
 <paragraph index="5356" node_type="writer" parent_index="5342">Inherit</paragraph>
 <paragraph index="5359" node_type="writer" parent_index="5342">BMM_CONTAINER_PROPERTY</paragraph>
 <paragraph index="5362" node_type="writer" parent_index="5342">Attributes</paragraph>
 <paragraph index="5365" node_type="writer" parent_index="5342">Signature</paragraph>
 <paragraph index="5368" node_type="writer" parent_index="5342">Meaning</paragraph>
 <paragraph index="5371" node_type="writer" parent_index="5342">1..1
(redefined)</paragraph>
 <paragraph index="5374" node_type="writer" parent_index="5342">type: BMM_INDEXED_CONTAINER_TYPE</paragraph>
 <paragraph index="5377" node_type="writer" parent_index="5342">Declared or inferred static type of the entity.</paragraph>
 <paragraph index="5380" node_type="writer" parent_index="5342">Functions</paragraph>
 <paragraph index="5383" node_type="writer" parent_index="5342">Signature</paragraph>
 <paragraph index="5386" node_type="writer" parent_index="5342">Meaning</paragraph>
 <paragraph index="5389" node_type="writer" parent_index="5342">1..1
(redefined)</paragraph>
 <paragraph index="5392" node_type="writer" parent_index="5342">display_name (): String</paragraph>
 <paragraph index="5395" node_type="writer" parent_index="5342">Name of this property in form name: ContainerTypeName&lt;IndexTypeName, …​&gt;.</paragraph>
 <paragraph index="5398" node_type="writer" parent_index="435">8.6.13. BMM_ROUTINE Class</paragraph>
 <object index="5399" name="Table59" object_type="table"/>
 <paragraph index="5401" node_type="writer" parent_index="5399">Class</paragraph>
 <paragraph index="5404" node_type="writer" parent_index="5399">BMM_ROUTINE (abstract)</paragraph>
 <paragraph index="5407" node_type="writer" parent_index="5399">Description</paragraph>
 <paragraph index="5410" node_type="writer" parent_index="5399">A feature defining a routine, scoped to a class.</paragraph>
 <paragraph index="5413" node_type="writer" parent_index="5399">Inherit</paragraph>
 <paragraph index="5416" node_type="writer" parent_index="5399">BMM_FEATURE</paragraph>
 <paragraph index="5419" node_type="writer" parent_index="5399">Attributes</paragraph>
 <paragraph index="5422" node_type="writer" parent_index="5399">Signature</paragraph>
 <paragraph index="5425" node_type="writer" parent_index="5399">Meaning</paragraph>
 <paragraph index="5428" node_type="writer" parent_index="5399">0..1</paragraph>
 <paragraph index="5431" node_type="writer" parent_index="5399">parameters: List&lt;BMM_PARAMETER&gt;</paragraph>
 <paragraph index="5434" node_type="writer" parent_index="5399">Formal parameters of the routine.</paragraph>
 <paragraph index="5437" node_type="writer" parent_index="5399">0..1</paragraph>
 <paragraph index="5440" node_type="writer" parent_index="5399">pre_conditions: List&lt;BMM_ASSERTION&gt;</paragraph>
 <paragraph index="5443" node_type="writer" parent_index="5399">Boolean conditions that must evaluate to True for the routine to execute correctly, May be used to generate exceptions if included in run-time build.</paragraph>
 <paragraph index="5444" node_type="writer" parent_index="5399">A False pre-condition implies an error in the passed parameters.</paragraph>
 <paragraph index="5447" node_type="writer" parent_index="5399">0..1</paragraph>
 <paragraph index="5450" node_type="writer" parent_index="5399">post_conditions: List&lt;BMM_ASSERTION&gt;</paragraph>
 <paragraph index="5453" node_type="writer" parent_index="5399">Boolean conditions that will evaluate to True if the routine executed correctly, May be used to generate exceptions if included in run-time build.</paragraph>
 <paragraph index="5454" node_type="writer" parent_index="5399">A False post-condition implies an error (i.e. bug) in routine code.</paragraph>
 <paragraph index="5457" node_type="writer" parent_index="5399">0..1</paragraph>
 <paragraph index="5460" node_type="writer" parent_index="5399">definition: BMM_ROUTINE_DEFINITION</paragraph>
 <paragraph index="5463" node_type="writer" parent_index="5399">Body of a routine, i.e. executable program.</paragraph>
 <paragraph index="5466" node_type="writer" parent_index="5399">Functions</paragraph>
 <paragraph index="5469" node_type="writer" parent_index="5399">Signature</paragraph>
 <paragraph index="5472" node_type="writer" parent_index="5399">Meaning</paragraph>
 <paragraph index="5475" node_type="writer" parent_index="5399">1..1</paragraph>
 <paragraph index="5478" node_type="writer" parent_index="5399">arity (): Integer</paragraph>
 <paragraph index="5481" node_type="writer" parent_index="5399">Return number of arguments of this routine.</paragraph>
 <paragraph index="5484" node_type="writer" parent_index="435">8.6.14. BMM_FUNCTION Class</paragraph>
 <object index="5485" name="Table60" object_type="table"/>
 <paragraph index="5487" node_type="writer" parent_index="5485">Class</paragraph>
 <paragraph index="5490" node_type="writer" parent_index="5485">BMM_FUNCTION</paragraph>
 <paragraph index="5493" node_type="writer" parent_index="5485">Description</paragraph>
 <paragraph index="5496" node_type="writer" parent_index="5485">A formal element with signature of the form: name ({arg:TArg}*):TResult. A function is a computed (rather than data) element, generally assumed to be non-state-changing.</paragraph>
 <paragraph index="5499" node_type="writer" parent_index="5485">Inherit</paragraph>
 <paragraph index="5502" node_type="writer" parent_index="5485">BMM_ROUTINE</paragraph>
 <paragraph index="5505" node_type="writer" parent_index="5485">Attributes</paragraph>
 <paragraph index="5508" node_type="writer" parent_index="5485">Signature</paragraph>
 <paragraph index="5511" node_type="writer" parent_index="5485">Meaning</paragraph>
 <paragraph index="5514" node_type="writer" parent_index="5485">0..1</paragraph>
 <paragraph index="5517" node_type="writer" parent_index="5485">operator_definition: BMM_OPERATOR</paragraph>
 <paragraph index="5520" node_type="writer" parent_index="5485">Optional details enabling a function to be represented as an operator in a syntactic representation.</paragraph>
 <paragraph index="5523" node_type="writer" parent_index="5485">1..1</paragraph>
 <paragraph index="5526" node_type="writer" parent_index="5485">result: BMM_RESULT</paragraph>
 <paragraph index="5529" node_type="writer" parent_index="5485">Automatically created Result variable, usable in body and post-condition.</paragraph>
 <paragraph index="5532" node_type="writer" parent_index="5485">Invariants</paragraph>
 <paragraph index="5535" node_type="writer" parent_index="5485">Operator_validity: operator_def /= Void implies arity in |1..2|</paragraph>
 <paragraph index="5541" node_type="writer" parent_index="5485">Inv_result_type: type = Result.type</paragraph>
 <paragraph index="5544" node_type="writer" parent_index="435">8.6.15. BMM_OPERATOR Class</paragraph>
 <object index="5545" name="Table61" object_type="table"/>
 <paragraph index="5547" node_type="writer" parent_index="5545">Class</paragraph>
 <paragraph index="5550" node_type="writer" parent_index="5545">BMM_OPERATOR</paragraph>
 <paragraph index="5553" node_type="writer" parent_index="5545">Description</paragraph>
 <paragraph index="5556" node_type="writer" parent_index="5545">Definition of a symbolic operator associated with a function.</paragraph>
 <paragraph index="5559" node_type="writer" parent_index="5545">Attributes</paragraph>
 <paragraph index="5562" node_type="writer" parent_index="5545">Signature</paragraph>
 <paragraph index="5565" node_type="writer" parent_index="5545">Meaning</paragraph>
 <paragraph index="5568" node_type="writer" parent_index="5545">1..1</paragraph>
 <paragraph index="5571" node_type="writer" parent_index="5545">position: BMM_OPERATOR_POSITION</paragraph>
 <paragraph index="5574" node_type="writer" parent_index="5545">Position of operator in syntactic representation.</paragraph>
 <paragraph index="5577" node_type="writer" parent_index="5545">1..1</paragraph>
 <paragraph index="5580" node_type="writer" parent_index="5545">symbols: List&lt;String&gt;</paragraph>
 <paragraph index="5583" node_type="writer" parent_index="5545">Set of String symbols that may be used to represent this operator in a textual representation of a BMM model.</paragraph>
 <paragraph index="5586" node_type="writer" parent_index="5545">1..1</paragraph>
 <paragraph index="5589" node_type="writer" parent_index="5545">name: String</paragraph>
 <paragraph index="5592" node_type="writer" parent_index="5545">Formal name of the operator, e.g. 'minus' etc.</paragraph>
 <paragraph index="5595" node_type="writer" parent_index="435">8.6.16. BMM_OPERATOR_POSITION Enumeration</paragraph>
 <object index="5596" name="Table62" object_type="table"/>
 <paragraph index="5598" node_type="writer" parent_index="5596">Enumeration</paragraph>
 <paragraph index="5601" node_type="writer" parent_index="5596">BMM_OPERATOR_POSITION</paragraph>
 <paragraph index="5604" node_type="writer" parent_index="5596">Description</paragraph>
 <paragraph index="5607" node_type="writer" parent_index="5596">Enumeration of possible position of operator in a syntactic representation for operators associated with 1- and 2- degree functions.</paragraph>
 <paragraph index="5610" node_type="writer" parent_index="5596">Attributes</paragraph>
 <paragraph index="5613" node_type="writer" parent_index="5596">Signature</paragraph>
 <paragraph index="5616" node_type="writer" parent_index="5596">Meaning</paragraph>
 <paragraph index="5622" node_type="writer" parent_index="5596">prefix</paragraph>
 <paragraph index="5625" node_type="writer" parent_index="5596">Prefix operator position: operator comes before operand.</paragraph>
 <paragraph index="5631" node_type="writer" parent_index="5596">infix</paragraph>
 <paragraph index="5634" node_type="writer" parent_index="5596">Infix operator position: operator comes between left and right operands.</paragraph>
 <paragraph index="5637" node_type="writer" parent_index="435">8.6.17. BMM_PROCEDURE Class</paragraph>
 <object index="5638" name="Table63" object_type="table"/>
 <paragraph index="5640" node_type="writer" parent_index="5638">Class</paragraph>
 <paragraph index="5643" node_type="writer" parent_index="5638">BMM_PROCEDURE</paragraph>
 <paragraph index="5646" node_type="writer" parent_index="5638">Description</paragraph>
 <paragraph index="5649" node_type="writer" parent_index="5638">A formal element with signature of the form: name ({arg:TArg}*):TStatus, where TStatus is the built-in type BMM_STATUS_TYPE.. A procedure is a computed (rather than data) element, generally assumed to be state-changing, and is usually called in the form name ({arg:TArg}*).</paragraph>
 <paragraph index="5652" node_type="writer" parent_index="5638">Inherit</paragraph>
 <paragraph index="5655" node_type="writer" parent_index="5638">BMM_ROUTINE</paragraph>
 <paragraph index="5658" node_type="writer" parent_index="5638">Attributes</paragraph>
 <paragraph index="5661" node_type="writer" parent_index="5638">Signature</paragraph>
 <paragraph index="5664" node_type="writer" parent_index="5638">Meaning</paragraph>
 <paragraph index="5667" node_type="writer" parent_index="5638">1..1
(redefined)</paragraph>
 <paragraph index="5670" node_type="writer" parent_index="5638">type: BMM_STATUS_TYPE</paragraph>
 <paragraph index="5673" node_type="writer" parent_index="5638">Declared or inferred static type of the entity.</paragraph>
 <paragraph index="5676" node_type="writer" parent_index="5638">Functions</paragraph>
 <paragraph index="5679" node_type="writer" parent_index="5638">Signature</paragraph>
 <paragraph index="5682" node_type="writer" parent_index="5638">Meaning</paragraph>
 <paragraph index="5685" node_type="writer" parent_index="5638">1..1
(effected)</paragraph>
 <paragraph index="5688" node_type="writer" parent_index="5638">signature (): BMM_PROCEDURE_TYPE</paragraph>
 <paragraph index="5691" node_type="writer" parent_index="5638">Formal signature of this element, in the form:</paragraph>
 <paragraph index="5692" node_type="writer" parent_index="5638">name [arg1_name: T_arg1, …​][:T_value]</paragraph>
 <paragraph index="5693" node_type="writer" parent_index="5638">Specific implementations in descendants.</paragraph>
 <paragraph index="5696" node_type="writer" parent_index="435">8.6.18. BMM_VARIABLE Class</paragraph>
 <object index="5697" name="Table64" object_type="table"/>
 <paragraph index="5699" node_type="writer" parent_index="5697">Class</paragraph>
 <paragraph index="5702" node_type="writer" parent_index="5697">BMM_VARIABLE (abstract)</paragraph>
 <paragraph index="5705" node_type="writer" parent_index="5697">Description</paragraph>
 <paragraph index="5708" node_type="writer" parent_index="5697">A routine-scoped formal element.</paragraph>
 <paragraph index="5711" node_type="writer" parent_index="5697">Inherit</paragraph>
 <paragraph index="5714" node_type="writer" parent_index="5697">BMM_FORMAL_ELEMENT</paragraph>
 <paragraph index="5717" node_type="writer" parent_index="5697">Attributes</paragraph>
 <paragraph index="5720" node_type="writer" parent_index="5697">Signature</paragraph>
 <paragraph index="5723" node_type="writer" parent_index="5697">Meaning</paragraph>
 <paragraph index="5726" node_type="writer" parent_index="5697">1..1
(redefined)</paragraph>
 <paragraph index="5729" node_type="writer" parent_index="5697">scope: BMM_ROUTINE</paragraph>
 <paragraph index="5732" node_type="writer" parent_index="5697">Routine within which variable is defined.</paragraph>
 <paragraph index="5735" node_type="writer" parent_index="435">8.6.19. BMM_WRITABLE_VARIABLE Class</paragraph>
 <object index="5736" name="Table65" object_type="table"/>
 <paragraph index="5738" node_type="writer" parent_index="5736">Class</paragraph>
 <paragraph index="5741" node_type="writer" parent_index="5736">BMM_WRITABLE_VARIABLE (abstract)</paragraph>
 <paragraph index="5744" node_type="writer" parent_index="5736">Description</paragraph>
 <paragraph index="5747" node_type="writer" parent_index="5736">Meta-type for writable variables, including the special variable Result.</paragraph>
 <paragraph index="5750" node_type="writer" parent_index="5736">Inherit</paragraph>
 <paragraph index="5753" node_type="writer" parent_index="5736">BMM_VARIABLE</paragraph>
 <paragraph index="5756" node_type="writer" parent_index="435">8.6.20. BMM_LOCAL Class</paragraph>
 <object index="5757" name="Table66" object_type="table"/>
 <paragraph index="5759" node_type="writer" parent_index="5757">Class</paragraph>
 <paragraph index="5762" node_type="writer" parent_index="5757">BMM_LOCAL</paragraph>
 <paragraph index="5765" node_type="writer" parent_index="5757">Description</paragraph>
 <paragraph index="5768" node_type="writer" parent_index="5757">A routine local variable (writable).</paragraph>
 <paragraph index="5771" node_type="writer" parent_index="5757">Inherit</paragraph>
 <paragraph index="5774" node_type="writer" parent_index="5757">BMM_WRITABLE_VARIABLE</paragraph>
 <paragraph index="5777" node_type="writer" parent_index="435">8.6.21. BMM_RESULT Class</paragraph>
 <object index="5778" name="Table67" object_type="table"/>
 <paragraph index="5780" node_type="writer" parent_index="5778">Class</paragraph>
 <paragraph index="5783" node_type="writer" parent_index="5778">BMM_RESULT</paragraph>
 <paragraph index="5786" node_type="writer" parent_index="5778">Description</paragraph>
 <paragraph index="5789" node_type="writer" parent_index="5778">Automatically declared variable representing result of a Function call (writable).</paragraph>
 <paragraph index="5792" node_type="writer" parent_index="5778">Inherit</paragraph>
 <paragraph index="5795" node_type="writer" parent_index="5778">BMM_WRITABLE_VARIABLE</paragraph>
 <paragraph index="5798" node_type="writer" parent_index="5778">Attributes</paragraph>
 <paragraph index="5801" node_type="writer" parent_index="5778">Signature</paragraph>
 <paragraph index="5804" node_type="writer" parent_index="5778">Meaning</paragraph>
 <paragraph index="5807" node_type="writer" parent_index="5778">1..1
(redefined)</paragraph>
 <paragraph index="5810" node_type="writer" parent_index="5778">name: String
{default = &quot;Result&quot;}</paragraph>
 <paragraph index="5813" node_type="writer" parent_index="5778">Name of this model element.</paragraph>
 <paragraph index="5816" node_type="writer" parent_index="435">8.6.22. BMM_READONLY_VARIABLE Class</paragraph>
 <object index="5817" name="Table68" object_type="table"/>
 <paragraph index="5819" node_type="writer" parent_index="5817">Class</paragraph>
 <paragraph index="5822" node_type="writer" parent_index="5817">BMM_READONLY_VARIABLE (abstract)</paragraph>
 <paragraph index="5825" node_type="writer" parent_index="5817">Description</paragraph>
 <paragraph index="5828" node_type="writer" parent_index="5817">Meta-type for writable variables, including routine parameters and the special variable Self.</paragraph>
 <paragraph index="5831" node_type="writer" parent_index="5817">Inherit</paragraph>
 <paragraph index="5834" node_type="writer" parent_index="5817">BMM_VARIABLE</paragraph>
 <paragraph index="5837" node_type="writer" parent_index="5817">Invariants</paragraph>
 <paragraph index="5840" node_type="writer" parent_index="5817">Inv_not_nullable: is_nullable = False</paragraph>
 <paragraph index="5843" node_type="writer" parent_index="435">8.6.23. BMM_SELF Class</paragraph>
 <object index="5844" name="Table69" object_type="table"/>
 <paragraph index="5846" node_type="writer" parent_index="5844">Class</paragraph>
 <paragraph index="5849" node_type="writer" parent_index="5844">BMM_SELF</paragraph>
 <paragraph index="5852" node_type="writer" parent_index="5844">Description</paragraph>
 <paragraph index="5855" node_type="writer" parent_index="5844">Meta-type for an automatically created variable referencing the current instance. Typically called 'self' or 'this' in programming languages. Read-only.</paragraph>
 <paragraph index="5858" node_type="writer" parent_index="5844">Inherit</paragraph>
 <paragraph index="5861" node_type="writer" parent_index="5844">BMM_READONLY_VARIABLE</paragraph>
 <paragraph index="5864" node_type="writer" parent_index="5844">Attributes</paragraph>
 <paragraph index="5867" node_type="writer" parent_index="5844">Signature</paragraph>
 <paragraph index="5870" node_type="writer" parent_index="5844">Meaning</paragraph>
 <paragraph index="5873" node_type="writer" parent_index="5844">1..1
(redefined)</paragraph>
 <paragraph index="5876" node_type="writer" parent_index="5844">name: String
{default = &quot;Self&quot;}</paragraph>
 <paragraph index="5879" node_type="writer" parent_index="5844">Name of this model element.</paragraph>
 <paragraph index="5882" node_type="writer" parent_index="435">8.6.24. BMM_PARAMETER Class</paragraph>
 <object index="5883" name="Table70" object_type="table"/>
 <paragraph index="5885" node_type="writer" parent_index="5883">Class</paragraph>
 <paragraph index="5888" node_type="writer" parent_index="5883">BMM_PARAMETER</paragraph>
 <paragraph index="5891" node_type="writer" parent_index="5883">Description</paragraph>
 <paragraph index="5894" node_type="writer" parent_index="5883">A routine parameter variable (read-only).</paragraph>
 <paragraph index="5897" node_type="writer" parent_index="5883">Inherit</paragraph>
 <paragraph index="5900" node_type="writer" parent_index="5883">BMM_READONLY_VARIABLE</paragraph>
 <paragraph index="5903" node_type="writer" parent_index="5883">Attributes</paragraph>
 <paragraph index="5906" node_type="writer" parent_index="5883">Signature</paragraph>
 <paragraph index="5909" node_type="writer" parent_index="5883">Meaning</paragraph>
 <paragraph index="5912" node_type="writer" parent_index="5883">0..1</paragraph>
 <paragraph index="5915" node_type="writer" parent_index="5883">direction: BMM_PARAMETER_DIRECTION</paragraph>
 <paragraph index="5918" node_type="writer" parent_index="5883">Optional read/write direction of the parameter. If none-supplied, the parameter is treated as in, i.e. readable.</paragraph>
 <paragraph index="5921" node_type="writer" parent_index="435">8.6.25. BMM_PARAMETER_DIRECTION Enumeration</paragraph>
 <object index="5922" name="Table71" object_type="table"/>
 <paragraph index="5924" node_type="writer" parent_index="5922">Enumeration</paragraph>
 <paragraph index="5927" node_type="writer" parent_index="5922">BMM_PARAMETER_DIRECTION</paragraph>
 <paragraph index="5930" node_type="writer" parent_index="5922">Description</paragraph>
 <paragraph index="5933" node_type="writer" parent_index="5922">Enumeration of parameter read/write direction values.</paragraph>
 <paragraph index="5936" node_type="writer" parent_index="5922">Attributes</paragraph>
 <paragraph index="5939" node_type="writer" parent_index="5922">Signature</paragraph>
 <paragraph index="5942" node_type="writer" parent_index="5922">Meaning</paragraph>
 <paragraph index="5948" node_type="writer" parent_index="5922">in</paragraph>
 <paragraph index="5951" node_type="writer" parent_index="5922">Parameter is an input parameter, and treated as readonly by the receiving routine.</paragraph>
 <paragraph index="5957" node_type="writer" parent_index="5922">out</paragraph>
 <paragraph index="5960" node_type="writer" parent_index="5922">Parameter is an output parameter, and treated as a reference to an entity writeable by the receiving routine.</paragraph>
 <paragraph index="5966" node_type="writer" parent_index="5922">in_out</paragraph>
 <paragraph index="5969" node_type="writer" parent_index="5922">Parameter is an input and output parameter, and treated as a reference to an entity readable and writeable by the receiving routine.</paragraph>
 <paragraph index="5972" node_type="writer" parent_index="435">8.6.26. BMM_ROUTINE_DEFINITION Class</paragraph>
 <object index="5973" name="Table72" object_type="table"/>
 <paragraph index="5975" node_type="writer" parent_index="5973">Class</paragraph>
 <paragraph index="5978" node_type="writer" parent_index="5973">BMM_ROUTINE_DEFINITION (abstract)</paragraph>
 <paragraph index="5981" node_type="writer" parent_index="5973">Description</paragraph>
 <paragraph index="5984" node_type="writer" parent_index="5973">Abstract ancestor of routine body meta-types.</paragraph>
 <paragraph index="5987" node_type="writer" parent_index="435">8.6.27. BMM_LOCAL_ROUTINE Class</paragraph>
 <object index="5988" name="Table73" object_type="table"/>
 <paragraph index="5990" node_type="writer" parent_index="5988">Class</paragraph>
 <paragraph index="5993" node_type="writer" parent_index="5988">BMM_LOCAL_ROUTINE</paragraph>
 <paragraph index="5996" node_type="writer" parent_index="5988">Description</paragraph>
 <paragraph index="5999" node_type="writer" parent_index="5988">Meta-type for locally declared routine body.</paragraph>
 <paragraph index="6002" node_type="writer" parent_index="5988">Inherit</paragraph>
 <paragraph index="6005" node_type="writer" parent_index="5988">BMM_ROUTINE_DEFINITION</paragraph>
 <paragraph index="6008" node_type="writer" parent_index="5988">Attributes</paragraph>
 <paragraph index="6011" node_type="writer" parent_index="5988">Signature</paragraph>
 <paragraph index="6014" node_type="writer" parent_index="5988">Meaning</paragraph>
 <paragraph index="6017" node_type="writer" parent_index="5988">0..1</paragraph>
 <paragraph index="6020" node_type="writer" parent_index="5988">locals: List&lt;BMM_LOCAL&gt;</paragraph>
 <paragraph index="6023" node_type="writer" parent_index="5988">Local variables of the routine, if there is a body defined.</paragraph>
 <paragraph index="6026" node_type="writer" parent_index="5988">1..1</paragraph>
 <paragraph index="6029" node_type="writer" parent_index="5988">body: BMM_STATEMENT_BLOCK</paragraph>
 <paragraph index="6032" node_type="writer" parent_index="5988">Body of routine declaration.</paragraph>
 <paragraph index="6035" node_type="writer" parent_index="435">8.6.28. BMM_EXTERNAL_ROUTINE Class</paragraph>
 <object index="6036" name="Table74" object_type="table"/>
 <paragraph index="6038" node_type="writer" parent_index="6036">Class</paragraph>
 <paragraph index="6041" node_type="writer" parent_index="6036">BMM_EXTERNAL_ROUTINE</paragraph>
 <paragraph index="6044" node_type="writer" parent_index="6036">Description</paragraph>
 <paragraph index="6047" node_type="writer" parent_index="6036">External routine meta-type, containing sufficient meta-data to enable a routine in an external library to be called.</paragraph>
 <paragraph index="6050" node_type="writer" parent_index="6036">Inherit</paragraph>
 <paragraph index="6053" node_type="writer" parent_index="6036">BMM_ROUTINE_DEFINITION</paragraph>
 <paragraph index="6056" node_type="writer" parent_index="6036">Attributes</paragraph>
 <paragraph index="6059" node_type="writer" parent_index="6036">Signature</paragraph>
 <paragraph index="6062" node_type="writer" parent_index="6036">Meaning</paragraph>
 <paragraph index="6065" node_type="writer" parent_index="6036">1..1</paragraph>
 <paragraph index="6068" node_type="writer" parent_index="6036">meta_data: Hash&lt;String, String&gt;</paragraph>
 <paragraph index="6071" node_type="writer" parent_index="6036">External call general meta-data, including target routine name, type mapping etc.</paragraph>
 <paragraph index="6074" node_type="writer" parent_index="6036">0..1</paragraph>
 <paragraph index="6077" node_type="writer" parent_index="6036">argument_mapping: Hash&lt;String, String&gt;</paragraph>
 <paragraph index="6080" node_type="writer" parent_index="6036">Optional argument-mapping meta-data.</paragraph>
 <paragraph index="6083" node_type="writer" parent_index="435">9. Literal Values</paragraph>
 <paragraph index="6084" node_type="writer" parent_index="435">9.1. Overview</paragraph>
 <paragraph index="6085" node_type="writer" parent_index="435">With a typical formal model, there is a need for formal representation of literal values. This is needed to support constant declarations, 'default values' (a UML concept), enumeration literals and literal routine calls (see next section). In BMM, all such values have as their meta-type the type BMM_LITERAL_VALUE&lt;T&gt; or a descendant. The type hierarchy mostly mimicks parts of the BMM_TYPE meta-type hierarchy, allowing for literal values of any of the meta-types in that part of the model. The UML model is shown below.</paragraph>
 <object index="6086" name="core_literal_value" object_type="section"/>
 <paragraph index="6087" node_type="writer" parent_index="6086"> </paragraph>
 <paragraph index="6088" node_type="writer" parent_index="6086">Figure 33. base.bmm.core.literal_value package - Literal Values</paragraph>
 <paragraph index="6090" node_type="writer" parent_index="435">9.2. General Model</paragraph>
 <paragraph index="6091" node_type="writer" parent_index="435">When a BMM model is instantiated in its in-memory form, e.g. in a BMM modelling tool, any literal values in the model such as constant values (e.g. Real Pi = 3.1415926), default values (e.g. Person.name: String = &quot;(unknown)&quot;) etc are instances of 'two types':</paragraph>
 <paragraph index="6092" node_type="writer" parent_index="435">their declared types withing the model, e.g. Real, String, Observation;</paragraph>
 <paragraph index="6093" node_type="writer" parent_index="435">the meta-type BMM_LITERAL_VALUE&lt;T&gt; (or a matching descendant if there is one), which is instantiated to represent the value object within the model.</paragraph>
 <paragraph index="6094" node_type="writer" parent_index="435">The value of any such instance is represented by the value_literal field within its BMM_LITERAL_VALUE object. This is assumed to carry a serialised form of the value expressed in a syntax known to the model processing environment within which the BMM model is being used. This may be a programming language syntax, JSON, or any other serialisable format, and is specified by BMM_LITERAL_VALUE.syntax.</paragraph>
 <paragraph index="6095" node_type="writer" parent_index="435">9.3. Container Literals</paragraph>
 <paragraph index="6096" node_type="writer" parent_index="435">Literals representing Lists or Sets of values of objects of other types have as their BMM meta-type BMM_CONTAINER_VALUE&lt;T&gt;. For example, if the serialised value [&quot;Feyerabend&quot;, &quot;Lakatos&quot;, &quot;Popper&quot;] (which happens to be a JSON Array of Strings) were parsed as a List&lt;String&gt; instance, its meta-type would be a BMM_CONTAINER_VALUE instance whose value_literal was the same string, assuming JSON were used as the syntax, and whose type will be BMM_CONTAINER_TYPE. Similarly a syntax that supported literal Sets using braces, e.g. {&quot;Feyerabend&quot;, &quot;Lakatos&quot;, &quot;Popper&quot;} may be parsed to a Set&lt;String&gt; instance, with the same meta-type as for the List.</paragraph>
 <paragraph index="6097" node_type="writer" parent_index="435">In a similar way, a Hash table (aka 'map', 'dictionary' etc) with a formal type of Hash&lt;K, V&gt; has as its meta-type BMM_INDEXED_CONTAINER_VALUE.</paragraph>
 <paragraph index="6098" node_type="writer" parent_index="435">9.4. Literal Tuples</paragraph>
 <paragraph index="6099" node_type="writer" parent_index="435">Literal tuples may be expressed in BMM, but are not instances of BMM_LITERAL_VALUE; instead they are instances (at the meta level) of EL_TUPLE, an expression-related meta-type. This is a consequence of the fact that Tuple is considered a BMM built-in meta-type rather than a model-provided type, and also that a Tuple instance may contain items of any meta-type, not just literal values. Tuple instances are used in BMM expressions and described in Section 10.4.</paragraph>
 <paragraph index="6100" node_type="writer" parent_index="435">9.5. Type Extensions</paragraph>
 <paragraph index="6101" node_type="writer" parent_index="435">If it were desired to create a full set of 'native' types for BMM, in the way supplied for UML in the UML Standard Profile, specific descendants would be added to the meta-type classes BMM_SIMPLE_TYPE and BMM_GENERIC_TYPE, as well as BMM_LITERAL_VALUE, which would allow such instances to be directly representable in the internal BMM type system. This would still need to be ultimately mapped to the types actually available in any language in which BMM is implemented.</paragraph>
 <paragraph index="6102" node_type="writer" parent_index="435">9.6. Class Definitions</paragraph>
 <paragraph index="6103" node_type="writer" parent_index="435">9.6.1. BMM_LITERAL_VALUE Class</paragraph>
 <object index="6104" name="Table75" object_type="table"/>
 <paragraph index="6106" node_type="writer" parent_index="6104">Class</paragraph>
 <paragraph index="6109" node_type="writer" parent_index="6104">BMM_LITERAL_VALUE&lt;T&gt; (abstract)</paragraph>
 <paragraph index="6112" node_type="writer" parent_index="6104">Description</paragraph>
 <paragraph index="6115" node_type="writer" parent_index="6104">Meta-type for literal instance values declared in a model. Instance values may be inline values of primitive types in the usual fashion or complex objects in syntax form, e.g. JSON.</paragraph>
 <paragraph index="6118" node_type="writer" parent_index="6104">Attributes</paragraph>
 <paragraph index="6121" node_type="writer" parent_index="6104">Signature</paragraph>
 <paragraph index="6124" node_type="writer" parent_index="6104">Meaning</paragraph>
 <paragraph index="6127" node_type="writer" parent_index="6104">1..1</paragraph>
 <paragraph index="6130" node_type="writer" parent_index="6104">value_literal: String</paragraph>
 <paragraph index="6133" node_type="writer" parent_index="6104">A serial representation of the value.</paragraph>
 <paragraph index="6136" node_type="writer" parent_index="6104">0..1</paragraph>
 <paragraph index="6139" node_type="writer" parent_index="6104">value: Any</paragraph>
 <paragraph index="6142" node_type="writer" parent_index="6104">A native representation of the value, possibly derived by deserialising value_literal.</paragraph>
 <paragraph index="6145" node_type="writer" parent_index="6104">0..1</paragraph>
 <paragraph index="6148" node_type="writer" parent_index="6104">syntax: String</paragraph>
 <paragraph index="6151" node_type="writer" parent_index="6104">Optional specification of formalism of the value_literal attribute for complex values. Value may be any of json | json5 | yawl | xml | odin | rdf or another value agreed by the user community. If not set, json is assumed.</paragraph>
 <paragraph index="6154" node_type="writer" parent_index="6104">1..1</paragraph>
 <paragraph index="6157" node_type="writer" parent_index="6104">type: T</paragraph>
 <paragraph index="6160" node_type="writer" parent_index="6104">Concrete type of this literal.</paragraph>
 <paragraph index="6163" node_type="writer" parent_index="435">9.6.2. BMM_CONTAINER_VALUE Class</paragraph>
 <object index="6164" name="Table76" object_type="table"/>
 <paragraph index="6166" node_type="writer" parent_index="6164">Class</paragraph>
 <paragraph index="6169" node_type="writer" parent_index="6164">BMM_CONTAINER_VALUE</paragraph>
 <paragraph index="6172" node_type="writer" parent_index="6164">Description</paragraph>
 <paragraph index="6175" node_type="writer" parent_index="6164">Meta-type for literals whose concrete type is a linear container type, i.e. array, list or set.</paragraph>
 <paragraph index="6178" node_type="writer" parent_index="6164">Inherit</paragraph>
 <paragraph index="6181" node_type="writer" parent_index="6164">BMM_LITERAL_VALUE</paragraph>
 <paragraph index="6184" node_type="writer" parent_index="435">9.6.3. BMM_INDEXED_CONTAINER_VALUE Class</paragraph>
 <object index="6185" name="Table77" object_type="table"/>
 <paragraph index="6187" node_type="writer" parent_index="6185">Class</paragraph>
 <paragraph index="6190" node_type="writer" parent_index="6185">BMM_INDEXED_CONTAINER_VALUE</paragraph>
 <paragraph index="6193" node_type="writer" parent_index="6185">Description</paragraph>
 <paragraph index="6196" node_type="writer" parent_index="6185">Meta-type for literals whose concrete type is an indexed container, i.e. Hash table, Map etc.</paragraph>
 <paragraph index="6199" node_type="writer" parent_index="6185">Inherit</paragraph>
 <paragraph index="6202" node_type="writer" parent_index="6185">BMM_LITERAL_VALUE</paragraph>
 <paragraph index="6205" node_type="writer" parent_index="435">9.6.4. BMM_UNITARY_VALUE Class</paragraph>
 <object index="6206" name="Table78" object_type="table"/>
 <paragraph index="6208" node_type="writer" parent_index="6206">Class</paragraph>
 <paragraph index="6211" node_type="writer" parent_index="6206">BMM_UNITARY_VALUE&lt;T&gt; (abstract)</paragraph>
 <paragraph index="6214" node_type="writer" parent_index="6206">Description</paragraph>
 <paragraph index="6217" node_type="writer" parent_index="6206">Meta-type for literals whose concrete type is a unitary type in the BMM sense.</paragraph>
 <paragraph index="6220" node_type="writer" parent_index="6206">Inherit</paragraph>
 <paragraph index="6223" node_type="writer" parent_index="6206">BMM_LITERAL_VALUE</paragraph>
 <paragraph index="6226" node_type="writer" parent_index="435">9.6.5. BMM_PRIMITIVE_VALUE Class</paragraph>
 <object index="6227" name="Table79" object_type="table"/>
 <paragraph index="6229" node_type="writer" parent_index="6227">Class</paragraph>
 <paragraph index="6232" node_type="writer" parent_index="6227">BMM_PRIMITIVE_VALUE&lt;&gt;</paragraph>
 <paragraph index="6235" node_type="writer" parent_index="6227">Description</paragraph>
 <paragraph index="6238" node_type="writer" parent_index="6227">Meta-type for literals whose concrete type is a primitive type.</paragraph>
 <paragraph index="6241" node_type="writer" parent_index="6227">Inherit</paragraph>
 <paragraph index="6244" node_type="writer" parent_index="6227">BMM_UNITARY_VALUE</paragraph>
 <paragraph index="6247" node_type="writer" parent_index="6227">Attributes</paragraph>
 <paragraph index="6250" node_type="writer" parent_index="6227">Signature</paragraph>
 <paragraph index="6253" node_type="writer" parent_index="6227">Meaning</paragraph>
 <paragraph index="6256" node_type="writer" parent_index="6227">1..1
(redefined)</paragraph>
 <paragraph index="6259" node_type="writer" parent_index="6227">type: BMM_SIMPLE_TYPE</paragraph>
 <paragraph index="6262" node_type="writer" parent_index="6227">Concrete type of this literal.</paragraph>
 <paragraph index="6265" node_type="writer" parent_index="435">9.6.6. BMM_STRING_VALUE Class</paragraph>
 <object index="6266" name="Table80" object_type="table"/>
 <paragraph index="6268" node_type="writer" parent_index="6266">Class</paragraph>
 <paragraph index="6271" node_type="writer" parent_index="6266">BMM_STRING_VALUE</paragraph>
 <paragraph index="6274" node_type="writer" parent_index="6266">Description</paragraph>
 <paragraph index="6277" node_type="writer" parent_index="6266">Meta-type for a literal String value, for which type is fixed to the BMM_TYPE representing String and value is of type String.</paragraph>
 <paragraph index="6280" node_type="writer" parent_index="6266">Inherit</paragraph>
 <paragraph index="6283" node_type="writer" parent_index="6266">BMM_PRIMITIVE_VALUE</paragraph>
 <paragraph index="6286" node_type="writer" parent_index="6266">Attributes</paragraph>
 <paragraph index="6289" node_type="writer" parent_index="6266">Signature</paragraph>
 <paragraph index="6292" node_type="writer" parent_index="6266">Meaning</paragraph>
 <paragraph index="6295" node_type="writer" parent_index="6266">1..1
(redefined)</paragraph>
 <paragraph index="6298" node_type="writer" parent_index="6266">value: String</paragraph>
 <paragraph index="6301" node_type="writer" parent_index="6266">Native String value.</paragraph>
 <paragraph index="6304" node_type="writer" parent_index="435">9.6.7. BMM_INTEGER_VALUE Class</paragraph>
 <object index="6305" name="Table81" object_type="table"/>
 <paragraph index="6307" node_type="writer" parent_index="6305">Class</paragraph>
 <paragraph index="6310" node_type="writer" parent_index="6305">BMM_INTEGER_VALUE</paragraph>
 <paragraph index="6313" node_type="writer" parent_index="6305">Description</paragraph>
 <paragraph index="6316" node_type="writer" parent_index="6305">Meta-type for a literal Integer value, for which type is fixed to the BMM_TYPE representing Integer and value is of type Integer.</paragraph>
 <paragraph index="6319" node_type="writer" parent_index="6305">Inherit</paragraph>
 <paragraph index="6322" node_type="writer" parent_index="6305">BMM_PRIMITIVE_VALUE</paragraph>
 <paragraph index="6325" node_type="writer" parent_index="6305">Attributes</paragraph>
 <paragraph index="6328" node_type="writer" parent_index="6305">Signature</paragraph>
 <paragraph index="6331" node_type="writer" parent_index="6305">Meaning</paragraph>
 <paragraph index="6334" node_type="writer" parent_index="6305">1..1
(redefined)</paragraph>
 <paragraph index="6337" node_type="writer" parent_index="6305">value: Integer</paragraph>
 <paragraph index="6340" node_type="writer" parent_index="6305">Native Integer value.</paragraph>
 <paragraph index="6343" node_type="writer" parent_index="435">9.6.8. BMM_BOOLEAN_VALUE Class</paragraph>
 <object index="6344" name="Table82" object_type="table"/>
 <paragraph index="6346" node_type="writer" parent_index="6344">Class</paragraph>
 <paragraph index="6349" node_type="writer" parent_index="6344">BMM_BOOLEAN_VALUE</paragraph>
 <paragraph index="6352" node_type="writer" parent_index="6344">Description</paragraph>
 <paragraph index="6355" node_type="writer" parent_index="6344">Meta-type for a literal Boolean value, for which type is fixed to the BMM_TYPE representing Boolean and value is of type Boolean.</paragraph>
 <paragraph index="6358" node_type="writer" parent_index="6344">Inherit</paragraph>
 <paragraph index="6361" node_type="writer" parent_index="6344">BMM_PRIMITIVE_VALUE</paragraph>
 <paragraph index="6364" node_type="writer" parent_index="6344">Attributes</paragraph>
 <paragraph index="6367" node_type="writer" parent_index="6344">Signature</paragraph>
 <paragraph index="6370" node_type="writer" parent_index="6344">Meaning</paragraph>
 <paragraph index="6373" node_type="writer" parent_index="6344">1..1
(redefined)</paragraph>
 <paragraph index="6376" node_type="writer" parent_index="6344">value: Boolean</paragraph>
 <paragraph index="6379" node_type="writer" parent_index="6344">Native Boolean value.</paragraph>
 <paragraph index="6382" node_type="writer" parent_index="435">9.6.9. BMM_INTERVAL_VALUE Class</paragraph>
 <object index="6383" name="Table83" object_type="table"/>
 <paragraph index="6385" node_type="writer" parent_index="6383">Class</paragraph>
 <paragraph index="6388" node_type="writer" parent_index="6383">BMM_INTERVAL_VALUE</paragraph>
 <paragraph index="6391" node_type="writer" parent_index="6383">Description</paragraph>
 <paragraph index="6394" node_type="writer" parent_index="6383">Meta-type for literal intervals of type Interval&lt;Ordered&gt;.</paragraph>
 <paragraph index="6397" node_type="writer" parent_index="6383">Inherit</paragraph>
 <paragraph index="6400" node_type="writer" parent_index="6383">BMM_LITERAL_VALUE</paragraph>
 <paragraph index="6403" node_type="writer" parent_index="435">10. Expressions</paragraph>
 <paragraph index="6404" node_type="writer" parent_index="435">10.1. Overview</paragraph>
 <paragraph index="6405" node_type="writer" parent_index="435">Expressions in BMM are used to specify class invariants, routine pre- and post-conditions, and may be used more generally in other contexts requiring expressions. They are defined by a set of classes prefixed by 'EL', indicating 'expression language'. The BMM expression meta-model is based on the following taxonomy of expression entities:</paragraph>
 <object index="6406" name="bmm_expression_type_hierarchy" object_type="section"/>
 <paragraph index="6407" node_type="writer" parent_index="6406"> </paragraph>
 <paragraph index="6408" node_type="writer" parent_index="6406">Figure 34. Expression Taxonomy</paragraph>
 <paragraph index="6410" node_type="writer" parent_index="435">The meta-types defined in this part of the BMM model may be understood as the types of entities in an abstract syntax tree (AST) generated from expression parsing. Conversely, one or more expression syntaxes may be parsed into a tree based on the model described here. Note however, that whatever the variation in surface syntax, all such syntaxes parsed this way ultimately have the semantics defined by the BMM EL meta-model. This is true even for expressions written in a syntax whose published semantics are in fact different, e.g. a well-known programming language.</paragraph>
 <paragraph index="6411" node_type="writer" parent_index="435">The UML model of the BMM expression package, consisting of mostly direct equivalents of the taxonomy classes above, is shown below.</paragraph>
 <object index="6412" name="bmm_expression" object_type="section"/>
 <paragraph index="6413" node_type="writer" parent_index="6412"> </paragraph>
 <paragraph index="6414" node_type="writer" parent_index="6412">Figure 35. bmm.expression Package</paragraph>
 <paragraph index="6416" node_type="writer" parent_index="435">EL classes are descendants of the class EL_EXPRESSION, which is characterised by the feature eval_type(). This is the BMM meta-type of the result type of the expression entity when used in an expression; for literals, this is the inferred type; for object references (including function calls), this is the same as the declared type, and for agents it is the meta-type BMM_SIGNATURE.</paragraph>
 <paragraph index="6417" node_type="writer" parent_index="435">Most EL_EXPRESSIONs are either value generating constructs (EL_VALUE_GENERATOR) or operator expressions. The special sub-type E_TUPLE represents tuple objects which are created on the fly by inline expressions of the form [expr, expr, …​].</paragraph>
 <paragraph index="6418" node_type="writer" parent_index="435">10.2. Terminal Entities</paragraph>
 <paragraph index="6419" node_type="writer" parent_index="435">Terminal entities are atomic with respect to operator expressions, and are either simple entities of familiar kinds (function calls, variable references etc) or else complex logic structures that when evaluated generate a value.</paragraph>
 <paragraph index="6420" node_type="writer" parent_index="435">10.2.1. Simple Terminal Entities</paragraph>
 <paragraph index="6421" node_type="writer" parent_index="435">The simple terminal meta-types in EL are as follows:</paragraph>
 <paragraph index="6422" node_type="writer" parent_index="435">literal values: inline-generated values created without reference to a model instance, but which must be instances of types defined by the model (EL_LITERAL);</paragraph>
 <paragraph index="6423" node_type="writer" parent_index="435">value generators (EL_VALUE_GENERATOR) based on formal model elements that may be called to (potentially) obtain an instance at runtime;</paragraph>
 <paragraph index="6424" node_type="writer" parent_index="435">predicates: Boolean-generating expression elements formed by predicates applied to any of the other value-generating expression elements.</paragraph>
 <paragraph index="6425" node_type="writer" parent_index="435">10.2.1.1. Literals</paragraph>
 <paragraph index="6426" node_type="writer" parent_index="435">A literal value may appear as a separate entity within an operator expression, as well as a functional call or agent parameter. The literal values that may be used are either instances of the openEHR Foundation Types or a complex object instance in a structured serial format (such as JSON, a JSON derivative, ODIN format etc), specified by BMM_LITERAL_VALUE.syntax.</paragraph>
 <paragraph index="6427" node_type="writer" parent_index="435">10.2.1.2. Value Generators</paragraph>
 <paragraph index="6428" node_type="writer" parent_index="435">Value generators are categorised as follows:</paragraph>
 <paragraph index="6429" node_type="writer" parent_index="435">feature references: (EL_FEATURE_REF)</paragraph>
 <paragraph index="6430" node_type="writer" parent_index="435">references to instantiable features: symbolic references to properties and constants (EL_PROPERTY_REF, EL_CONSTANT_REF);</paragraph>
 <paragraph index="6431" node_type="writer" parent_index="435">calls to functions: appropriately constructed calls to functions of the types that define instances (EL_FUNCTION_CALL);</paragraph>
 <paragraph index="6432" node_type="writer" parent_index="435">generation of agents: a special kind of reference to any routine of a model type that generates a delayed routine call object (EL_AGENT);</paragraph>
 <paragraph index="6433" node_type="writer" parent_index="435">variable reference: references to variables within the scope of the current routine, including local variables, parameters, the current object (Self), or the current function result (Result) (EL_VARIABLE);</paragraph>
 <paragraph index="6434" node_type="writer" parent_index="435">a type reference: (EL_TYPE_REF) a reference representing a type object assumed to be available at runtime, on which argumentless function calls and constants may be accessed.</paragraph>
 <paragraph index="6435" node_type="writer" parent_index="435">The arguments of function calls and delayed routine calls may be complex expressions, but will eventually resolved to literal values and instance references. Consequently, the value generated by any expression is ultimately founded upon literal values and instance references.</paragraph>
 <paragraph index="6436" node_type="writer" parent_index="435">To be valid, any model-based feature reference must have a scoping object (represented via the attribute scope in EL_SCOPED), which is one of:</paragraph>
 <paragraph index="6437" node_type="writer" parent_index="435">the current object - implied;</paragraph>
 <paragraph index="6438" node_type="writer" parent_index="435">another object, which may be designated via:</paragraph>
 <paragraph index="6439" node_type="writer" parent_index="435">a specified scoping object, achieved through 'dot-notation' in most languages;</paragraph>
 <paragraph index="6440" node_type="writer" parent_index="435">a type reference.</paragraph>
 <paragraph index="6441" node_type="writer" parent_index="435">Feature References</paragraph>
 <paragraph index="6442" node_type="writer" parent_index="435">In BMM, a feature reference is any symbolic reference to a class feature that resolves to an object at evaluation time. This includes all referenceable entities within classes except procedures, which have no return value. Concretely, a feature reference takes the form of one of:</paragraph>
 <paragraph index="6443" node_type="writer" parent_index="435">a property name, e.g. name;</paragraph>
 <paragraph index="6444" node_type="writer" parent_index="435">a constant name, e.g. pi;</paragraph>
 <paragraph index="6445" node_type="writer" parent_index="435">a variable or parameter name, e.g. a_name, call_name;</paragraph>
 <paragraph index="6446" node_type="writer" parent_index="435">a function call.</paragraph>
 <paragraph index="6447" node_type="writer" parent_index="435">Function calls are described in detail in the following section.</paragraph>
 <paragraph index="6448" node_type="writer" parent_index="435">Type Reference</paragraph>
 <paragraph index="6449" node_type="writer" parent_index="435">A special meta-type, EL_TYPE_REF is provided to refer to a type as an object. This is exclusively used as a convenient way (common in many programming languages) of accessing class features that do not depend on instance properties (i.e. 'constant', 'enum', and 'static' members in C-based languages) without having to explicitly create an instance. As an expression, a type reference will normally only appear as a qualifier of a feature reference, using syntax such as {TypeName}.feature, or with arguments, {TypeName}.function (args…​).</paragraph>
 <paragraph index="6450" node_type="writer" parent_index="435">A class feature is defined as one that is:</paragraph>
 <paragraph index="6451" node_type="writer" parent_index="435">a constant;</paragraph>
 <paragraph index="6452" node_type="writer" parent_index="435">an enumeration literal;</paragraph>
 <paragraph index="6453" node_type="writer" parent_index="435">a function that does not reference any class property or make any call that does, in its body, pre_conditions or post_conditions.</paragraph>
 <paragraph index="6454" node_type="writer" parent_index="435">The last category typically includes 'external' functions that are wrappers for calls to the operating system or other external resource that maintains its own state independently.</paragraph>
 <paragraph index="6455" node_type="writer" parent_index="435">Since a type reference can be made without instantiation, it may be made to an abstract class as well as a concrete one. This facilitates the use of so-called 'utility' classes containing groups of useful functions e.g. for handling specific kinds of strings.</paragraph>
 <paragraph index="6456" node_type="writer" parent_index="435">Examples of type references as qualifiers of class features include the following:</paragraph>
 <paragraph index="6457" node_type="writer" parent_index="435">{Env}.current_time to access the class function current_time defined on the class (or interface) Env;</paragraph>
 <paragraph index="6458" node_type="writer" parent_index="435">{Colours}.red, to access an enumeration literal;</paragraph>
 <paragraph index="6459" node_type="writer" parent_index="435">{Version_utils}.version_higher (&quot;1.5.40&quot;, &quot;11.5.4&quot;).</paragraph>
 <paragraph index="6460" node_type="writer" parent_index="435">A type reference may also be used on its own, such as in the following type test, which is the EL equivalent of programming language operators like type_of().</paragraph>
 <paragraph index="6461" node_type="writer" parent_index="435">admission_dates.type = {Interval&lt;Iso8601_date_time&gt;}.</paragraph>
 <paragraph index="6462" node_type="writer" parent_index="435">Agents</paragraph>
 <paragraph index="6463" node_type="writer" parent_index="435">An agent is the BMM term for a delayed routine call, and has the meta-type EL_AGENT, which in turn has as its formal evaluation type (eval_type) is the meta-type BMM_SIGNATURE. It usually appears as a standalone expression, or else a parameter within another agent or function call. Agents are described in detail in the following section.</paragraph>
 <paragraph index="6464" node_type="writer" parent_index="435">10.2.1.3. Variables</paragraph>
 <paragraph index="6465" node_type="writer" parent_index="435">Symbolic variables (meta-type EL_VARIABLE) are one of the following:</paragraph>
 <paragraph index="6466" node_type="writer" parent_index="435">variables declared locally in a routine (EL_VARIABLE.definition = BMM_LOCAL);</paragraph>
 <paragraph index="6467" node_type="writer" parent_index="435">named arguments of a routine (EL_VARIABLE.definition = BMM_PARAMETER);</paragraph>
 <paragraph index="6468" node_type="writer" parent_index="435">a special variable called 'Result' representing the result object of a function (EL_VARIABLE.definition = BMM_RESULT);</paragraph>
 <paragraph index="6469" node_type="writer" parent_index="435">a special variable (often called 'this' or 'self' in object-oriented programming languages) to refer to the object acting as the context for enclosed statements (EL_VARIABLE.definition = BMM_SELF).</paragraph>
 <paragraph index="6470" node_type="writer" parent_index="435">10.2.1.4. Predicates</paragraph>
 <paragraph index="6471" node_type="writer" parent_index="435">Predicates in BMM are Boolean-returning terminal expressions taking one feature reference operand, and are represented by the meta-type EL_PREDICATE. Predicates conceptually apply to data instance structures and may be understood as queries on data. Any number of specific predicates might be added as extensions via inheritance. In particular, Xpath-style predicates could be supported by addition of meta-types descending from EL_PREDICATE. The following UML shows the predicate meta-types.</paragraph>
 <object index="6472" name="bmm_expression_predicate" object_type="section"/>
 <paragraph index="6473" node_type="writer" parent_index="6472"> </paragraph>
 <paragraph index="6474" node_type="writer" parent_index="6472">Figure 36. Predicates</paragraph>
 <paragraph index="6476" node_type="writer" parent_index="435">The following predicates are pre-defined.</paragraph>
 <paragraph index="6477" node_type="writer" parent_index="435">Attached (x)</paragraph>
 <paragraph index="6478" node_type="writer" parent_index="435">The attached predicate is used to test for an instance reference (including a function call result) being Void. It may be used in expressions such as the following class invariant.</paragraph>
 <paragraph index="6479" node_type="writer" parent_index="435">class SmartRef</paragraph>
 <paragraph index="6481" node_type="writer" parent_index="435">feature</paragraph>
 <paragraph index="6483" node_type="writer" parent_index="435">    property url: Url;</paragraph>
 <paragraph index="6484" node_type="writer" parent_index="435">    property value: Base64String;</paragraph>
 <paragraph index="6486" node_type="writer" parent_index="435">    invariant</paragraph>
 <paragraph index="6487" node_type="writer" parent_index="435">        Validity: attached(url) or attached(value)</paragraph>
 <paragraph index="6488" node_type="writer" parent_index="435">Defined (x)</paragraph>
 <paragraph index="6489" node_type="writer" parent_index="435">The defined predicate is used to test whether an instance that is mapped to an external data access method exists in the data context (regardless of its value there).</paragraph>
 <paragraph index="6490" node_type="writer" parent_index="435">TBD: this might be replaced by another approach.</paragraph>
 <paragraph index="6491" node_type="writer" parent_index="435">10.2.2. Decision Tables</paragraph>
 <paragraph index="6492" node_type="writer" parent_index="435">The BMM expression package contains the meta-class EL_DECISION_TABLE that defines an abstract decision table construct, consisting of an ordered set of items, each of type EL_DECISION_BRANCH, and having a result of any expression type (including another decision table). Two concrete subtypes of each of these abstract meta-types are used to represent two common kinds of decision structure found in procedural and most object-oriented programming languages:</paragraph>
 <paragraph index="6493" node_type="writer" parent_index="435">an if/then/elseif/else condition chain (meta-classes EL_CONDITION_CHAIN and EL_CONDITIONAL_EXPRESSION); and</paragraph>
 <paragraph index="6494" node_type="writer" parent_index="435">a case statement style table (meta-classes EL_CASE_TABLE and EL_CASE), whose conditions are value intervals against which the table’s input value expression is evaluated to determine the result.</paragraph>
 <paragraph index="6495" node_type="writer" parent_index="435">The else branch will be used to provide the result expression in the case that all other branches fail, guaranteeing a result.</paragraph>
 <paragraph index="6496" node_type="writer" parent_index="435">EL_DECISION_TABLE and its descendants are also kind of expression, enabling them to be used as value-returning entities in certain other expression contexts, including inside other decision tables.</paragraph>
 <paragraph index="6497" node_type="writer" parent_index="435">The following UML illustrates.</paragraph>
 <object index="6498" name="bmm_expression_decision_table" object_type="section"/>
 <paragraph index="6499" node_type="writer" parent_index="6498"> </paragraph>
 <paragraph index="6500" node_type="writer" parent_index="6498">Figure 37. Decision Tables</paragraph>
 <paragraph index="6502" node_type="writer" parent_index="435">The logic of a EL_CONDITION_CHAIN is the same as an if/then/elseif/else chain in procedural programming, except that instead of assignment statements on each branch, pure result expressions are used. This enables a more sophisticated syntactic rendering, resembling a table, such as the following:</paragraph>
 <paragraph index="6503" node_type="writer" parent_index="435">    molecular_subtype: Terminology_term</paragraph>
 <paragraph index="6504" node_type="writer" parent_index="435">        Result := choice in</paragraph>
 <paragraph index="6505" node_type="writer" parent_index="435">            =======================================================</paragraph>
 <paragraph index="6506" node_type="writer" parent_index="435">            er_positive and</paragraph>
 <paragraph index="6507" node_type="writer" parent_index="435">            her2_negative and</paragraph>
 <paragraph index="6508" node_type="writer" parent_index="435">            not ki67.in_range (#high):    #luminal_A,</paragraph>
 <paragraph index="6509" node_type="writer" parent_index="435">            -------------------------------------------------------</paragraph>
 <paragraph index="6510" node_type="writer" parent_index="435">            er_positive and</paragraph>
 <paragraph index="6511" node_type="writer" parent_index="435">            her2_negative and</paragraph>
 <paragraph index="6512" node_type="writer" parent_index="435">            ki67.in_range (#high):        #luminal_B_HER2_negative,</paragraph>
 <paragraph index="6513" node_type="writer" parent_index="435">            -------------------------------------------------------</paragraph>
 <paragraph index="6514" node_type="writer" parent_index="435">            er_positive and</paragraph>
 <paragraph index="6515" node_type="writer" parent_index="435">            her2_positive:                #luminal_B_HER2_positive,</paragraph>
 <paragraph index="6516" node_type="writer" parent_index="435">            -------------------------------------------------------</paragraph>
 <paragraph index="6517" node_type="writer" parent_index="435">            er_negative and</paragraph>
 <paragraph index="6518" node_type="writer" parent_index="435">            pr_negative and</paragraph>
 <paragraph index="6519" node_type="writer" parent_index="435">            her2_positive and</paragraph>
 <paragraph index="6520" node_type="writer" parent_index="435">            ki67.in_range (#high):        #HER2,</paragraph>
 <paragraph index="6521" node_type="writer" parent_index="435">            -------------------------------------------------------</paragraph>
 <paragraph index="6522" node_type="writer" parent_index="435">            er_negative and</paragraph>
 <paragraph index="6523" node_type="writer" parent_index="435">            pr_negative and</paragraph>
 <paragraph index="6524" node_type="writer" parent_index="435">            her2_negative and</paragraph>
 <paragraph index="6525" node_type="writer" parent_index="435">            ki67.in_range (#high):        #triple_negative,</paragraph>
 <paragraph index="6526" node_type="writer" parent_index="435">            -------------------------------------------------------</paragraph>
 <paragraph index="6527" node_type="writer" parent_index="435">            *:                            #none</paragraph>
 <paragraph index="6528" node_type="writer" parent_index="435">            =======================================================</paragraph>
 <paragraph index="6529" node_type="writer" parent_index="435">        ;</paragraph>
 <paragraph index="6530" node_type="writer" parent_index="435">The above is a function that computes the molecular subtype of breast cancer using a decision table whose branches are based on a number of input variables that appear in expressions down the left-hand side and which returns a Terminology_code instance (the notation #identifier represents a literal Terminology_code instance).</paragraph>
 <paragraph index="6531" node_type="writer" parent_index="435">An example of EL_CASE_TABLE is shown below. Here, two case tables are used, with each generating a numeric result based on the values of the platelets and gfr variables respectively.</paragraph>
 <paragraph index="6532" node_type="writer" parent_index="435">    cyclophosphamide_dose: Quantity</paragraph>
 <paragraph index="6533" node_type="writer" parent_index="435">        Result := cyclophosphamide_dose_per_m2 * BSA.bsa_m2</paragraph>
 <paragraph index="6534" node_type="writer" parent_index="435">            * case platelets.range in</paragraph>
 <paragraph index="6535" node_type="writer" parent_index="435">                ===================</paragraph>
 <paragraph index="6536" node_type="writer" parent_index="435">                #normal:      1,</paragraph>
 <paragraph index="6537" node_type="writer" parent_index="435">                #low:         0.75</paragraph>
 <paragraph index="6538" node_type="writer" parent_index="435">                ===================</paragraph>
 <paragraph index="6539" node_type="writer" parent_index="435">            * case gfr.range in</paragraph>
 <paragraph index="6540" node_type="writer" parent_index="435">                ===================</paragraph>
 <paragraph index="6541" node_type="writer" parent_index="435">                #normal:      1,</paragraph>
 <paragraph index="6542" node_type="writer" parent_index="435">                #low:         0.75,</paragraph>
 <paragraph index="6543" node_type="writer" parent_index="435">                #very_low:    0.5</paragraph>
 <paragraph index="6544" node_type="writer" parent_index="435">                ===================</paragraph>
 <paragraph index="6545" node_type="writer" parent_index="435">            ;</paragraph>
 <paragraph index="6546" node_type="writer" parent_index="435">10.3. Operator Expressions</paragraph>
 <paragraph index="6547" node_type="writer" parent_index="435">BMM contains meta-types representing operators, but assumes that all operators are surface aliases for functions defined on some class. For this reason, an occurrence of an operator within an expression, represented an instance of a descendant of EL_OPERATOR, contains the attribute definition to refer to the corresponding function definition. This has to be inferred from the types of its operands. Consequently, 'operator expressions' as commonly understood are simply function calls (often nested) in BMM. The following UML shows the relevant meta-types.</paragraph>
 <object index="6548" name="bmm_expression_operator" object_type="section"/>
 <paragraph index="6549" node_type="writer" parent_index="6548"> </paragraph>
 <paragraph index="6550" node_type="writer" parent_index="6548">Figure 38. Operator meta-types</paragraph>
 <paragraph index="6552" node_type="writer" parent_index="435">The following example illustrates the general meta-model of expressions, using a typical use of expression, the class invariant.</paragraph>
 <paragraph index="6553" node_type="writer" parent_index="435">class Account</paragraph>
 <paragraph index="6555" node_type="writer" parent_index="435">feature</paragraph>
 <paragraph index="6556" node_type="writer" parent_index="435">    balance: Decimal</paragraph>
 <paragraph index="6557" node_type="writer" parent_index="435">    overdraft_limit: Decimal</paragraph>
 <paragraph index="6559" node_type="writer" parent_index="435">invariant</paragraph>
 <paragraph index="6560" node_type="writer" parent_index="435">    balance + overdraft_limit &gt; 0</paragraph>
 <paragraph index="6561" node_type="writer" parent_index="435">The expression balance + overdraft_limit &gt; 0 makes use of two operators + and &gt;, which are really functions defined on the type Decimal, as follows.</paragraph>
 <paragraph index="6562" node_type="writer" parent_index="435">class Decimal</paragraph>
 <paragraph index="6564" node_type="writer" parent_index="435">feature</paragraph>
 <paragraph index="6565" node_type="writer" parent_index="435">    greater_than (other: Decimal): Boolean</paragraph>
 <paragraph index="6566" node_type="writer" parent_index="435">        alias '&gt;'</paragraph>
 <paragraph index="6568" node_type="writer" parent_index="435">    addition: (other: Decimal): Decimal</paragraph>
 <paragraph index="6569" node_type="writer" parent_index="435">        alias '+'</paragraph>
 <paragraph index="6570" node_type="writer" parent_index="435">A parser processing this expression would produce the result shown below, assuming that the BMM model containing these classes had already been instantiated.</paragraph>
 <object index="6571" name="bmm_expression_property_ref" object_type="section"/>
 <paragraph index="6572" node_type="writer" parent_index="6571"> </paragraph>
 <paragraph index="6573" node_type="writer" parent_index="6571">Figure 39. Instantiated Operator Expression</paragraph>
 <paragraph index="6575" node_type="writer" parent_index="435">Below, we consider a number of examples illustrating expressions containing the various kinds of terminal reference, based on the following assumed declarations.</paragraph>
 <paragraph index="6576" node_type="writer" parent_index="435">    feature -- Definitions</paragraph>
 <paragraph index="6578" node_type="writer" parent_index="435">        Fast_resting_heart_rate: Real = 100;</paragraph>
 <paragraph index="6579" node_type="writer" parent_index="435">        Atrial_fibrillation_heart_rate: Real = 120;</paragraph>
 <paragraph index="6580" node_type="writer" parent_index="435">        Erratic: Terminology_code = {</paragraph>
 <paragraph index="6581" node_type="writer" parent_index="435">            &quot;terminology_id&quot;: &quot;snomed_ct&quot;,</paragraph>
 <paragraph index="6582" node_type="writer" parent_index="435">            &quot;code_string&quot;: &quot;286761003&quot;</paragraph>
 <paragraph index="6583" node_type="writer" parent_index="435">        }</paragraph>
 <paragraph index="6584" node_type="writer" parent_index="435">        Blood_pressure_units: String = &quot;mm[Hg]&quot;;</paragraph>
 <paragraph index="6586" node_type="writer" parent_index="435">    feature -- Accessors</paragraph>
 <paragraph index="6588" node_type="writer" parent_index="435">        heart_rate: Real;</paragraph>
 <paragraph index="6589" node_type="writer" parent_index="435">        heart_rhythm: Terminology_code;</paragraph>
 <paragraph index="6590" node_type="writer" parent_index="435">        bp_samples: List&lt;Quantity&gt;;</paragraph>
 <paragraph index="6591" node_type="writer" parent_index="435">        patient: Patient;</paragraph>
 <paragraph index="6592" node_type="writer" parent_index="435">The first example is a comparison of a property value to a value, where the &gt;= operator maps to the function Real.greater_than_or_equal()</paragraph>
 <paragraph index="6593" node_type="writer" parent_index="435">    heart_rate &gt;= 80</paragraph>
 <paragraph index="6594" node_type="writer" parent_index="435">The following shows the comparison of a property value with a constant, where the &gt;= operator maps to the function Real.greater_than_or_equal()</paragraph>
 <paragraph index="6595" node_type="writer" parent_index="435">    heart_rate &gt;= Fast_resting_heart_rate</paragraph>
 <paragraph index="6596" node_type="writer" parent_index="435">The following is a logical condition, where the = operator maps to a function such as Terminology_code.equal(); and maps to Boolean.and(); and &gt;= maps to Real.greater_than_or_equal().</paragraph>
 <paragraph index="6597" node_type="writer" parent_index="435">    heart_rhythm = Erratic and heart_rate &gt;= Atrial_fibrillation_heart_rate</paragraph>
 <paragraph index="6598" node_type="writer" parent_index="435">The following is the same logical condition, but with the use of object scope specified with 'dot notation', here 'patient.'.</paragraph>
 <paragraph index="6599" node_type="writer" parent_index="435">    patient.heart_rhythm = Erratic and patient.heart_rate &gt;= Atrial_fibrillation_heart_rate</paragraph>
 <paragraph index="6600" node_type="writer" parent_index="435">The following shows a function call whose argument is an expression.</paragraph>
 <paragraph index="6601" node_type="writer" parent_index="435">    date_of_birth.earlier ({Env}.current_date - P10Y)</paragraph>
 <paragraph index="6602" node_type="writer" parent_index="435">The following shows the use of an inline agent as an argument to the function List.for_all().</paragraph>
 <paragraph index="6603" node_type="writer" parent_index="435">    bp_samples.for_all (</paragraph>
 <paragraph index="6604" node_type="writer" parent_index="435">        agent (a_quantity: Quantity) {</paragraph>
 <paragraph index="6605" node_type="writer" parent_index="435">            a_quantity.units.is_equal (Blood_pressure_units);</paragraph>
 <paragraph index="6606" node_type="writer" parent_index="435">        }</paragraph>
 <paragraph index="6607" node_type="writer" parent_index="435">    );</paragraph>
 <paragraph index="6608" node_type="writer" parent_index="435">10.4. Tuples</paragraph>
 <paragraph index="6609" node_type="writer" parent_index="435">Although rarely useful in class definitions, a Tuple of any degree may be formed from any combination of other EL expressions and used on its own as an expression terminal element. The main use for this construct is to express a literal tuple, i.e. one whose constituents consist only of proper literal values.</paragraph>
 <paragraph index="6610" node_type="writer" parent_index="435">For more general uses of BMM Expressions, tuple instances are the basis of representing ad hoc query results which have a formal type such as List&lt;[Ta, Tb, Tc]&gt;, where [Ta, Tb, Tc] represents a tuple of three types.</paragraph>
 <paragraph index="6611" node_type="writer" parent_index="435">10.5. Usage in BMM Models</paragraph>
 <paragraph index="6612" node_type="writer" parent_index="435">Expressions as used in BMM models to express class invariants and routine pre- and post-conditions are always in the form of an BMM_ASSERTION, i.e. a tagged Boolean-returning EL_EXPRESSION.</paragraph>
 <paragraph index="6613" node_type="writer" parent_index="435">10.5.1. Simple Assertions</paragraph>
 <paragraph index="6614" node_type="writer" parent_index="435">Simple assertions may be formed from common operators and operands, including the usual logical arithmetic and comparison operators, as well as any operators relating to specific data types. Normally the top-level operator in the Expression graph is a logical or relational operator. Since all operators are mapped to functions defined on types, there are no 'floating' or 'built-in' operators as such.</paragraph>
 <paragraph index="6615" node_type="writer" parent_index="435">10.5.2. Existential and Universal Quantifier Invariants</paragraph>
 <paragraph index="6616" node_type="writer" parent_index="435">A common kind of expression used in class invariants operates over collections and uses the existential and universal quantifier operators, i.e. ∃ and ∀, from predicate logic. A typical expression to use within a class invariant is shown below in an abstract syntax.</paragraph>
 <paragraph index="6617" node_type="writer" parent_index="435">class PersonName</paragraph>
 <paragraph index="6618" node_type="writer" parent_index="435">property items: String[1..*];</paragraph>
 <paragraph index="6620" node_type="writer" parent_index="435">invariant</paragraph>
 <paragraph index="6621" node_type="writer" parent_index="435">    ∀ nameItem: items | not nameItem.isEmpty()</paragraph>
 <paragraph index="6622" node_type="writer" parent_index="435">A different syntax might express it as follows.</paragraph>
 <paragraph index="6623" node_type="writer" parent_index="435">    invariant</paragraph>
 <paragraph index="6624" node_type="writer" parent_index="435">        for nameItem in items all</paragraph>
 <paragraph index="6625" node_type="writer" parent_index="435">            not nameItem.isEmpty()</paragraph>
 <paragraph index="6626" node_type="writer" parent_index="435">        end</paragraph>
 <paragraph index="6627" node_type="writer" parent_index="435">A similar invariant, this time using ∃, is shown below.</paragraph>
 <paragraph index="6628" node_type="writer" parent_index="435">    invariant</paragraph>
 <paragraph index="6629" node_type="writer" parent_index="435">        for nameItem in items</paragraph>
 <paragraph index="6630" node_type="writer" parent_index="435">            ∃ not nameItem.isEmpty()</paragraph>
 <paragraph index="6631" node_type="writer" parent_index="435">Regardless of the surface syntax, expressions such as the above map to functions such as for_all and there_exists defined on relevant linear container types. These functions have the following signatures in which the 'test' expression appears as a Function agent type.</paragraph>
 <paragraph index="6632" node_type="writer" parent_index="435">class Container&lt;T&gt;</paragraph>
 <paragraph index="6634" node_type="writer" parent_index="435">feature</paragraph>
 <paragraph index="6636" node_type="writer" parent_index="435">    for_all (test: Function&lt;[T], Boolean&gt;): Boolean;</paragraph>
 <paragraph index="6637" node_type="writer" parent_index="435">            -- True if for every v in container, test (v) is True</paragraph>
 <paragraph index="6639" node_type="writer" parent_index="435">    there_exists (test: Function&lt;[T], Boolean&gt;): Boolean;</paragraph>
 <paragraph index="6640" node_type="writer" parent_index="435">            -- True if there is any v in container for which test (v) is True</paragraph>
 <paragraph index="6641" node_type="writer" parent_index="435">10.6. Class Definitions</paragraph>
 <paragraph index="6642" node_type="writer" parent_index="435">10.6.1. EL_EXPRESSION Class</paragraph>
 <object index="6643" name="Table84" object_type="table"/>
 <paragraph index="6645" node_type="writer" parent_index="6643">Class</paragraph>
 <paragraph index="6648" node_type="writer" parent_index="6643">EL_EXPRESSION (abstract)</paragraph>
 <paragraph index="6651" node_type="writer" parent_index="6643">Description</paragraph>
 <paragraph index="6654" node_type="writer" parent_index="6643">Abstract parent of all typed expression meta-types.</paragraph>
 <paragraph index="6657" node_type="writer" parent_index="6643">Functions</paragraph>
 <paragraph index="6660" node_type="writer" parent_index="6643">Signature</paragraph>
 <paragraph index="6663" node_type="writer" parent_index="6643">Meaning</paragraph>
 <paragraph index="6666" node_type="writer" parent_index="6643">1..1
(abstract)</paragraph>
 <paragraph index="6669" node_type="writer" parent_index="6643">eval_type (): BMM_TYPE</paragraph>
 <paragraph index="6672" node_type="writer" parent_index="6643">Meta-type of expression entity used in type-checking and evaluation.</paragraph>
 <paragraph index="6673" node_type="writer" parent_index="6643">Effected in descendants.</paragraph>
 <paragraph index="6676" node_type="writer" parent_index="6643">1..1</paragraph>
 <paragraph index="6679" node_type="writer" parent_index="6643">is_boolean (): Boolean

Post_result: Result = eval_type().equal( {BMM_MODEL}.boolean_type_definition())</paragraph>
 <paragraph index="6682" node_type="writer" parent_index="6643">True if eval_type is notionally Boolean (i.e. a BMM_SIMPLE_TYPE with type_name() = Boolean).</paragraph>
 <paragraph index="6685" node_type="writer" parent_index="435">10.6.2. EL_TERMINAL Class</paragraph>
 <object index="6686" name="Table85" object_type="table"/>
 <paragraph index="6688" node_type="writer" parent_index="6686">Class</paragraph>
 <paragraph index="6691" node_type="writer" parent_index="6686">EL_TERMINAL (abstract)</paragraph>
 <paragraph index="6694" node_type="writer" parent_index="6686">Description</paragraph>
 <paragraph index="6697" node_type="writer" parent_index="6686">Expression entities that are terminals (i.e. leaves) within operator expressions or tuples.</paragraph>
 <paragraph index="6700" node_type="writer" parent_index="6686">Inherit</paragraph>
 <paragraph index="6703" node_type="writer" parent_index="6686">EL_EXPRESSION</paragraph>
 <paragraph index="6706" node_type="writer" parent_index="435">10.6.3. EL_SIMPLE Class</paragraph>
 <object index="6707" name="Table86" object_type="table"/>
 <paragraph index="6709" node_type="writer" parent_index="6707">Class</paragraph>
 <paragraph index="6712" node_type="writer" parent_index="6707">EL_SIMPLE (abstract)</paragraph>
 <paragraph index="6715" node_type="writer" parent_index="6707">Description</paragraph>
 <paragraph index="6718" node_type="writer" parent_index="6707">Simple terminal i.e. logically atomic expression element.</paragraph>
 <paragraph index="6721" node_type="writer" parent_index="6707">Inherit</paragraph>
 <paragraph index="6724" node_type="writer" parent_index="6707">EL_TERMINAL</paragraph>
 <paragraph index="6727" node_type="writer" parent_index="435">10.6.4. EL_VALUE_GENERATOR Class</paragraph>
 <object index="6728" name="Table87" object_type="table"/>
 <paragraph index="6730" node_type="writer" parent_index="6728">Class</paragraph>
 <paragraph index="6733" node_type="writer" parent_index="6728">EL_VALUE_GENERATOR (abstract)</paragraph>
 <paragraph index="6736" node_type="writer" parent_index="6728">Description</paragraph>
 <paragraph index="6739" node_type="writer" parent_index="6728">Meta-type representing a value-generating simple expression.</paragraph>
 <paragraph index="6742" node_type="writer" parent_index="6728">Inherit</paragraph>
 <paragraph index="6745" node_type="writer" parent_index="6728">EL_SIMPLE</paragraph>
 <paragraph index="6748" node_type="writer" parent_index="6728">Attributes</paragraph>
 <paragraph index="6751" node_type="writer" parent_index="6728">Signature</paragraph>
 <paragraph index="6754" node_type="writer" parent_index="6728">Meaning</paragraph>
 <paragraph index="6757" node_type="writer" parent_index="6728">1..1</paragraph>
 <paragraph index="6760" node_type="writer" parent_index="6728">is_writable: Boolean</paragraph>
 <paragraph index="6766" node_type="writer" parent_index="6728">1..1</paragraph>
 <paragraph index="6769" node_type="writer" parent_index="6728">name: String</paragraph>
 <paragraph index="6772" node_type="writer" parent_index="6728">Name used to represent the reference or other entity.</paragraph>
 <paragraph index="6775" node_type="writer" parent_index="6728">Functions</paragraph>
 <paragraph index="6778" node_type="writer" parent_index="6728">Signature</paragraph>
 <paragraph index="6781" node_type="writer" parent_index="6728">Meaning</paragraph>
 <paragraph index="6784" node_type="writer" parent_index="6728">1..1</paragraph>
 <paragraph index="6787" node_type="writer" parent_index="6728">reference (): String</paragraph>
 <paragraph index="6790" node_type="writer" parent_index="6728">Generated full reference name, based on constituent parts of the entity. Default version outputs name field.</paragraph>
 <paragraph index="6793" node_type="writer" parent_index="435">10.6.5. EL_TYPE_REF Class</paragraph>
 <object index="6794" name="Table88" object_type="table"/>
 <paragraph index="6796" node_type="writer" parent_index="6794">Class</paragraph>
 <paragraph index="6799" node_type="writer" parent_index="6794">EL_TYPE_REF</paragraph>
 <paragraph index="6802" node_type="writer" parent_index="6794">Description</paragraph>
 <paragraph index="6805" node_type="writer" parent_index="6794">Meta-type for reference to a non-abstract type as an object. Assumed to be accessible at run-time. Typically represented syntactically as TypeName or {TypeName}.</paragraph>
 <paragraph index="6806" node_type="writer" parent_index="6794">May be used as a value, or as the qualifier for a function or constant access.</paragraph>
 <paragraph index="6809" node_type="writer" parent_index="6794">Inherit</paragraph>
 <paragraph index="6812" node_type="writer" parent_index="6794">EL_VALUE_GENERATOR</paragraph>
 <paragraph index="6815" node_type="writer" parent_index="6794">Attributes</paragraph>
 <paragraph index="6818" node_type="writer" parent_index="6794">Signature</paragraph>
 <paragraph index="6821" node_type="writer" parent_index="6794">Meaning</paragraph>
 <paragraph index="6824" node_type="writer" parent_index="6794">1..1</paragraph>
 <paragraph index="6827" node_type="writer" parent_index="6794">type: BMM_TYPE</paragraph>
 <paragraph index="6830" node_type="writer" parent_index="6794">Type, directly from the name of the reference, e.g. {SOME_TYPE}.</paragraph>
 <paragraph index="6833" node_type="writer" parent_index="6794">1..1</paragraph>
 <paragraph index="6836" node_type="writer" parent_index="6794">is_mutable: Boolean
{default = false}</paragraph>
 <paragraph index="6842" node_type="writer" parent_index="6794">Functions</paragraph>
 <paragraph index="6845" node_type="writer" parent_index="6794">Signature</paragraph>
 <paragraph index="6848" node_type="writer" parent_index="6794">Meaning</paragraph>
 <paragraph index="6851" node_type="writer" parent_index="6794">1..1
(effected)</paragraph>
 <paragraph index="6854" node_type="writer" parent_index="6794">eval_type (): BMM_TYPE</paragraph>
 <paragraph index="6857" node_type="writer" parent_index="6794">Return type.</paragraph>
 <paragraph index="6860" node_type="writer" parent_index="435">10.6.6. EL_LITERAL Class</paragraph>
 <object index="6861" name="Table89" object_type="table"/>
 <paragraph index="6863" node_type="writer" parent_index="6861">Class</paragraph>
 <paragraph index="6866" node_type="writer" parent_index="6861">EL_LITERAL</paragraph>
 <paragraph index="6869" node_type="writer" parent_index="6861">Description</paragraph>
 <paragraph index="6872" node_type="writer" parent_index="6861">Literal value of any type known in the model, including primitive types. Defined via a BMM_LITERAL_VALUE.</paragraph>
 <paragraph index="6875" node_type="writer" parent_index="6861">Inherit</paragraph>
 <paragraph index="6878" node_type="writer" parent_index="6861">EL_SIMPLE</paragraph>
 <paragraph index="6881" node_type="writer" parent_index="6861">Attributes</paragraph>
 <paragraph index="6884" node_type="writer" parent_index="6861">Signature</paragraph>
 <paragraph index="6887" node_type="writer" parent_index="6861">Meaning</paragraph>
 <paragraph index="6890" node_type="writer" parent_index="6861">1..1</paragraph>
 <paragraph index="6893" node_type="writer" parent_index="6861">value: BMM_LITERAL_VALUE&lt;BMM_TYPE&gt;</paragraph>
 <paragraph index="6896" node_type="writer" parent_index="6861">The reference item from which the value of this node can be computed.</paragraph>
 <paragraph index="6899" node_type="writer" parent_index="6861">Functions</paragraph>
 <paragraph index="6902" node_type="writer" parent_index="6861">Signature</paragraph>
 <paragraph index="6905" node_type="writer" parent_index="6861">Meaning</paragraph>
 <paragraph index="6908" node_type="writer" parent_index="6861">1..1
(effected)</paragraph>
 <paragraph index="6911" node_type="writer" parent_index="6861">eval_type (): BMM_TYPE</paragraph>
 <paragraph index="6914" node_type="writer" parent_index="6861">Return value.type.</paragraph>
 <paragraph index="6917" node_type="writer" parent_index="435">10.6.7. EL_VARIABLE Class</paragraph>
 <object index="6918" name="Table90" object_type="table"/>
 <paragraph index="6920" node_type="writer" parent_index="6918">Class</paragraph>
 <paragraph index="6923" node_type="writer" parent_index="6918">EL_VARIABLE (abstract)</paragraph>
 <paragraph index="6926" node_type="writer" parent_index="6918">Description</paragraph>
 <paragraph index="6929" node_type="writer" parent_index="6918">Abstract meta-type of any kind of symbolic variable.</paragraph>
 <paragraph index="6932" node_type="writer" parent_index="6918">Inherit</paragraph>
 <paragraph index="6935" node_type="writer" parent_index="6918">EL_VALUE_GENERATOR</paragraph>
 <paragraph index="6938" node_type="writer" parent_index="435">10.6.8. EL_WRITABLE_VARIABLE Class</paragraph>
 <object index="6939" name="Table91" object_type="table"/>
 <paragraph index="6941" node_type="writer" parent_index="6939">Class</paragraph>
 <paragraph index="6944" node_type="writer" parent_index="6939">EL_WRITABLE_VARIABLE</paragraph>
 <paragraph index="6947" node_type="writer" parent_index="6939">Description</paragraph>
 <paragraph index="6950" node_type="writer" parent_index="6939">Meta-type of writable variables, including routine locals and the special variable 'Result'.</paragraph>
 <paragraph index="6953" node_type="writer" parent_index="6939">Inherit</paragraph>
 <paragraph index="6956" node_type="writer" parent_index="6939">EL_VARIABLE</paragraph>
 <paragraph index="6959" node_type="writer" parent_index="6939">Attributes</paragraph>
 <paragraph index="6962" node_type="writer" parent_index="6939">Signature</paragraph>
 <paragraph index="6965" node_type="writer" parent_index="6939">Meaning</paragraph>
 <paragraph index="6968" node_type="writer" parent_index="6939">1..1</paragraph>
 <paragraph index="6971" node_type="writer" parent_index="6939">definition: BMM_WRITABLE_VARIABLE</paragraph>
 <paragraph index="6974" node_type="writer" parent_index="6939">Variable definition to which this reference refers.</paragraph>
 <paragraph index="6977" node_type="writer" parent_index="6939">1..1
(redefined)</paragraph>
 <paragraph index="6980" node_type="writer" parent_index="6939">is_writable: Boolean
{default = true}</paragraph>
 <paragraph index="6983" node_type="writer" parent_index="6939">Defined to return True in all cases.</paragraph>
 <paragraph index="6986" node_type="writer" parent_index="435">10.6.9. EL_READONLY_VARIABLE Class</paragraph>
 <object index="6987" name="Table92" object_type="table"/>
 <paragraph index="6989" node_type="writer" parent_index="6987">Class</paragraph>
 <paragraph index="6992" node_type="writer" parent_index="6987">EL_READONLY_VARIABLE</paragraph>
 <paragraph index="6995" node_type="writer" parent_index="6987">Description</paragraph>
 <paragraph index="6998" node_type="writer" parent_index="6987">Meta-type of read-only variables, including routine parameter and the special variable 'Self'.</paragraph>
 <paragraph index="7001" node_type="writer" parent_index="6987">Inherit</paragraph>
 <paragraph index="7004" node_type="writer" parent_index="6987">EL_VARIABLE</paragraph>
 <paragraph index="7007" node_type="writer" parent_index="6987">Attributes</paragraph>
 <paragraph index="7010" node_type="writer" parent_index="6987">Signature</paragraph>
 <paragraph index="7013" node_type="writer" parent_index="6987">Meaning</paragraph>
 <paragraph index="7016" node_type="writer" parent_index="6987">1..1</paragraph>
 <paragraph index="7019" node_type="writer" parent_index="6987">definition: BMM_READONLY_VARIABLE</paragraph>
 <paragraph index="7022" node_type="writer" parent_index="6987">Variable definition to which this reference refers.</paragraph>
 <paragraph index="7025" node_type="writer" parent_index="6987">1..1
(redefined)</paragraph>
 <paragraph index="7028" node_type="writer" parent_index="6987">is_writable: Boolean
{default = false}</paragraph>
 <paragraph index="7031" node_type="writer" parent_index="6987">Defined to return False in all cases.</paragraph>
 <paragraph index="7034" node_type="writer" parent_index="435">10.6.10. EL_FEATURE_REF Class</paragraph>
 <object index="7035" name="Table93" object_type="table"/>
 <paragraph index="7037" node_type="writer" parent_index="7035">Class</paragraph>
 <paragraph index="7040" node_type="writer" parent_index="7035">EL_FEATURE_REF (abstract)</paragraph>
 <paragraph index="7043" node_type="writer" parent_index="7035">Description</paragraph>
 <paragraph index="7046" node_type="writer" parent_index="7035">A reference that is scoped by a containing entity and requires a context qualifier if it is not the currently scoping entity.</paragraph>
 <paragraph index="7049" node_type="writer" parent_index="7035">Inherit</paragraph>
 <paragraph index="7052" node_type="writer" parent_index="7035">EL_VALUE_GENERATOR</paragraph>
 <paragraph index="7055" node_type="writer" parent_index="7035">Attributes</paragraph>
 <paragraph index="7058" node_type="writer" parent_index="7035">Signature</paragraph>
 <paragraph index="7061" node_type="writer" parent_index="7035">Meaning</paragraph>
 <paragraph index="7064" node_type="writer" parent_index="7035">0..1</paragraph>
 <paragraph index="7067" node_type="writer" parent_index="7035">scoper: EL_VALUE_GENERATOR</paragraph>
 <paragraph index="7070" node_type="writer" parent_index="7035">Scoping expression, which must be a EL_VALUE_GENERATOR.</paragraph>
 <paragraph index="7073" node_type="writer" parent_index="7035">Functions</paragraph>
 <paragraph index="7076" node_type="writer" parent_index="7035">Signature</paragraph>
 <paragraph index="7079" node_type="writer" parent_index="7035">Meaning</paragraph>
 <paragraph index="7082" node_type="writer" parent_index="7035">1..1
(redefined)</paragraph>
 <paragraph index="7085" node_type="writer" parent_index="7035">reference (): String</paragraph>
 <paragraph index="7088" node_type="writer" parent_index="7035">Generated full reference name, consisting of scoping elements and name concatenated using dot notation.</paragraph>
 <paragraph index="7091" node_type="writer" parent_index="435">10.6.11. EL_PROPERTY_REF Class</paragraph>
 <object index="7092" name="Table94" object_type="table"/>
 <paragraph index="7094" node_type="writer" parent_index="7092">Class</paragraph>
 <paragraph index="7097" node_type="writer" parent_index="7092">EL_PROPERTY_REF</paragraph>
 <paragraph index="7100" node_type="writer" parent_index="7092">Description</paragraph>
 <paragraph index="7103" node_type="writer" parent_index="7092">Reference to a writable property.</paragraph>
 <paragraph index="7106" node_type="writer" parent_index="7092">Inherit</paragraph>
 <paragraph index="7109" node_type="writer" parent_index="7092">EL_FEATURE_REF</paragraph>
 <paragraph index="7112" node_type="writer" parent_index="7092">Attributes</paragraph>
 <paragraph index="7115" node_type="writer" parent_index="7092">Signature</paragraph>
 <paragraph index="7118" node_type="writer" parent_index="7092">Meaning</paragraph>
 <paragraph index="7121" node_type="writer" parent_index="7092">1..1</paragraph>
 <paragraph index="7124" node_type="writer" parent_index="7092">definition: BMM_PROPERTY</paragraph>
 <paragraph index="7127" node_type="writer" parent_index="7092">Property definition (within class).</paragraph>
 <paragraph index="7130" node_type="writer" parent_index="7092">1..1
(redefined)</paragraph>
 <paragraph index="7133" node_type="writer" parent_index="7092">is_writable: Boolean
{default = true}</paragraph>
 <paragraph index="7136" node_type="writer" parent_index="7092">Defined to return True.</paragraph>
 <paragraph index="7139" node_type="writer" parent_index="7092">Functions</paragraph>
 <paragraph index="7142" node_type="writer" parent_index="7092">Signature</paragraph>
 <paragraph index="7145" node_type="writer" parent_index="7092">Meaning</paragraph>
 <paragraph index="7148" node_type="writer" parent_index="7092">1..1
(effected)</paragraph>
 <paragraph index="7151" node_type="writer" parent_index="7092">eval_type (): BMM_TYPE</paragraph>
 <paragraph index="7154" node_type="writer" parent_index="7092">Type definition (i.e. BMM meta-type definition object) of the constant, property or variable, inferred by inspection of the current scoping instance. Return definition.type.</paragraph>
 <paragraph index="7157" node_type="writer" parent_index="435">10.6.12. EL_STATIC_REF Class</paragraph>
 <object index="7158" name="Table95" object_type="table"/>
 <paragraph index="7160" node_type="writer" parent_index="7158">Class</paragraph>
 <paragraph index="7163" node_type="writer" parent_index="7158">EL_STATIC_REF</paragraph>
 <paragraph index="7166" node_type="writer" parent_index="7158">Description</paragraph>
 <paragraph index="7169" node_type="writer" parent_index="7158">Reference to a writable property, either a constant or computed.</paragraph>
 <paragraph index="7172" node_type="writer" parent_index="7158">Inherit</paragraph>
 <paragraph index="7175" node_type="writer" parent_index="7158">EL_FEATURE_REF</paragraph>
 <paragraph index="7178" node_type="writer" parent_index="7158">Attributes</paragraph>
 <paragraph index="7181" node_type="writer" parent_index="7158">Signature</paragraph>
 <paragraph index="7184" node_type="writer" parent_index="7158">Meaning</paragraph>
 <paragraph index="7187" node_type="writer" parent_index="7158">1..1</paragraph>
 <paragraph index="7190" node_type="writer" parent_index="7158">definition: BMM_STATIC</paragraph>
 <paragraph index="7193" node_type="writer" parent_index="7158">Constant definition (within class).</paragraph>
 <paragraph index="7196" node_type="writer" parent_index="7158">1..1
(redefined)</paragraph>
 <paragraph index="7199" node_type="writer" parent_index="7158">is_writable: Boolean
{default = false}</paragraph>
 <paragraph index="7202" node_type="writer" parent_index="7158">Defined to return False.</paragraph>
 <paragraph index="7205" node_type="writer" parent_index="435">10.6.13. EL_AGENT_CALL Class</paragraph>
 <object index="7206" name="Table96" object_type="table"/>
 <paragraph index="7208" node_type="writer" parent_index="7206">Class</paragraph>
 <paragraph index="7211" node_type="writer" parent_index="7206">EL_AGENT_CALL (abstract)</paragraph>
 <paragraph index="7214" node_type="writer" parent_index="7206">Description</paragraph>
 <paragraph index="7217" node_type="writer" parent_index="7206">A call made to a 'closed' agent, i.e. one with no remaining open arguments.</paragraph>
 <paragraph index="7220" node_type="writer" parent_index="7206">Attributes</paragraph>
 <paragraph index="7223" node_type="writer" parent_index="7206">Signature</paragraph>
 <paragraph index="7226" node_type="writer" parent_index="7206">Meaning</paragraph>
 <paragraph index="7229" node_type="writer" parent_index="7206">1..1</paragraph>
 <paragraph index="7232" node_type="writer" parent_index="7206">agent: EL_AGENT</paragraph>
 <paragraph index="7235" node_type="writer" parent_index="7206">The agent being called.</paragraph>
 <paragraph index="7238" node_type="writer" parent_index="7206">Invariants</paragraph>
 <paragraph index="7241" node_type="writer" parent_index="7206">Inv_valid_call: agent.is_callable()</paragraph>
 <paragraph index="7244" node_type="writer" parent_index="435">10.6.14. EL_FUNCTION_CALL Class</paragraph>
 <object index="7245" name="Table97" object_type="table"/>
 <paragraph index="7247" node_type="writer" parent_index="7245">Class</paragraph>
 <paragraph index="7250" node_type="writer" parent_index="7245">EL_FUNCTION_CALL</paragraph>
 <paragraph index="7253" node_type="writer" parent_index="7245">Description</paragraph>
 <paragraph index="7256" node_type="writer" parent_index="7245">A call made on a closed function agent, returning a result. Equivalent to an 'application' of a function in Lambda calculus.</paragraph>
 <paragraph index="7259" node_type="writer" parent_index="7245">Inherit</paragraph>
 <paragraph index="7262" node_type="writer" parent_index="7245">EL_FEATURE_REF, EL_AGENT_CALL</paragraph>
 <paragraph index="7265" node_type="writer" parent_index="7245">Attributes</paragraph>
 <paragraph index="7268" node_type="writer" parent_index="7245">Signature</paragraph>
 <paragraph index="7271" node_type="writer" parent_index="7245">Meaning</paragraph>
 <paragraph index="7274" node_type="writer" parent_index="7245">1..1
(redefined)</paragraph>
 <paragraph index="7277" node_type="writer" parent_index="7245">agent: EL_FUNCTION_AGENT</paragraph>
 <paragraph index="7280" node_type="writer" parent_index="7245">The function agent being called.</paragraph>
 <paragraph index="7283" node_type="writer" parent_index="7245">1..1
(redefined)</paragraph>
 <paragraph index="7286" node_type="writer" parent_index="7245">is_writable: Boolean
{default = false}</paragraph>
 <paragraph index="7289" node_type="writer" parent_index="7245">Defined to return False.</paragraph>
 <paragraph index="7292" node_type="writer" parent_index="7245">Functions</paragraph>
 <paragraph index="7295" node_type="writer" parent_index="7245">Signature</paragraph>
 <paragraph index="7298" node_type="writer" parent_index="7245">Meaning</paragraph>
 <paragraph index="7301" node_type="writer" parent_index="7245">1..1
(effected)</paragraph>
 <paragraph index="7304" node_type="writer" parent_index="7245">eval_type (): BMM_TYPE</paragraph>
 <paragraph index="7307" node_type="writer" parent_index="7245">Return agent.definition.type.</paragraph>
 <paragraph index="7310" node_type="writer" parent_index="7245">1..1
(redefined)</paragraph>
 <paragraph index="7313" node_type="writer" parent_index="7245">reference (): String</paragraph>
 <paragraph index="7316" node_type="writer" parent_index="7245">Generated full reference name, consisting of any scoping elements, function name and routine parameters enclosed in parentheses.</paragraph>
 <paragraph index="7319" node_type="writer" parent_index="7245">Invariants</paragraph>
 <paragraph index="7322" node_type="writer" parent_index="7245">Inv_valid_agent: agent.is_callable()</paragraph>
 <paragraph index="7325" node_type="writer" parent_index="435">10.6.15. EL_AGENT Class</paragraph>
 <object index="7326" name="Table98" object_type="table"/>
 <paragraph index="7328" node_type="writer" parent_index="7326">Class</paragraph>
 <paragraph index="7331" node_type="writer" parent_index="7326">EL_AGENT (abstract)</paragraph>
 <paragraph index="7334" node_type="writer" parent_index="7326">Description</paragraph>
 <paragraph index="7337" node_type="writer" parent_index="7326">A delayed routine call, whose arguments may be open, partially closed or closed. Generated by special reference to a routine, usually via a dedicated keyword, such as 'lambda' or 'agent', or other special syntax.</paragraph>
 <paragraph index="7338" node_type="writer" parent_index="7326">Instances may include closed delayed calls like calculate_age (dob=&quot;1987-09-13&quot;, today=&quot;2019-06-03&quot;) but also partially open calls such as format_structure (struct=?, style=3), where struct is an open argument.</paragraph>
 <paragraph index="7339" node_type="writer" parent_index="7326">Evaluation type (i.e. type of runtime evaluated form) is BMM_SIGNATURE.</paragraph>
 <paragraph index="7342" node_type="writer" parent_index="7326">Inherit</paragraph>
 <paragraph index="7345" node_type="writer" parent_index="7326">EL_FEATURE_REF</paragraph>
 <paragraph index="7348" node_type="writer" parent_index="7326">Attributes</paragraph>
 <paragraph index="7351" node_type="writer" parent_index="7326">Signature</paragraph>
 <paragraph index="7354" node_type="writer" parent_index="7326">Meaning</paragraph>
 <paragraph index="7357" node_type="writer" parent_index="7326">0..1</paragraph>
 <paragraph index="7360" node_type="writer" parent_index="7326">closed_args: EL_TUPLE</paragraph>
 <paragraph index="7363" node_type="writer" parent_index="7326">Closed arguments of a routine call as a tuple of objects.</paragraph>
 <paragraph index="7366" node_type="writer" parent_index="7326">0..1</paragraph>
 <paragraph index="7369" node_type="writer" parent_index="7326">open_args: List&lt;String&gt;</paragraph>
 <paragraph index="7372" node_type="writer" parent_index="7326">Optional list of names of open arguments of the call. If not provided, and the name refers to a routine with more arguments than supplied in closed_args, the missing arguments are inferred from the definition.</paragraph>
 <paragraph index="7375" node_type="writer" parent_index="7326">0..1</paragraph>
 <paragraph index="7378" node_type="writer" parent_index="7326">definition: BMM_ROUTINE</paragraph>
 <paragraph index="7381" node_type="writer" parent_index="7326">Reference to definition of a routine for which this is an agent, if one exists.</paragraph>
 <paragraph index="7384" node_type="writer" parent_index="7326">1..1
(redefined)</paragraph>
 <paragraph index="7387" node_type="writer" parent_index="7326">name: String</paragraph>
 <paragraph index="7390" node_type="writer" parent_index="7326">Name of the routine being called.</paragraph>
 <paragraph index="7393" node_type="writer" parent_index="7326">1..1
(redefined)</paragraph>
 <paragraph index="7396" node_type="writer" parent_index="7326">is_writable: Boolean
{default = false}</paragraph>
 <paragraph index="7402" node_type="writer" parent_index="7326">Functions</paragraph>
 <paragraph index="7405" node_type="writer" parent_index="7326">Signature</paragraph>
 <paragraph index="7408" node_type="writer" parent_index="7326">Meaning</paragraph>
 <paragraph index="7411" node_type="writer" parent_index="7326">1..1
(effected)</paragraph>
 <paragraph index="7414" node_type="writer" parent_index="7326">eval_type (): BMM_ROUTINE_TYPE

Post_result: Result = definition.signature</paragraph>
 <paragraph index="7417" node_type="writer" parent_index="7326">Eval type is the signature corresponding to the (remaining) open arguments and return type, if any.</paragraph>
 <paragraph index="7420" node_type="writer" parent_index="7326">1..1</paragraph>
 <paragraph index="7423" node_type="writer" parent_index="7326">is_callable (): Boolean

Post_result_validity: Result = open_arguments = Void</paragraph>
 <paragraph index="7426" node_type="writer" parent_index="7326">True if there are no open arguments.</paragraph>
 <paragraph index="7429" node_type="writer" parent_index="7326">1..1
(redefined)</paragraph>
 <paragraph index="7432" node_type="writer" parent_index="7326">reference (): String</paragraph>
 <paragraph index="7435" node_type="writer" parent_index="7326">Generated full reference name, including scoping elements.</paragraph>
 <paragraph index="7438" node_type="writer" parent_index="435">10.6.16. EL_FUNCTION_AGENT Class</paragraph>
 <object index="7439" name="Table99" object_type="table"/>
 <paragraph index="7441" node_type="writer" parent_index="7439">Class</paragraph>
 <paragraph index="7444" node_type="writer" parent_index="7439">EL_FUNCTION_AGENT</paragraph>
 <paragraph index="7447" node_type="writer" parent_index="7439">Description</paragraph>
 <paragraph index="7450" node_type="writer" parent_index="7439">An agent whose signature is of a function, i.e. has a result type.</paragraph>
 <paragraph index="7453" node_type="writer" parent_index="7439">Inherit</paragraph>
 <paragraph index="7456" node_type="writer" parent_index="7439">EL_AGENT</paragraph>
 <paragraph index="7459" node_type="writer" parent_index="7439">Attributes</paragraph>
 <paragraph index="7462" node_type="writer" parent_index="7439">Signature</paragraph>
 <paragraph index="7465" node_type="writer" parent_index="7439">Meaning</paragraph>
 <paragraph index="7468" node_type="writer" parent_index="7439">0..1
(redefined)</paragraph>
 <paragraph index="7471" node_type="writer" parent_index="7439">definition: BMM_FUNCTION</paragraph>
 <paragraph index="7474" node_type="writer" parent_index="7439">Reference to definition of a routine for which this is a direct call instance, if one exists.</paragraph>
 <paragraph index="7477" node_type="writer" parent_index="7439">Functions</paragraph>
 <paragraph index="7480" node_type="writer" parent_index="7439">Signature</paragraph>
 <paragraph index="7483" node_type="writer" parent_index="7439">Meaning</paragraph>
 <paragraph index="7486" node_type="writer" parent_index="7439">1..1
(effected)</paragraph>
 <paragraph index="7489" node_type="writer" parent_index="7439">eval_type (): BMM_FUNCTION_TYPE

Post_result: Result = definition.signature</paragraph>
 <paragraph index="7492" node_type="writer" parent_index="7439">Eval type is the signature corresponding to the (remaining) open arguments and return type, if any.</paragraph>
 <paragraph index="7495" node_type="writer" parent_index="435">10.6.17. EL_PROCEDURE_AGENT Class</paragraph>
 <object index="7496" name="Table100" object_type="table"/>
 <paragraph index="7498" node_type="writer" parent_index="7496">Class</paragraph>
 <paragraph index="7501" node_type="writer" parent_index="7496">EL_PROCEDURE_AGENT</paragraph>
 <paragraph index="7504" node_type="writer" parent_index="7496">Description</paragraph>
 <paragraph index="7507" node_type="writer" parent_index="7496">An agent whose signature is of a procedure, i.e. has no result type.</paragraph>
 <paragraph index="7510" node_type="writer" parent_index="7496">Inherit</paragraph>
 <paragraph index="7513" node_type="writer" parent_index="7496">EL_AGENT</paragraph>
 <paragraph index="7516" node_type="writer" parent_index="7496">Attributes</paragraph>
 <paragraph index="7519" node_type="writer" parent_index="7496">Signature</paragraph>
 <paragraph index="7522" node_type="writer" parent_index="7496">Meaning</paragraph>
 <paragraph index="7525" node_type="writer" parent_index="7496">0..1
(redefined)</paragraph>
 <paragraph index="7528" node_type="writer" parent_index="7496">definition: BMM_PROCEDURE</paragraph>
 <paragraph index="7531" node_type="writer" parent_index="7496">Reference to definition of routine for which this is a call instance.</paragraph>
 <paragraph index="7534" node_type="writer" parent_index="7496">Functions</paragraph>
 <paragraph index="7537" node_type="writer" parent_index="7496">Signature</paragraph>
 <paragraph index="7540" node_type="writer" parent_index="7496">Meaning</paragraph>
 <paragraph index="7543" node_type="writer" parent_index="7496">1..1
(effected)</paragraph>
 <paragraph index="7546" node_type="writer" parent_index="7496">eval_type (): BMM_PROCEDURE_TYPE

Post_result: Result = definition.signature</paragraph>
 <paragraph index="7549" node_type="writer" parent_index="7496">Eval type is the signature corresponding to the (remaining) open arguments and return type, if any.</paragraph>
 <paragraph index="7552" node_type="writer" parent_index="435">10.6.18. EL_PREDICATE Class</paragraph>
 <object index="7553" name="Table101" object_type="table"/>
 <paragraph index="7555" node_type="writer" parent_index="7553">Class</paragraph>
 <paragraph index="7558" node_type="writer" parent_index="7553">EL_PREDICATE (abstract)</paragraph>
 <paragraph index="7561" node_type="writer" parent_index="7553">Description</paragraph>
 <paragraph index="7564" node_type="writer" parent_index="7553">Parent type of predicate of any object reference.</paragraph>
 <paragraph index="7567" node_type="writer" parent_index="7553">Inherit</paragraph>
 <paragraph index="7570" node_type="writer" parent_index="7553">EL_SIMPLE</paragraph>
 <paragraph index="7573" node_type="writer" parent_index="7553">Attributes</paragraph>
 <paragraph index="7576" node_type="writer" parent_index="7553">Signature</paragraph>
 <paragraph index="7579" node_type="writer" parent_index="7553">Meaning</paragraph>
 <paragraph index="7582" node_type="writer" parent_index="7553">1..1</paragraph>
 <paragraph index="7585" node_type="writer" parent_index="7553">operand: EL_VALUE_GENERATOR</paragraph>
 <paragraph index="7588" node_type="writer" parent_index="7553">The target instance of this predicate.</paragraph>
 <paragraph index="7591" node_type="writer" parent_index="7553">Functions</paragraph>
 <paragraph index="7594" node_type="writer" parent_index="7553">Signature</paragraph>
 <paragraph index="7597" node_type="writer" parent_index="7553">Meaning</paragraph>
 <paragraph index="7600" node_type="writer" parent_index="7553">1..1
(effected)</paragraph>
 <paragraph index="7603" node_type="writer" parent_index="7553">eval_type (): BMM_SIMPLE_TYPE</paragraph>
 <paragraph index="7606" node_type="writer" parent_index="7553">Return {BMM_MODEL}.boolean_type_definition().</paragraph>
 <paragraph index="7609" node_type="writer" parent_index="435">10.6.19. EL_DEFINED Class</paragraph>
 <object index="7610" name="Table102" object_type="table"/>
 <paragraph index="7612" node_type="writer" parent_index="7610">Class</paragraph>
 <paragraph index="7615" node_type="writer" parent_index="7610">EL_DEFINED</paragraph>
 <paragraph index="7618" node_type="writer" parent_index="7610">Description</paragraph>
 <paragraph index="7621" node_type="writer" parent_index="7610">A predicate taking one external variable reference argument, that returns true if the reference is resolvable, i.e. the external value is obtainable.</paragraph>
 <object index="7622" name="Table103" object_type="table"/>
 <paragraph index="7624" node_type="writer" parent_index="7622">Note</paragraph>
 <paragraph index="7627" node_type="writer" parent_index="7622">probably to be removed. </paragraph>
 <paragraph index="7633" node_type="writer" parent_index="7610">Inherit</paragraph>
 <paragraph index="7636" node_type="writer" parent_index="7610">EL_PREDICATE</paragraph>
 <paragraph index="7639" node_type="writer" parent_index="435">10.6.20. EL_ATTACHED Class</paragraph>
 <object index="7640" name="Table104" object_type="table"/>
 <paragraph index="7642" node_type="writer" parent_index="7640">Class</paragraph>
 <paragraph index="7645" node_type="writer" parent_index="7640">EL_ATTACHED</paragraph>
 <paragraph index="7648" node_type="writer" parent_index="7640">Description</paragraph>
 <paragraph index="7651" node_type="writer" parent_index="7640">A predicate on any object reference (including function call) that returns True if the reference is attached, i.e. non-Void.</paragraph>
 <paragraph index="7654" node_type="writer" parent_index="7640">Inherit</paragraph>
 <paragraph index="7657" node_type="writer" parent_index="7640">EL_PREDICATE</paragraph>
 <paragraph index="7660" node_type="writer" parent_index="435">10.6.21. EL_DECISION_TABLE Class</paragraph>
 <object index="7661" name="Table105" object_type="table"/>
 <paragraph index="7663" node_type="writer" parent_index="7661">Class</paragraph>
 <paragraph index="7666" node_type="writer" parent_index="7661">EL_DECISION_TABLE&lt;T&gt; (abstract)</paragraph>
 <paragraph index="7669" node_type="writer" parent_index="7661">Description</paragraph>
 <paragraph index="7672" node_type="writer" parent_index="7661">Meta-type for decision tables. Generic on the meta-type of the result attribute of the branches, to allow specialised forms of if/else and case structures to be created.</paragraph>
 <paragraph index="7675" node_type="writer" parent_index="7661">Inherit</paragraph>
 <paragraph index="7678" node_type="writer" parent_index="7661">EL_TERMINAL</paragraph>
 <paragraph index="7681" node_type="writer" parent_index="7661">Attributes</paragraph>
 <paragraph index="7684" node_type="writer" parent_index="7661">Signature</paragraph>
 <paragraph index="7687" node_type="writer" parent_index="7661">Meaning</paragraph>
 <paragraph index="7690" node_type="writer" parent_index="7661">1..1</paragraph>
 <paragraph index="7693" node_type="writer" parent_index="7661">items: List&lt;EL_DECISION_BRANCH&gt;</paragraph>
 <paragraph index="7696" node_type="writer" parent_index="7661">Members of the chain, equivalent to branches in an if/then/else chain and cases in a case statement.</paragraph>
 <paragraph index="7699" node_type="writer" parent_index="7661">1..1</paragraph>
 <paragraph index="7702" node_type="writer" parent_index="7661">else: T</paragraph>
 <paragraph index="7705" node_type="writer" parent_index="7661">Result expression of conditional, if its condition evaluates to True.</paragraph>
 <paragraph index="7708" node_type="writer" parent_index="435">10.6.22. EL_DECISION_BRANCH Class</paragraph>
 <object index="7709" name="Table106" object_type="table"/>
 <paragraph index="7711" node_type="writer" parent_index="7709">Class</paragraph>
 <paragraph index="7714" node_type="writer" parent_index="7709">EL_DECISION_BRANCH&lt;T&gt; (abstract)</paragraph>
 <paragraph index="7717" node_type="writer" parent_index="7709">Description</paragraph>
 <paragraph index="7720" node_type="writer" parent_index="7709">Abstract parent of meta-types representing a branch of some kind of decision structure. Defines result as being of the generic type T.</paragraph>
 <paragraph index="7723" node_type="writer" parent_index="7709">Attributes</paragraph>
 <paragraph index="7726" node_type="writer" parent_index="7709">Signature</paragraph>
 <paragraph index="7729" node_type="writer" parent_index="7709">Meaning</paragraph>
 <paragraph index="7732" node_type="writer" parent_index="7709">1..1</paragraph>
 <paragraph index="7735" node_type="writer" parent_index="7709">result: T</paragraph>
 <paragraph index="7738" node_type="writer" parent_index="7709">Result expression of conditional, if its condition evaluates to True.</paragraph>
 <paragraph index="7741" node_type="writer" parent_index="435">10.6.23. EL_CONDITION_CHAIN Class</paragraph>
 <object index="7742" name="Table107" object_type="table"/>
 <paragraph index="7744" node_type="writer" parent_index="7742">Class</paragraph>
 <paragraph index="7747" node_type="writer" parent_index="7742">EL_CONDITION_CHAIN&lt;T&gt;</paragraph>
 <paragraph index="7750" node_type="writer" parent_index="7742">Description</paragraph>
 <paragraph index="7753" node_type="writer" parent_index="7742">Compound expression consisting of a chain of condition-gated expressions, and an ungated else member that as a whole, represents an if/then/elseif/else chains.</paragraph>
 <paragraph index="7754" node_type="writer" parent_index="7742">Evaluated by iterating through items and for each one, evaluating its condition, which if True, causes the evaluation result of the chain to be that item’s result evaluation result.</paragraph>
 <paragraph index="7755" node_type="writer" parent_index="7742">If no member of items has a True-returning condition, the evaluation result is the result of evaluating the else expression.</paragraph>
 <paragraph index="7758" node_type="writer" parent_index="7742">Inherit</paragraph>
 <paragraph index="7761" node_type="writer" parent_index="7742">EL_DECISION_TABLE</paragraph>
 <paragraph index="7764" node_type="writer" parent_index="7742">Attributes</paragraph>
 <paragraph index="7767" node_type="writer" parent_index="7742">Signature</paragraph>
 <paragraph index="7770" node_type="writer" parent_index="7742">Meaning</paragraph>
 <paragraph index="7773" node_type="writer" parent_index="7742">1..1
(redefined)</paragraph>
 <paragraph index="7776" node_type="writer" parent_index="7742">items: List&lt;EL_CONDITIONAL_EXPRESSION&gt;</paragraph>
 <paragraph index="7779" node_type="writer" parent_index="7742">Members of the chain, equivalent to branches in an if/then/else chain and cases in a case statement.</paragraph>
 <paragraph index="7782" node_type="writer" parent_index="435">10.6.24. EL_CONDITIONAL_EXPRESSION Class</paragraph>
 <object index="7783" name="Table108" object_type="table"/>
 <paragraph index="7785" node_type="writer" parent_index="7783">Class</paragraph>
 <paragraph index="7788" node_type="writer" parent_index="7783">EL_CONDITIONAL_EXPRESSION&lt;T&gt;</paragraph>
 <paragraph index="7791" node_type="writer" parent_index="7783">Description</paragraph>
 <paragraph index="7794" node_type="writer" parent_index="7783">Conditional structure used in condition chain expressions. Evaluated by evaluating its condition, which is a Boolean-returning expression, and if this returns True, the result is the evaluation result of expression.</paragraph>
 <paragraph index="7797" node_type="writer" parent_index="7783">Inherit</paragraph>
 <paragraph index="7800" node_type="writer" parent_index="7783">EL_DECISION_BRANCH</paragraph>
 <paragraph index="7803" node_type="writer" parent_index="7783">Attributes</paragraph>
 <paragraph index="7806" node_type="writer" parent_index="7783">Signature</paragraph>
 <paragraph index="7809" node_type="writer" parent_index="7783">Meaning</paragraph>
 <paragraph index="7812" node_type="writer" parent_index="7783">1..1</paragraph>
 <paragraph index="7815" node_type="writer" parent_index="7783">condition: EL_EXPRESSION</paragraph>
 <paragraph index="7818" node_type="writer" parent_index="7783">Boolean expression defining the condition of this decision branch.</paragraph>
 <paragraph index="7821" node_type="writer" parent_index="7783">Invariants</paragraph>
 <paragraph index="7824" node_type="writer" parent_index="7783">Inv_condition_boolean: condition.is_boolean()</paragraph>
 <paragraph index="7827" node_type="writer" parent_index="435">10.6.25. EL_CASE_TABLE Class</paragraph>
 <object index="7828" name="Table109" object_type="table"/>
 <paragraph index="7830" node_type="writer" parent_index="7828">Class</paragraph>
 <paragraph index="7833" node_type="writer" parent_index="7828">EL_CASE_TABLE&lt;T&gt;</paragraph>
 <paragraph index="7836" node_type="writer" parent_index="7828">Description</paragraph>
 <paragraph index="7839" node_type="writer" parent_index="7828">Compound expression consisting of a list of value-range / expression pairs, and an else member that as a whole, represents a case statement flavour of decision table.</paragraph>
 <paragraph index="7840" node_type="writer" parent_index="7828">Evaluated by iterating through items and for each one, comparing input to the item value_range. If the input is in the range, the evaluation result of the table is that item’s result evaluation result.</paragraph>
 <paragraph index="7841" node_type="writer" parent_index="7828">If no member of items has a True-returning condition, the evaluation result is the result of evaluating the else expression.</paragraph>
 <paragraph index="7844" node_type="writer" parent_index="7828">Inherit</paragraph>
 <paragraph index="7847" node_type="writer" parent_index="7828">EL_DECISION_TABLE</paragraph>
 <paragraph index="7850" node_type="writer" parent_index="7828">Attributes</paragraph>
 <paragraph index="7853" node_type="writer" parent_index="7828">Signature</paragraph>
 <paragraph index="7856" node_type="writer" parent_index="7828">Meaning</paragraph>
 <paragraph index="7859" node_type="writer" parent_index="7828">1..1</paragraph>
 <paragraph index="7862" node_type="writer" parent_index="7828">test_value: EL_VALUE_GENERATOR</paragraph>
 <paragraph index="7865" node_type="writer" parent_index="7828">Expressing generating the input value for the case table.</paragraph>
 <paragraph index="7868" node_type="writer" parent_index="7828">1..1
(redefined)</paragraph>
 <paragraph index="7871" node_type="writer" parent_index="7828">items: List&lt;EL_CASE&gt;</paragraph>
 <paragraph index="7874" node_type="writer" parent_index="7828">Members of the chain, equivalent to branches in an if/then/else chain and cases in a case statement.</paragraph>
 <paragraph index="7877" node_type="writer" parent_index="435">10.6.26. EL_CASE Class</paragraph>
 <object index="7878" name="Table110" object_type="table"/>
 <paragraph index="7880" node_type="writer" parent_index="7878">Class</paragraph>
 <paragraph index="7883" node_type="writer" parent_index="7878">EL_CASE&lt;T&gt;</paragraph>
 <paragraph index="7886" node_type="writer" parent_index="7878">Description</paragraph>
 <paragraph index="7889" node_type="writer" parent_index="7878">One branch of a Case table, consisting of a value constraint (the match criterion) and a result, of the generic parameter type T.</paragraph>
 <paragraph index="7892" node_type="writer" parent_index="7878">Inherit</paragraph>
 <paragraph index="7895" node_type="writer" parent_index="7878">EL_DECISION_BRANCH</paragraph>
 <paragraph index="7898" node_type="writer" parent_index="7878">Attributes</paragraph>
 <paragraph index="7901" node_type="writer" parent_index="7878">Signature</paragraph>
 <paragraph index="7904" node_type="writer" parent_index="7878">Meaning</paragraph>
 <paragraph index="7907" node_type="writer" parent_index="7878">1..1</paragraph>
 <paragraph index="7910" node_type="writer" parent_index="7878">value_constraint: C_OBJECT</paragraph>
 <paragraph index="7913" node_type="writer" parent_index="7878">Constraint on</paragraph>
 <paragraph index="7916" node_type="writer" parent_index="435">10.6.27. EL_OPERATOR Class</paragraph>
 <object index="7917" name="Table111" object_type="table"/>
 <paragraph index="7919" node_type="writer" parent_index="7917">Class</paragraph>
 <paragraph index="7922" node_type="writer" parent_index="7917">EL_OPERATOR (abstract)</paragraph>
 <paragraph index="7925" node_type="writer" parent_index="7917">Description</paragraph>
 <paragraph index="7928" node_type="writer" parent_index="7917">Abstract parent of operator types.</paragraph>
 <paragraph index="7931" node_type="writer" parent_index="7917">Inherit</paragraph>
 <paragraph index="7934" node_type="writer" parent_index="7917">EL_EXPRESSION</paragraph>
 <paragraph index="7937" node_type="writer" parent_index="7917">Attributes</paragraph>
 <paragraph index="7940" node_type="writer" parent_index="7917">Signature</paragraph>
 <paragraph index="7943" node_type="writer" parent_index="7917">Meaning</paragraph>
 <paragraph index="7946" node_type="writer" parent_index="7917">0..1</paragraph>
 <paragraph index="7949" node_type="writer" parent_index="7917">precedence_overridden: Boolean</paragraph>
 <paragraph index="7952" node_type="writer" parent_index="7917">True if the natural precedence of operators is overridden in the expression represented by this node of the expression tree. If True, parentheses should be introduced around the totality of the syntax expression corresponding to this operator node and its operands.</paragraph>
 <paragraph index="7955" node_type="writer" parent_index="7917">0..1</paragraph>
 <paragraph index="7958" node_type="writer" parent_index="7917">symbol: String</paragraph>
 <paragraph index="7961" node_type="writer" parent_index="7917">The symbol actually used in the expression, or intended to be used for serialisation. Must be a member of OPERATOR_DEF.symbols.</paragraph>
 <paragraph index="7964" node_type="writer" parent_index="7917">1..1</paragraph>
 <paragraph index="7967" node_type="writer" parent_index="7917">call: EL_FUNCTION_CALL</paragraph>
 <paragraph index="7970" node_type="writer" parent_index="7917">Function call equivalent to this operator expression, inferred by matching operator against functions defined in interface of principal operand.</paragraph>
 <paragraph index="7973" node_type="writer" parent_index="7917">Functions</paragraph>
 <paragraph index="7976" node_type="writer" parent_index="7917">Signature</paragraph>
 <paragraph index="7979" node_type="writer" parent_index="7917">Meaning</paragraph>
 <paragraph index="7982" node_type="writer" parent_index="7917">1..1</paragraph>
 <paragraph index="7985" node_type="writer" parent_index="7917">operator_definition (): BMM_OPERATOR</paragraph>
 <paragraph index="7988" node_type="writer" parent_index="7917">Operator definition derived from definition.operator_definition().</paragraph>
 <paragraph index="7991" node_type="writer" parent_index="7917">1..1</paragraph>
 <paragraph index="7994" node_type="writer" parent_index="7917">equivalent_call (): EL_FUNCTION_CALL</paragraph>
 <paragraph index="7997" node_type="writer" parent_index="7917">Function call equivalent to this operator.</paragraph>
 <paragraph index="8000" node_type="writer" parent_index="435">10.6.28. EL_UNARY_OPERATOR Class</paragraph>
 <object index="8001" name="Table112" object_type="table"/>
 <paragraph index="8003" node_type="writer" parent_index="8001">Class</paragraph>
 <paragraph index="8006" node_type="writer" parent_index="8001">EL_UNARY_OPERATOR</paragraph>
 <paragraph index="8009" node_type="writer" parent_index="8001">Description</paragraph>
 <paragraph index="8012" node_type="writer" parent_index="8001">Unary operator expression node.</paragraph>
 <paragraph index="8015" node_type="writer" parent_index="8001">Inherit</paragraph>
 <paragraph index="8018" node_type="writer" parent_index="8001">EL_OPERATOR</paragraph>
 <paragraph index="8021" node_type="writer" parent_index="8001">Attributes</paragraph>
 <paragraph index="8024" node_type="writer" parent_index="8001">Signature</paragraph>
 <paragraph index="8027" node_type="writer" parent_index="8001">Meaning</paragraph>
 <paragraph index="8030" node_type="writer" parent_index="8001">1..1</paragraph>
 <paragraph index="8033" node_type="writer" parent_index="8001">operand: EL_EXPRESSION</paragraph>
 <paragraph index="8036" node_type="writer" parent_index="8001">Operand node.</paragraph>
 <paragraph index="8039" node_type="writer" parent_index="435">10.6.29. EL_BINARY_OPERATOR Class</paragraph>
 <object index="8040" name="Table113" object_type="table"/>
 <paragraph index="8042" node_type="writer" parent_index="8040">Class</paragraph>
 <paragraph index="8045" node_type="writer" parent_index="8040">EL_BINARY_OPERATOR</paragraph>
 <paragraph index="8048" node_type="writer" parent_index="8040">Description</paragraph>
 <paragraph index="8051" node_type="writer" parent_index="8040">Binary operator expression node.</paragraph>
 <paragraph index="8054" node_type="writer" parent_index="8040">Inherit</paragraph>
 <paragraph index="8057" node_type="writer" parent_index="8040">EL_OPERATOR</paragraph>
 <paragraph index="8060" node_type="writer" parent_index="8040">Attributes</paragraph>
 <paragraph index="8063" node_type="writer" parent_index="8040">Signature</paragraph>
 <paragraph index="8066" node_type="writer" parent_index="8040">Meaning</paragraph>
 <paragraph index="8069" node_type="writer" parent_index="8040">1..1</paragraph>
 <paragraph index="8072" node_type="writer" parent_index="8040">left_operand: EL_EXPRESSION</paragraph>
 <paragraph index="8075" node_type="writer" parent_index="8040">Left operand node.</paragraph>
 <paragraph index="8078" node_type="writer" parent_index="8040">1..1</paragraph>
 <paragraph index="8081" node_type="writer" parent_index="8040">right_operand: EL_EXPRESSION</paragraph>
 <paragraph index="8084" node_type="writer" parent_index="8040">Right operand node.</paragraph>
 <paragraph index="8087" node_type="writer" parent_index="435">10.6.30. EL_TUPLE Class</paragraph>
 <object index="8088" name="Table114" object_type="table"/>
 <paragraph index="8090" node_type="writer" parent_index="8088">Class</paragraph>
 <paragraph index="8093" node_type="writer" parent_index="8088">EL_TUPLE</paragraph>
 <paragraph index="8096" node_type="writer" parent_index="8088">Description</paragraph>
 <paragraph index="8099" node_type="writer" parent_index="8088">Defines an array of optionally named items each of any type.</paragraph>
 <paragraph index="8102" node_type="writer" parent_index="8088">Inherit</paragraph>
 <paragraph index="8105" node_type="writer" parent_index="8088">EL_EXPRESSION</paragraph>
 <paragraph index="8108" node_type="writer" parent_index="8088">Attributes</paragraph>
 <paragraph index="8111" node_type="writer" parent_index="8088">Signature</paragraph>
 <paragraph index="8114" node_type="writer" parent_index="8088">Meaning</paragraph>
 <paragraph index="8117" node_type="writer" parent_index="8088">0..1</paragraph>
 <paragraph index="8120" node_type="writer" parent_index="8088">items: List&lt;EL_TUPLE_ITEM&gt;</paragraph>
 <paragraph index="8123" node_type="writer" parent_index="8088">Items in the tuple, potentially with names. Typical use is to represent an argument list to routine call.</paragraph>
 <paragraph index="8126" node_type="writer" parent_index="8088">1..1</paragraph>
 <paragraph index="8129" node_type="writer" parent_index="8088">type: BMM_TUPLE_TYPE</paragraph>
 <paragraph index="8132" node_type="writer" parent_index="8088">Static type inferred from literal value.</paragraph>
 <paragraph index="8135" node_type="writer" parent_index="8088">Functions</paragraph>
 <paragraph index="8138" node_type="writer" parent_index="8088">Signature</paragraph>
 <paragraph index="8141" node_type="writer" parent_index="8088">Meaning</paragraph>
 <paragraph index="8144" node_type="writer" parent_index="8088">1..1
(effected)</paragraph>
 <paragraph index="8147" node_type="writer" parent_index="8088">eval_type (): BMM_TYPE</paragraph>
 <paragraph index="8150" node_type="writer" parent_index="8088">Return type.</paragraph>
 <paragraph index="8153" node_type="writer" parent_index="435">10.6.31. EL_TUPLE_ITEM Class</paragraph>
 <object index="8154" name="Table115" object_type="table"/>
 <paragraph index="8156" node_type="writer" parent_index="8154">Class</paragraph>
 <paragraph index="8159" node_type="writer" parent_index="8154">EL_TUPLE_ITEM</paragraph>
 <paragraph index="8162" node_type="writer" parent_index="8154">Description</paragraph>
 <paragraph index="8165" node_type="writer" parent_index="8154">A single tuple item, with an optional name.</paragraph>
 <paragraph index="8168" node_type="writer" parent_index="8154">Attributes</paragraph>
 <paragraph index="8171" node_type="writer" parent_index="8154">Signature</paragraph>
 <paragraph index="8174" node_type="writer" parent_index="8154">Meaning</paragraph>
 <paragraph index="8177" node_type="writer" parent_index="8154">0..1</paragraph>
 <paragraph index="8180" node_type="writer" parent_index="8154">item: EL_EXPRESSION</paragraph>
 <paragraph index="8183" node_type="writer" parent_index="8154">Reference to value entity. If Void, this indicates that the item in this position is Void, e.g. within a routine call parameter list.</paragraph>
 <paragraph index="8186" node_type="writer" parent_index="8154">0..1</paragraph>
 <paragraph index="8189" node_type="writer" parent_index="8154">name: String</paragraph>
 <paragraph index="8192" node_type="writer" parent_index="8154">Optional name of tuple item.</paragraph>
 <paragraph index="8195" node_type="writer" parent_index="435">10.6.32. EL_CONSTRAINED Class</paragraph>
 <object index="8196" name="Table116" object_type="table"/>
 <paragraph index="8198" node_type="writer" parent_index="8196">Class</paragraph>
 <paragraph index="8201" node_type="writer" parent_index="8196">EL_CONSTRAINED (abstract)</paragraph>
 <paragraph index="8204" node_type="writer" parent_index="8196">Description</paragraph>
 <paragraph index="8207" node_type="writer" parent_index="8196">Abstract parent for second-order constrained forms of first-order expression meta-types.</paragraph>
 <paragraph index="8210" node_type="writer" parent_index="8196">Inherit</paragraph>
 <paragraph index="8213" node_type="writer" parent_index="8196">EL_EXPRESSION</paragraph>
 <paragraph index="8216" node_type="writer" parent_index="8196">Attributes</paragraph>
 <paragraph index="8219" node_type="writer" parent_index="8196">Signature</paragraph>
 <paragraph index="8222" node_type="writer" parent_index="8196">Meaning</paragraph>
 <paragraph index="8225" node_type="writer" parent_index="8196">1..1</paragraph>
 <paragraph index="8228" node_type="writer" parent_index="8196">base_expression: EL_EXPRESSION</paragraph>
 <paragraph index="8231" node_type="writer" parent_index="8196">The base expression of this constrained form.</paragraph>
 <paragraph index="8234" node_type="writer" parent_index="435">10.6.33. EL_BOOLEAN_EXPRESSION Class</paragraph>
 <object index="8235" name="Table117" object_type="table"/>
 <paragraph index="8237" node_type="writer" parent_index="8235">Class</paragraph>
 <paragraph index="8240" node_type="writer" parent_index="8235">EL_BOOLEAN_EXPRESSION</paragraph>
 <paragraph index="8243" node_type="writer" parent_index="8235">Description</paragraph>
 <paragraph index="8246" node_type="writer" parent_index="8235">Boolean-returning expression.</paragraph>
 <paragraph index="8249" node_type="writer" parent_index="8235">Inherit</paragraph>
 <paragraph index="8252" node_type="writer" parent_index="8235">EL_CONSTRAINED</paragraph>
 <paragraph index="8255" node_type="writer" parent_index="8235">Invariants</paragraph>
 <paragraph index="8258" node_type="writer" parent_index="8235">Inv_boolean_expression: base_expression.is_boolean()</paragraph>
 <paragraph index="8261" node_type="writer" parent_index="435">11. Functional Elements</paragraph>
 <paragraph index="8262" node_type="writer" parent_index="435">11.1. Overview</paragraph>
 <paragraph index="8263" node_type="writer" parent_index="435">BMM provides support for representing functional entities, often known as lambdas. The two key functional entities are known in the calculus as a lambda term and an application. The first is more commonly understood by programmers as a delayed routine call, here denoted by the term agent. The latter is what programmers understand as a 'call', i.e. an application of a lambda term.</paragraph>
 <paragraph index="8264" node_type="writer" parent_index="435">An agent is formed by reference to a function or procedure in an expression context, potentially with provision of some or all arguments. This creates an entity whose type is an instance of the meta-type BMM_SIGNATURE. There are three variations as follows:</paragraph>
 <paragraph index="8265" node_type="writer" parent_index="435">no arguments supplied: this is just a reference to a function or procedure by name, and is typically used to pass it as an argument to some other routine;</paragraph>
 <paragraph index="8266" node_type="writer" parent_index="435">some arguments supplied: this generates a new delayed function or procedure call whose formal signature is the projection of the remaining open arguments with respect to the original signature;</paragraph>
 <paragraph index="8267" node_type="writer" parent_index="435">all arguments supplied: this generates a new fully closed delayed call that may be invoked.</paragraph>
 <paragraph index="8268" node_type="writer" parent_index="435">A call is thus an invocation of a closed agent. The evaluation type of a function call is the result type of the original function definition, thus its meta-type is just BMM_TYPE. A procedure call has no evaluation type.</paragraph>
 <paragraph index="8269" node_type="writer" parent_index="435">Both calls and agents are special kinds of references to their original routines, and both can appear within an expression context, including as arguments passed to routine invocations. The following UML view of the bmm.expression package illustrates these details.</paragraph>
 <object index="8270" name="bmm_expression_functional" object_type="section"/>
 <paragraph index="8271" node_type="writer" parent_index="8270"> </paragraph>
 <paragraph index="8272" node_type="writer" parent_index="8270">Figure 40. bmm.expression package - Functional Elements</paragraph>
 <paragraph index="8274" node_type="writer" parent_index="435">11.2. Agents</paragraph>
 <paragraph index="8275" node_type="writer" parent_index="435">In the model the three classes EL_AGENT, EL_FUNCTION_AGENT, and EL_PROCEDURE_AGENT (centre) define respectively, Agent and its Function and Procedure forms. An Agent is understood as one kind of terminal expression, since it is concretely a reference that generates a value, in this case, to a routine that generates a delayed call object. It potentially has closed_args, in the form of an EL_TUPLE which is a meta-type for tuple instances, which instantiate an instance BMM_TUPLE_TYPE (such as [String, Integer]). The items of the tuple are each in the form of an EL_TUPLE_ITEM consisting of the argument name (optional) and an item, which is an EL_EXPRESSION, having an eval_type of BMM_TYPE. By this means, the actual arguments to a routine call may be any expression, including operators, and (as shown), terminal expressions. This includes other agent expressions, and also function calls (but not procedure calls, since they are not value-generating entities).</paragraph>
 <paragraph index="8276" node_type="writer" parent_index="435">An example of a delayed function call in syntax form is nodeCount (struct=?, depth=3) (the exact syntax will vary according to programming language). Here, the struct argument is left open, while the depth argument is closed with the supplied value 3. This expression generates an agent whose signature is [StructType]:Integer (assuming the concrete type of the struct argument is StructType). This capability is known as function currying and is the basis for enabling delayed routine calls to have their arguments progressively filled before final execution, each time generating a new agent with a reduced signature.</paragraph>
 <paragraph index="8277" node_type="writer" parent_index="435">11.3. Calls</paragraph>
 <paragraph index="8278" node_type="writer" parent_index="435">On the left of the UML diagram is the meta-class EL_FUNCTION_CALL, which represents a call to a function Agent, and which is also an EL_SIMPLE. For such a call to be possible, all arguments must be supplied (which may be none, in the case of a parameterless function).</paragraph>
 <paragraph index="8279" node_type="writer" parent_index="435">An example of a Function Call is calculateAge ('1982-03-22', '2019-06-01'), which calculates a person’s age from his date of birth and a given date. In normal programming languages, any of the parameters may be any referenceable value-returning entity, i.e. any in-scope variable, other function call, or a valid operator expression, e.g. calculateAge ('1982-03-22', today()), where today() is a function returning the date of today.</paragraph>
 <paragraph index="8280" node_type="writer" parent_index="435">Such calls are direct equivalents for expressions using basic mathematical operators and functions, on the usual basis that any operator (such as 'plus', i.e. +) is formally defined as a function such as add (arg1, arg2: Numeric): Numeric.</paragraph>
 <paragraph index="8281" node_type="writer" parent_index="435">The instance structure for a typical expression such as the Body Mass Index (BMI), i.e. weight / height^2, is shown below.</paragraph>
 <object index="8282" name="bmm_nested_call" object_type="section"/>
 <paragraph index="8283" node_type="writer" parent_index="8282"> </paragraph>
 <paragraph index="8284" node_type="writer" parent_index="8282">Figure 41. Function call example - Body Mass index (BMI)</paragraph>
 <paragraph index="8286" node_type="writer" parent_index="435">12. Statements</paragraph>
 <paragraph index="8287" node_type="writer" parent_index="435">12.1. Overview</paragraph>
 <paragraph index="8288" node_type="writer" parent_index="435">BMM provides meta-model elements for defining the body of a routine, consisting of statements. This facility is not needed for achieving the original purpose of BMM, i.e. a computable in-memory representation of a model at the interface level (classes, types and signatures), rather it provides a basis for representing program logic, such as function definitions.</paragraph>
 <paragraph index="8289" node_type="writer" parent_index="435">BMM statements are formalised using the classes BMM_STATEMENT_ITEM, BMM_STATEMENT_BLOCK and BMM_STATEMENT and various descendant types, as shown in the UML view below.</paragraph>
 <object index="8290" name="LANG-statement" object_type="section"/>
 <paragraph index="8291" node_type="writer" parent_index="8290"> </paragraph>
 <paragraph index="8292" node_type="writer" parent_index="8290">Figure 42. Features for routine definition</paragraph>
 <paragraph index="8294" node_type="writer" parent_index="435">The use of the three-class hierarchy pattern allows a Routine body to be a simple statement or a block, containing statements and/or more blocks. The class BMM_STATEMENT is abstract, allowing specific statement meta-models to be developed whose 'statement' meta-types inherit from this class. A number of common types are included by default, and are described below.</paragraph>
 <paragraph index="8295" node_type="writer" parent_index="435">This facility is primarily provided to support the definition of higher-level languages by embedding them in the outer BMM meta-model.</paragraph>
 <paragraph index="8296" node_type="writer" parent_index="435">12.2. Variable Declaration</paragraph>
 <paragraph index="8297" node_type="writer" parent_index="435">Writable variables are declared using a variable declaration (BMM_DECLARATION). This may be understood as the creation of an instance of the relevant meta-type, i.e. of EL_WRITABLE_VARIABLE, that will represent the variable for all subsequent uses in the program text.</paragraph>
 <paragraph index="8298" node_type="writer" parent_index="435">12.3. Assignment</paragraph>
 <paragraph index="8299" node_type="writer" parent_index="435">A BMM assignment is the same concept as found in most frame-based programming languages, and provides a meta-model entity to represent a writable target (variable or property) being assigned to from a source, which is any expression of the same evaluation type. Type checking is thus based on a comparison of definition.type of the target and eval_type() of the source.</paragraph>
 <paragraph index="8300" node_type="writer" parent_index="435">The following example shows a simple assignment in the definition of the function position.</paragraph>
 <paragraph index="8301" node_type="writer" parent_index="435">class Simple_bank_account</paragraph>
 <paragraph index="8303" node_type="writer" parent_index="435">feature -- Definitions</paragraph>
 <paragraph index="8305" node_type="writer" parent_index="435">    overdraft_limit: Decimal = 250;</paragraph>
 <paragraph index="8307" node_type="writer" parent_index="435">feature -- State</paragraph>
 <paragraph index="8309" node_type="writer" parent_index="435">    balance: Decimal;</paragraph>
 <paragraph index="8311" node_type="writer" parent_index="435">feature -- Interface</paragraph>
 <paragraph index="8313" node_type="writer" parent_index="435">    position: Decimal {</paragraph>
 <paragraph index="8314" node_type="writer" parent_index="435">        Result := balance + overdraft_limit</paragraph>
 <paragraph index="8315" node_type="writer" parent_index="435">    }</paragraph>
 <paragraph index="8317" node_type="writer" parent_index="435">invariant</paragraph>
 <paragraph index="8318" node_type="writer" parent_index="435">    Solvent: position &gt;= 0.0</paragraph>
 <paragraph index="8319" node_type="writer" parent_index="435">The BMM meta-model for this statement is shown below.</paragraph>
 <object index="8320" name="bmm_assignment" object_type="section"/>
 <paragraph index="8321" node_type="writer" parent_index="8320"> </paragraph>
 <paragraph index="8322" node_type="writer" parent_index="8320">Figure 43. Assignment to function Result</paragraph>
 <paragraph index="8324" node_type="writer" parent_index="435">12.4. Procedure Call</paragraph>
 <paragraph index="8325" node_type="writer" parent_index="435">A procedure call is represented in BMM by the meta-type BMM_PROCEDURE_CALL, which refers to an instance of EL_PROCEDURE_AGENT, the same way that a function call is represented in terms of an EL_FUNCTION_AGENT. The effect of a procedure call is to cause an external action to be performed, such as display something on the screen, write to a database etc.</paragraph>
 <paragraph index="8326" node_type="writer" parent_index="435">In the following example, the procedure put() is called from the deposit() and withdraw() functions in the class Account_access.</paragraph>
 <paragraph index="8327" node_type="writer" parent_index="435">class Simple_bank_account</paragraph>
 <paragraph index="8329" node_type="writer" parent_index="435">feature -- Modification</paragraph>
 <paragraph index="8331" node_type="writer" parent_index="435">    put (val: Decimal)</paragraph>
 <paragraph index="8332" node_type="writer" parent_index="435">        precondition</paragraph>
 <paragraph index="8333" node_type="writer" parent_index="435">            valid_amount: val + overdraft_limit &gt;= 0.0</paragraph>
 <paragraph index="8334" node_type="writer" parent_index="435">    {</paragraph>
 <paragraph index="8335" node_type="writer" parent_index="435">        balance := balance + val</paragraph>
 <paragraph index="8336" node_type="writer" parent_index="435">    }</paragraph>
 <paragraph index="8338" node_type="writer" parent_index="435">class Account_access</paragraph>
 <paragraph index="8340" node_type="writer" parent_index="435">feature -- Command</paragraph>
 <paragraph index="8342" node_type="writer" parent_index="435">    deposit (v: Decimal; ac: Simple_bank_account)</paragraph>
 <paragraph index="8343" node_type="writer" parent_index="435">        pre_condition</paragraph>
 <paragraph index="8344" node_type="writer" parent_index="435">            valid_amount: v &gt; 0.0</paragraph>
 <paragraph index="8345" node_type="writer" parent_index="435">    {</paragraph>
 <paragraph index="8346" node_type="writer" parent_index="435">        ac.put (v);</paragraph>
 <paragraph index="8347" node_type="writer" parent_index="435">    }</paragraph>
 <paragraph index="8349" node_type="writer" parent_index="435">    withdraw (v: Decimal; ac: Simple_bank_account)</paragraph>
 <paragraph index="8350" node_type="writer" parent_index="435">        pre_condition</paragraph>
 <paragraph index="8351" node_type="writer" parent_index="435">            valid_amount: ac.overdraft_limit - v &gt;= 0.0</paragraph>
 <paragraph index="8352" node_type="writer" parent_index="435">    {</paragraph>
 <paragraph index="8353" node_type="writer" parent_index="435">        ac.put (-v);</paragraph>
 <paragraph index="8354" node_type="writer" parent_index="435">    }</paragraph>
 <paragraph index="8355" node_type="writer" parent_index="435">The BMM meta-model instance structure for the call is shown below.</paragraph>
 <object index="8356" name="bmm_procedure_call" object_type="section"/>
 <paragraph index="8357" node_type="writer" parent_index="8356"> </paragraph>
 <paragraph index="8358" node_type="writer" parent_index="8356">Figure 44. Procedure call</paragraph>
 <paragraph index="8360" node_type="writer" parent_index="435">12.5. Action Tables</paragraph>
 <paragraph index="8361" node_type="writer" parent_index="435">The BMM statement package includes the meta-classes BMM_ACTION_TABLE and BMM_CONDITIONAL_ACTION, which together provide a way of representing a decision table whose outputs are statements (rather than values, as in the case of the related Expression meta-classes EL_DECISION_TABLE and EL_CONDITIONAL_EXPRESSION). An action table corresponds closely to the standard constructs 'if/then/elseif' and the case statement.</paragraph>
 <paragraph index="8362" node_type="writer" parent_index="435">The following example shows the logic of a BMM Action table meta-type, within a procedure that generates appropriate alerts or alarms based on patient vital signs, using the standard if/then/else constrol structure.</paragraph>
 <paragraph index="8363" node_type="writer" parent_index="435">    check_vital_signs</paragraph>
 <paragraph index="8364" node_type="writer" parent_index="435">        if systolic_pressure.in_range ([critical_high])</paragraph>
 <paragraph index="8365" node_type="writer" parent_index="435">            raise_alarm ([emergency])</paragraph>
 <paragraph index="8367" node_type="writer" parent_index="435">        elseif systolic_pressure.in_range ([high]) and oxygen_sat.in_range([low])</paragraph>
 <paragraph index="8368" node_type="writer" parent_index="435">            call_staff</paragraph>
 <paragraph index="8369" node_type="writer" parent_index="435">        end</paragraph>
 <paragraph index="8370" node_type="writer" parent_index="435">    end</paragraph>
 <paragraph index="8371" node_type="writer" parent_index="435">In a functional style syntax that directly mirrors the Action table meta-model, this may be written as:</paragraph>
 <paragraph index="8372" node_type="writer" parent_index="435">    check_vital_signs</paragraph>
 <paragraph index="8373" node_type="writer" parent_index="435">        ============================================================================</paragraph>
 <paragraph index="8374" node_type="writer" parent_index="435">        systolic_pressure.in_range ([critical_high]):     raise_alarm ([emergency]),</paragraph>
 <paragraph index="8375" node_type="writer" parent_index="435">        ----------------------------------------------------------------------------</paragraph>
 <paragraph index="8376" node_type="writer" parent_index="435">        systolic_pressure.in_range ([high]) and</paragraph>
 <paragraph index="8377" node_type="writer" parent_index="435">        oxygen_sat.in_range([low]):                       call_staff</paragraph>
 <paragraph index="8378" node_type="writer" parent_index="435">        ============================================================================</paragraph>
 <paragraph index="8379" node_type="writer" parent_index="435">    end</paragraph>
 <paragraph index="8380" node_type="writer" parent_index="435">12.6. Assertions</paragraph>
 <paragraph index="8381" node_type="writer" parent_index="435">The BMM statement model includes a statement meta-type to represent the notion of an assertion as a statement, typically expressed in syntax such as assert (&lt;boolean expression&gt;). This kind of statement is understood as an executable instruction to check that the condition is true, and if not, to generate an exception of the appropriate type, assuming exceptions are available.</paragraph>
 <paragraph index="8382" node_type="writer" parent_index="435">12.7. Class Definitions</paragraph>
 <paragraph index="8383" node_type="writer" parent_index="435">12.7.1. BMM_STATEMENT_ITEM Class</paragraph>
 <object index="8384" name="Table118" object_type="table"/>
 <paragraph index="8386" node_type="writer" parent_index="8384">Class</paragraph>
 <paragraph index="8389" node_type="writer" parent_index="8384">BMM_STATEMENT_ITEM (abstract)</paragraph>
 <paragraph index="8392" node_type="writer" parent_index="8384">Description</paragraph>
 <paragraph index="8395" node_type="writer" parent_index="8384">Abstract parent of statement types representing a locally defined routine body.</paragraph>
 <paragraph index="8398" node_type="writer" parent_index="435">12.7.2. BMM_STATEMENT_BLOCK Class</paragraph>
 <object index="8399" name="Table119" object_type="table"/>
 <paragraph index="8401" node_type="writer" parent_index="8399">Class</paragraph>
 <paragraph index="8404" node_type="writer" parent_index="8399">BMM_STATEMENT_BLOCK</paragraph>
 <paragraph index="8407" node_type="writer" parent_index="8399">Description</paragraph>
 <paragraph index="8410" node_type="writer" parent_index="8399">A statement 'block' corresponding to the programming language concept of the same name. May be used to establish scope in specific languages.</paragraph>
 <paragraph index="8413" node_type="writer" parent_index="8399">Inherit</paragraph>
 <paragraph index="8416" node_type="writer" parent_index="8399">BMM_STATEMENT_ITEM</paragraph>
 <paragraph index="8419" node_type="writer" parent_index="8399">Attributes</paragraph>
 <paragraph index="8422" node_type="writer" parent_index="8399">Signature</paragraph>
 <paragraph index="8425" node_type="writer" parent_index="8399">Meaning</paragraph>
 <paragraph index="8428" node_type="writer" parent_index="8399">0..1</paragraph>
 <paragraph index="8431" node_type="writer" parent_index="8399">items: List&lt;BMM_STATEMENT_ITEM&gt;</paragraph>
 <paragraph index="8434" node_type="writer" parent_index="8399">Child blocks of the current block.</paragraph>
 <paragraph index="8437" node_type="writer" parent_index="435">12.7.3. BMM_STATEMENT Class</paragraph>
 <object index="8438" name="Table120" object_type="table"/>
 <paragraph index="8440" node_type="writer" parent_index="8438">Class</paragraph>
 <paragraph index="8443" node_type="writer" parent_index="8438">BMM_STATEMENT (abstract)</paragraph>
 <paragraph index="8446" node_type="writer" parent_index="8438">Description</paragraph>
 <paragraph index="8449" node_type="writer" parent_index="8438">Abstract parent of 'statement' types that may be defined to implement BMM Routines.</paragraph>
 <paragraph index="8452" node_type="writer" parent_index="8438">Inherit</paragraph>
 <paragraph index="8455" node_type="writer" parent_index="8438">BMM_STATEMENT_ITEM</paragraph>
 <paragraph index="8458" node_type="writer" parent_index="435">12.7.4. BMM_SIMPLE_STATEMENT Class</paragraph>
 <object index="8459" name="Table121" object_type="table"/>
 <paragraph index="8461" node_type="writer" parent_index="8459">Class</paragraph>
 <paragraph index="8464" node_type="writer" parent_index="8459">BMM_SIMPLE_STATEMENT (abstract)</paragraph>
 <paragraph index="8467" node_type="writer" parent_index="8459">Description</paragraph>
 <paragraph index="8470" node_type="writer" parent_index="8459">Simple statement, i.e. statement with one logical element - a single expression, procedure call etc.</paragraph>
 <paragraph index="8473" node_type="writer" parent_index="8459">Inherit</paragraph>
 <paragraph index="8476" node_type="writer" parent_index="8459">BMM_STATEMENT</paragraph>
 <paragraph index="8479" node_type="writer" parent_index="435">12.7.5. BMM_DECLARATION Class</paragraph>
 <object index="8480" name="Table122" object_type="table"/>
 <paragraph index="8482" node_type="writer" parent_index="8480">Class</paragraph>
 <paragraph index="8485" node_type="writer" parent_index="8480">BMM_DECLARATION</paragraph>
 <paragraph index="8488" node_type="writer" parent_index="8480">Description</paragraph>
 <paragraph index="8491" node_type="writer" parent_index="8480">Declaration of a writable variable, associating a name with a type.</paragraph>
 <paragraph index="8494" node_type="writer" parent_index="8480">Inherit</paragraph>
 <paragraph index="8497" node_type="writer" parent_index="8480">BMM_SIMPLE_STATEMENT</paragraph>
 <paragraph index="8500" node_type="writer" parent_index="8480">Attributes</paragraph>
 <paragraph index="8503" node_type="writer" parent_index="8480">Signature</paragraph>
 <paragraph index="8506" node_type="writer" parent_index="8480">Meaning</paragraph>
 <paragraph index="8509" node_type="writer" parent_index="8480">1..1</paragraph>
 <paragraph index="8512" node_type="writer" parent_index="8480">name: String</paragraph>
 <paragraph index="8518" node_type="writer" parent_index="8480">1..1</paragraph>
 <paragraph index="8521" node_type="writer" parent_index="8480">result: EL_WRITABLE_VARIABLE</paragraph>
 <paragraph index="8527" node_type="writer" parent_index="8480">1..1</paragraph>
 <paragraph index="8530" node_type="writer" parent_index="8480">type: BMM_TYPE</paragraph>
 <paragraph index="8533" node_type="writer" parent_index="8480">The declared type of the variable.</paragraph>
 <paragraph index="8536" node_type="writer" parent_index="435">12.7.6. BMM_ASSIGNMENT Class</paragraph>
 <object index="8537" name="Table123" object_type="table"/>
 <paragraph index="8539" node_type="writer" parent_index="8537">Class</paragraph>
 <paragraph index="8542" node_type="writer" parent_index="8537">BMM_ASSIGNMENT</paragraph>
 <paragraph index="8545" node_type="writer" parent_index="8537">Description</paragraph>
 <paragraph index="8548" node_type="writer" parent_index="8537">Statement type representing an assignment from a value-generating source to a writable entity, i.e. a variable reference or property.</paragraph>
 <paragraph index="8549" node_type="writer" parent_index="8537">At the meta-model level, may be understood as an initialisation of an existing meta-model instance.</paragraph>
 <paragraph index="8552" node_type="writer" parent_index="8537">Inherit</paragraph>
 <paragraph index="8555" node_type="writer" parent_index="8537">BMM_SIMPLE_STATEMENT</paragraph>
 <paragraph index="8558" node_type="writer" parent_index="8537">Attributes</paragraph>
 <paragraph index="8561" node_type="writer" parent_index="8537">Signature</paragraph>
 <paragraph index="8564" node_type="writer" parent_index="8537">Meaning</paragraph>
 <paragraph index="8567" node_type="writer" parent_index="8537">1..1</paragraph>
 <paragraph index="8570" node_type="writer" parent_index="8537">target: EL_VALUE_GENERATOR</paragraph>
 <paragraph index="8573" node_type="writer" parent_index="8537">The target variable on the notional left-hand side of this assignment.</paragraph>
 <paragraph index="8576" node_type="writer" parent_index="8537">1..1</paragraph>
 <paragraph index="8579" node_type="writer" parent_index="8537">source: EL_EXPRESSION</paragraph>
 <paragraph index="8582" node_type="writer" parent_index="8537">Source right hand side) of the assignment.</paragraph>
 <paragraph index="8585" node_type="writer" parent_index="8537">Invariants</paragraph>
 <paragraph index="8588" node_type="writer" parent_index="8537">Inv_target_writable: target.is_writable</paragraph>
 <paragraph index="8591" node_type="writer" parent_index="435">12.7.7. BMM_PROCEDURE_CALL Class</paragraph>
 <object index="8592" name="Table124" object_type="table"/>
 <paragraph index="8594" node_type="writer" parent_index="8592">Class</paragraph>
 <paragraph index="8597" node_type="writer" parent_index="8592">BMM_PROCEDURE_CALL</paragraph>
 <paragraph index="8600" node_type="writer" parent_index="8592">Description</paragraph>
 <paragraph index="8603" node_type="writer" parent_index="8592">A call made on a closed procedure agent. The method in BMM via which external actions are achieved from within a program.</paragraph>
 <paragraph index="8606" node_type="writer" parent_index="8592">Inherit</paragraph>
 <paragraph index="8609" node_type="writer" parent_index="8592">EL_AGENT_CALL, BMM_SIMPLE_STATEMENT</paragraph>
 <paragraph index="8612" node_type="writer" parent_index="8592">Attributes</paragraph>
 <paragraph index="8615" node_type="writer" parent_index="8592">Signature</paragraph>
 <paragraph index="8618" node_type="writer" parent_index="8592">Meaning</paragraph>
 <paragraph index="8621" node_type="writer" parent_index="8592">1..1
(redefined)</paragraph>
 <paragraph index="8624" node_type="writer" parent_index="8592">agent: EL_PROCEDURE_AGENT</paragraph>
 <paragraph index="8627" node_type="writer" parent_index="8592">The procedure agent being called.</paragraph>
 <paragraph index="8630" node_type="writer" parent_index="8592">Invariants</paragraph>
 <paragraph index="8633" node_type="writer" parent_index="8592">Inv_valid_agent: agent.is_callable()</paragraph>
 <paragraph index="8636" node_type="writer" parent_index="435">12.7.8. BMM_ASSERTION Class</paragraph>
 <object index="8637" name="Table125" object_type="table"/>
 <paragraph index="8639" node_type="writer" parent_index="8637">Class</paragraph>
 <paragraph index="8642" node_type="writer" parent_index="8637">BMM_ASSERTION</paragraph>
 <paragraph index="8645" node_type="writer" parent_index="8637">Description</paragraph>
 <paragraph index="8648" node_type="writer" parent_index="8637">A statement that asserts the truth of its expression. If the expression evaluates to False the execution generates an exception (depending on run-time settings).</paragraph>
 <paragraph index="8649" node_type="writer" parent_index="8637">May be rendered in syntax as assert condition or similar.</paragraph>
 <paragraph index="8652" node_type="writer" parent_index="8637">Inherit</paragraph>
 <paragraph index="8655" node_type="writer" parent_index="8637">BMM_SIMPLE_STATEMENT</paragraph>
 <paragraph index="8658" node_type="writer" parent_index="8637">Attributes</paragraph>
 <paragraph index="8661" node_type="writer" parent_index="8637">Signature</paragraph>
 <paragraph index="8664" node_type="writer" parent_index="8637">Meaning</paragraph>
 <paragraph index="8667" node_type="writer" parent_index="8637">1..1</paragraph>
 <paragraph index="8670" node_type="writer" parent_index="8637">expression: EL_BOOLEAN_EXPRESSION</paragraph>
 <paragraph index="8673" node_type="writer" parent_index="8637">Boolean-valued expression of the assertion.</paragraph>
 <paragraph index="8676" node_type="writer" parent_index="8637">0..1</paragraph>
 <paragraph index="8679" node_type="writer" parent_index="8637">tag: String</paragraph>
 <paragraph index="8682" node_type="writer" parent_index="8637">Optional tag, typically used to designate design intention of the assertion, e.g. &quot;Inv_all_members_valid&quot;.</paragraph>
 <paragraph index="8685" node_type="writer" parent_index="435">12.7.9. BMM_ACTION_TABLE Class</paragraph>
 <object index="8686" name="Table126" object_type="table"/>
 <paragraph index="8688" node_type="writer" parent_index="8686">Class</paragraph>
 <paragraph index="8691" node_type="writer" parent_index="8686">BMM_ACTION_TABLE</paragraph>
 <paragraph index="8694" node_type="writer" parent_index="8686">Description</paragraph>
 <paragraph index="8697" node_type="writer" parent_index="8686">Multi-branch conditional statement structure</paragraph>
 <paragraph index="8700" node_type="writer" parent_index="8686">Inherit</paragraph>
 <paragraph index="8703" node_type="writer" parent_index="8686">BMM_STATEMENT</paragraph>
 <paragraph index="8706" node_type="writer" parent_index="8686">Attributes</paragraph>
 <paragraph index="8709" node_type="writer" parent_index="8686">Signature</paragraph>
 <paragraph index="8712" node_type="writer" parent_index="8686">Meaning</paragraph>
 <paragraph index="8715" node_type="writer" parent_index="8686">1..1</paragraph>
 <paragraph index="8718" node_type="writer" parent_index="8686">decision_table: BMM_ACTION_DECISION_TABLE</paragraph>
 <paragraph index="8721" node_type="writer" parent_index="8686">A specialised decision table whose outputs can only be procedure agents. In execution, the matched agent will be invoked.</paragraph>
 <paragraph index="8724" node_type="writer" parent_index="435">12.7.10. BMM_ACTION_DECISION_TABLE Class</paragraph>
 <object index="8725" name="Table127" object_type="table"/>
 <paragraph index="8727" node_type="writer" parent_index="8725">Class</paragraph>
 <paragraph index="8730" node_type="writer" parent_index="8725">BMM_ACTION_DECISION_TABLE</paragraph>
 <paragraph index="8733" node_type="writer" parent_index="8725">Description</paragraph>
 <paragraph index="8736" node_type="writer" parent_index="8725">Specialised form of Decision Table that allows only procedure call agents (lambdas) as the result of branches.</paragraph>
 <paragraph index="8739" node_type="writer" parent_index="435">13. Model Semantics</paragraph>
 <paragraph index="8740" node_type="writer" parent_index="435">This section describes various semantics that apply at a whole-of-model level rather than within single entities such as a class, type or property.</paragraph>
 <paragraph index="8741" node_type="writer" parent_index="435">13.1. Inheritance</paragraph>
 <paragraph index="8742" node_type="writer" parent_index="435">13.1.1. Simple Inheritance</paragraph>
 <paragraph index="8743" node_type="writer" parent_index="435">The BMM supports single and multiple inheritance, although it does not distinguish between different types of inheritance relation as some programming languages do. Inheritance is formally defined to be between a class definition (an instance of BMM_CLASS) and a defined type, i.e. a BMM_SIMPLE_TYPE or BMM_GENERIC_TYPE. This is because the inheritance parents of a class may be any of:</paragraph>
 <paragraph index="8744" node_type="writer" parent_index="435">a simple class;</paragraph>
 <paragraph index="8745" node_type="writer" parent_index="435">a generic class;</paragraph>
 <paragraph index="8746" node_type="writer" parent_index="435">a class type, i.e. the effective class definition corresponding to an effective generic type, which has one or more formal parameters substituted.</paragraph>
 <paragraph index="8747" node_type="writer" parent_index="435">The general case for all three is represented by the corresponding type, i.e., a simple type or generic type.</paragraph>
 <paragraph index="8748" node_type="writer" parent_index="435">The evaluation of inheritance relations defined in a BMM model results in an acyclic graph such that ancestors and descendants can be visualised for any class. The following screen shot shows the ancestors view of a class OBSERVATION.</paragraph>
 <object index="8749" name="awb_class_ancestors" object_type="section"/>
 <paragraph index="8750" node_type="writer" parent_index="8749"> </paragraph>
 <paragraph index="8751" node_type="writer" parent_index="8749">Figure 45. BMM class - ancestors view</paragraph>
 <paragraph index="8753" node_type="writer" parent_index="435">The next screenshot shows the descendants view of one of the ancestor classes of the same class.</paragraph>
 <object index="8754" name="awb_class_descendants" object_type="section"/>
 <paragraph index="8755" node_type="writer" parent_index="8754"> </paragraph>
 <paragraph index="8756" node_type="writer" parent_index="8754">Figure 46. BMM class - descendants view</paragraph>
 <paragraph index="8758" node_type="writer" parent_index="435">13.1.2. Generic Inheritance</paragraph>
 <paragraph index="8759" node_type="writer" parent_index="435">Inheritance between generic classes works in the same way as for simple classes, with the additional semantics of formal parameter inheritance, which are as follows:</paragraph>
 <paragraph index="8760" node_type="writer" parent_index="435">each unsubstituted formal parameter of the parent type must have a same-named counterpart in the formal parameters of the inheriting class;</paragraph>
 <paragraph index="8761" node_type="writer" parent_index="435">the formal parameters of the inheriting class may further constrain any of the ancestor type’s formal parameters.</paragraph>
 <paragraph index="8762" node_type="writer" parent_index="435">The following example shows the class DV_INTERVAL&lt;T:DV_ORDERED&gt; inheriting from Interval&lt;T:Ordered&gt;. Here the number of open generic parameters remains unchanged, while the type constraint Ordered is covariantly narrowed to DV_ORDERED, which inherits from the Ordered type.</paragraph>
 <object index="8763" name="awb_generic_inheritance_constraint_narrowing" object_type="section"/>
 <paragraph index="8764" node_type="writer" parent_index="8763"> </paragraph>
 <paragraph index="8765" node_type="writer" parent_index="8763">Figure 47. Generic inheritance, constraint-narrowing</paragraph>
 <paragraph index="8767" node_type="writer" parent_index="435">The resulting types of lower and upper are now T:DV_ORDERED rather than T:Ordered from the parent. In the fully computed model shown above, these two properties are synthesised within DV_INTERVAL&lt;T&gt; with their new concrete types. Their BMM meta-type objects (type BMM_UNITARY_PROPERTY) will both have the meta-attribute is_synthesised_generic set to True and are marked with an asterisk within the property view to indicate this.</paragraph>
 <paragraph index="8768" node_type="writer" parent_index="435">A simple class may also inherit from a closed generic type, with the parameters of the latter fixed to specific type(s), as shown in the following example.</paragraph>
 <object index="8769" name="awb_generic_inheritance_closed" object_type="section"/>
 <paragraph index="8770" node_type="writer" parent_index="8769"> </paragraph>
 <paragraph index="8771" node_type="writer" parent_index="8769">Figure 48. Generic inheritance, closed</paragraph>
 <paragraph index="8773" node_type="writer" parent_index="435">In this case, The resulting type of event is TIMER_EVENT rather than T:EVENT from the parent. As in the previous example, this property has been synthesised new within TIMER_WAIT, with the meta-attribute is_synthesised_generic set True and is marked accordingly within the tool.</paragraph>
 <paragraph index="8774" node_type="writer" parent_index="435">The general case is that any number of formal generic parameters may be substituted or left open down the inheritance lineage, as shown by the variant descendants of the class GENERIC_PARENT&lt;T:SUPPLIER, U:SUPPLIER&gt; in the following example.</paragraph>
 <object index="8775" name="awb_generic_inheritance_mixed" object_type="section"/>
 <paragraph index="8776" node_type="writer" parent_index="8775"> </paragraph>
 <paragraph index="8777" node_type="writer" parent_index="8775">Figure 49. Generic inheritance, mixed open and closed</paragraph>
 <paragraph index="8779" node_type="writer" parent_index="435">Generic substitution may be with other open, closed or partly-closed generic types. The following example illustrates the inheritance by X_VERSIONED_COMPOSITION of X_VERSIONED_COMPOSITION&lt;ORIGINAL_VERSION&lt;COMPOSITION&gt;&gt;.</paragraph>
 <object index="8780" name="awb_generic_inheritance" object_type="section"/>
 <paragraph index="8781" node_type="writer" parent_index="8780"> </paragraph>
 <paragraph index="8782" node_type="writer" parent_index="8780">Figure 50. Generic inheritance, open parameter</paragraph>
 <paragraph index="8784" node_type="writer" parent_index="435">13.1.3. Multiple Inheritance</paragraph>
 <paragraph index="8785" node_type="writer" parent_index="435">Multiple inheritance is typically used in the definition of classes that have a Liskov substitution inheritance relation as well as a re-use inheritance relation. The following shows a class DV_INTERVAL&lt;T&gt; multiply inheriting from Interval&lt;T&gt; and DATA_VALUE, where the latter is considered the substitutable type, and the former an interface re-use.</paragraph>
 <object index="8786" name="awb_multiple_inheritance" object_type="section"/>
 <paragraph index="8787" node_type="writer" parent_index="8786"> </paragraph>
 <paragraph index="8788" node_type="writer" parent_index="8786">Figure 51. Multiple inheritance</paragraph>
 <paragraph index="8790" node_type="writer" parent_index="435">13.1.4. Inheritance and Invariants, Pre-conditions and Post-conditions</paragraph>
 <paragraph index="8791" node_type="writer" parent_index="435">TBD</paragraph>
 <paragraph index="8792" node_type="writer" parent_index="435">14. BMM Extensions</paragraph>
 <paragraph index="8793" node_type="writer" parent_index="435">14.1. Overview</paragraph>
 <paragraph index="8794" node_type="writer" parent_index="435">14.2. General Extensions</paragraph>
 <paragraph index="8795" node_type="writer" parent_index="435">14.3. Feature Extensions</paragraph>
 <paragraph index="8796" node_type="writer" parent_index="435">References</paragraph>
 <paragraph index="8797" node_type="writer" parent_index="435">Dijkstra, E. W. (1976). A discipline of programming. Prentice-Hall Englewood Cliffs, N.J.</paragraph>
 <paragraph index="8798" node_type="writer" parent_index="435">Meyer, B. (1997). Object-oriented Software Construction (Second.). Prentice Hall.</paragraph>
 <paragraph index="8799" node_type="writer" parent_index="435">Smith, G. (2000). The Object Z Specification Language. Kluwer Academic Publishers. Retrieved from http://www.itee.uq.edu.au/ smith/objectz.html</paragraph>
 <object index="8801" name="footer" object_type="section"/>
 <object index="8803" name="footer-text" object_type="section"/>
 <paragraph index="8804" node_type="writer" parent_index="8803">Last updated 2022-12-18 23:34:47 UTC </paragraph>
</indexing>
